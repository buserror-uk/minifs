diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 0ed36cd..e3e760d 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -144,11 +144,42 @@ config USE_ARCH_MEMSET
 	  Such implementation may be faster under some conditions
 	  but may increase the binary size.
 
+config SPL_USE_ARCH_MEMCPY
+	bool "Use an assembly optimized implementation of memcpy for SPL"
+	default n
+
+config SPL_USE_ARCH_MEMSET
+	bool "Use an assembly optimized implementation of memcset for SPL"
+	default n
+
 config ARCH_OMAP2
 	bool
 	select CPU_V7
 	select SUPPORT_SPL
 
+config ARCH_RZN1
+	bool
+	select CADENCE_QSPI if SPI_FLASH
+	select CADENCE_QSPI_MMAP if SPI_FLASH
+	select CMD_SF if SPI_FLASH
+	select OF_CONTROL
+	select DM
+	select DM_GPIO
+	select DM_I2C
+	select DM_MMC
+	select DM_SERIAL
+	select DM_SPI
+	select DM_SPI_FLASH
+	select DWAPB_GPIO
+	select SPL_DM if SPL
+	select SPL_LIBCOMMON_SUPPORT if SPL
+	select SPL_LIBGENERIC_SUPPORT if SPL
+	select SPL_OF_CONTROL if SPL
+	select SPL_SYS_MALLOC_SIMPLE if SPL
+	select SYS_I2C_DW
+	select SYS_NS16550
+	select USB_GADGET_RZN1 if USB_GADGET
+
 config ARM64_SUPPORT_AARCH32
 	bool "ARM64 system support AArch32 execution state"
 	default y if ARM64 && !TARGET_THUNDERX_88XX
@@ -543,6 +574,28 @@ config ARCH_RMOBILE
 	select DM
 	select DM_SERIAL
 
+config ARCH_RZN1D
+	bool "Renesas RZ/N1D SoCs"
+	select ARCH_RZN1
+	select CPU_V7
+	select CPU_V7_HAS_NONSEC
+	select CPU_V7_HAS_VIRT
+	select SUPPORT_SPL
+
+config ARCH_RZN1S
+	bool "Renesas RZ/N1S SoCs"
+	select ARCH_RZN1
+	select CPU_V7
+	select CPU_V7_HAS_NONSEC
+	select CPU_V7_HAS_VIRT
+	select SUPPORT_SPL
+
+config ARCH_RZN1L
+	bool "Renesas RZ/N1L Cortex M3 SoCs"
+	select ARCH_RZN1
+	select CPU_V7M
+	select SUPPORT_SPL
+
 config TARGET_S32V234EVB
 	bool "Support s32v234evb"
 	select ARM64
@@ -949,6 +1002,8 @@ source "arch/arm/cpu/armv7/mx5/Kconfig"
 
 source "arch/arm/mach-omap2/Kconfig"
 
+source "arch/arm/cpu/armv7/rzn1/Kconfig"
+
 source "arch/arm/cpu/armv8/fsl-layerscape/Kconfig"
 
 source "arch/arm/mach-orion5x/Kconfig"
diff --git a/arch/arm/cpu/armv7/Kconfig b/arch/arm/cpu/armv7/Kconfig
index b9c4f4e..e120adf 100644
--- a/arch/arm/cpu/armv7/Kconfig
+++ b/arch/arm/cpu/armv7/Kconfig
@@ -32,7 +32,9 @@ config ARMV7_VIRT
 	depends on CPU_V7_HAS_VIRT && ARMV7_NONSEC
 	default y
 	---help---
-	Say Y here to boot in hypervisor (HYP) mode when booting non-secure.
+	Say Y here to optionally boot in hypervisor (HYP) mode when booting non-secure.
+	U-Boot will look for the boot_hyp env variable, and will only switch to
+	HYP if this variable is set to "yes".
 
 config ARMV7_PSCI
 	bool "Enable PSCI support" if EXPERT
diff --git a/arch/arm/cpu/armv7/Makefile b/arch/arm/cpu/armv7/Makefile
index 0e515a4..cb3c6b1 100644
--- a/arch/arm/cpu/armv7/Makefile
+++ b/arch/arm/cpu/armv7/Makefile
@@ -38,6 +38,7 @@ obj-$(if $(filter mx5,$(SOC)),y) += mx5/
 obj-$(CONFIG_MX6) += mx6/
 obj-$(CONFIG_MX7) += mx7/
 obj-$(CONFIG_RMOBILE) += rmobile/
+obj-$(CONFIG_ARCH_RZN1) += rzn1/
 obj-$(if $(filter stv0991,$(SOC)),y) += stv0991/
 obj-$(CONFIG_ARCH_SUNXI) += sunxi/
 obj-$(CONFIG_VF610) += vf610/
diff --git a/arch/arm/cpu/armv7/nonsec_virt.S b/arch/arm/cpu/armv7/nonsec_virt.S
index 95ce938..4009ff2 100644
--- a/arch/arm/cpu/armv7/nonsec_virt.S
+++ b/arch/arm/cpu/armv7/nonsec_virt.S
@@ -79,8 +79,13 @@ _secure_monitor:
 	mov	r6, #SVC_MODE			@ default mode is SVC
 	is_cpu_virt_capable r4
 #ifdef CONFIG_ARMV7_VIRT
+	bne	_skip_hyp			@ Don't hyp if not asked to
+	ldr	r7, =nonsec_and_hyp		@ Get the global
+	ldr	r7, [r7]
+	cmp	r7, #1
 	orreq	r5, r5, #0x100			@ allow HVC instruction
 	moveq	r6, #HYP_MODE			@ Enter the kernel as HYP
+_skip_hyp:
 #endif
 
 	mcr	p15, 0, r5, c1, c1, 0		@ write SCR (with NS bit set)
@@ -102,6 +107,10 @@ _secure_monitor:
 	msr	spsr_cxfs, ip			@ Set full SPSR
 	movs	pc, lr				@ ERET to non-secure
 
+	.globl 	nonsec_and_hyp
+nonsec_and_hyp:
+	.word 0
+
 ENTRY(_do_nonsec_entry)
 	mov	ip, r0
 	mov	r0, r1
@@ -207,7 +216,11 @@ ENDPROC(_nonsec_init)
 #ifdef CONFIG_SMP_PEN_ADDR
 /* void __weak smp_waitloop(unsigned previous_address); */
 ENTRY(smp_waitloop)
+#ifdef CONFIG_SMP_PEN_WFE
+	wfe
+#else
 	wfi
+#endif
 	ldr	r1, =CONFIG_SMP_PEN_ADDR	@ load start address
 	ldr	r1, [r1]
 #ifdef CONFIG_PEN_ADDR_BIG_ENDIAN
diff --git a/arch/arm/cpu/armv7/rzn1/Kconfig b/arch/arm/cpu/armv7/rzn1/Kconfig
new file mode 100644
index 0000000..d477a75
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/Kconfig
@@ -0,0 +1,30 @@
+if ARCH_RZN1
+
+config RZN1D
+	bool
+	default y
+
+config RZN1S
+	bool
+
+choice
+	prompt "RZN1 board select"
+	optional
+
+config TARGET_RENESAS_RZN1D400_DB
+	bool "Renesas rzn1d400-db"
+	select SUPPORT_SPL
+
+config TARGET_RENESAS_RZN1S324_DB
+	bool "Renesas rzn1s324-db"
+	select SUPPORT_SPL
+
+endchoice
+
+config SYS_SOC
+	default "rzn1"
+
+source "board/renesas/rzn1d400-db/Kconfig"
+source "board/renesas/rzn1s324-db/Kconfig"
+
+endif
diff --git a/arch/arm/cpu/armv7/rzn1/Makefile b/arch/arm/cpu/armv7/rzn1/Makefile
new file mode 100644
index 0000000..dcdc6b8
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/Makefile
@@ -0,0 +1,10 @@
+#
+# (C) Copyright 2015 Renesas Electronics Europe Ltd
+#
+# SPDX-License-Identifier:     GPL-2.0+
+#
+
+obj-y	:= cpu.o clock.o pinmux.o ipcm.o
+obj-$(CONFIG_SPL_BUILD)		+= spl.o
+obj-$(CONFIG_CADENCE_DDR_CTRL)	+= ddr_phy.o
+obj-$(CONFIG_NET)		+= eth.o
diff --git a/arch/arm/cpu/armv7/rzn1/clock.c b/arch/arm/cpu/armv7/rzn1/clock.c
new file mode 100644
index 0000000..d73acc0
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/clock.c
@@ -0,0 +1,132 @@
+/*
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier:	BSD-2-Clause
+ */
+#include <asm/io.h>
+#include <common.h>
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-utils.h"
+#include "renesas/rzn1-clocks.h"
+
+/* Generic register/bit group descriptor */
+struct rzn1_onereg {
+	uint16_t reg : 7,	/* Register number (word) */
+		pos : 5,	/* Bit number */
+		size : 4;	/* Optional: size in bits */
+} __attribute__((packed));
+
+struct rzn1_clkdesc {
+	struct rzn1_onereg clock, reset, ready, masteridle, scon, mirack, mistat;
+} __attribute__((packed));
+
+#define _BIT(_r, _p) { .reg = _r, .pos = _p }
+
+#define _CLK(_n, _clk, _rst, _rdy, _midle, _scon, _mirack, _mistat) \
+	{ .clock = _clk, .reset = _rst, .ready = _rdy, .masteridle = _midle, \
+	  .scon = _scon, .mirack = _mirack, .mistat = _mistat }
+
+#include "renesas/rzn1-clkctrl-tables.h"
+
+#define clk_readl readl
+#define clk_writel writel
+
+static void *clk_mgr_base_addr = (void *)RZN1_SYSTEM_CTRL_BASE;
+
+static void clk_mgr_desc_set(const struct rzn1_onereg *one, int on)
+{
+	u32 *reg = ((u32 *)clk_mgr_base_addr) + one->reg;
+	u32 val = clk_readl(reg);
+	val = (val & ~(1 << one->pos)) | ((!!on) << one->pos);
+	clk_writel(val, reg);
+}
+
+static u32 clk_mgr_desc_get(const struct rzn1_onereg *one)
+{
+	u32 *reg = ((u32 *)clk_mgr_base_addr) + one->reg;
+	u32 val = clk_readl(reg);
+	val = (val >> one->pos) & 1;
+	return val;
+}
+
+int rzn1_clk_set_gate(int clkdesc_id, int on)
+{
+	const struct rzn1_clkdesc *g = &rzn1_clock_list[clkdesc_id];
+	u32 timeout;
+
+	BUG_ON(!clk_mgr_base_addr);
+	BUG_ON(!g->clock.reg);
+
+	if (!on && g->masteridle.reg) {
+		/* Set 'Master Idle Request' bit */
+		clk_mgr_desc_set(&g->masteridle, 1);
+
+		/* Wait for Master Idle Request acknowledge */
+		if (g->mirack.reg) {
+			for (timeout = 100000; timeout &&
+				!clk_mgr_desc_get(&g->mirack); timeout--)
+					;
+			if (!timeout)
+				return -1;
+		}
+
+		/* Wait for Master Idle Status signal */
+		if (g->mistat.reg) {
+			for (timeout = 100000; timeout &&
+				!clk_mgr_desc_get(&g->mistat); timeout--)
+					;
+			if (!timeout)
+				return -1;
+		}
+	}
+
+	/* Enable/disable the clock */
+	clk_mgr_desc_set(&g->clock, on);
+
+	/* If the peripheral is memory mapped (i.e. an AXI slave), there is an
+	 * associated SLVRDY bit in the System Controller that needs to be set
+	 * so that the FlexWAY bus fabric passes on the read/write requests.
+	 */
+	if (g->ready.reg)
+		clk_mgr_desc_set(&g->ready, on);
+
+	/* Clear 'Master Idle Request' bit */
+	if (g->masteridle.reg)
+		clk_mgr_desc_set(&g->masteridle, !on);
+
+	/* Wait for FlexWAY Socket Connection signal */
+	if (on && g->scon.reg) {
+		for (timeout = 100000; timeout &&
+			!clk_mgr_desc_get(&g->scon); timeout--)
+				;
+		if (!timeout)
+			return -1;
+	}
+
+	return 0;
+}
+
+void rzn1_clk_reset(int clkdesc_id)
+{
+	const struct rzn1_clkdesc *g = &rzn1_clock_list[clkdesc_id];
+
+	BUG_ON(!clk_mgr_base_addr);
+	BUG_ON(!g->clock.reg);
+
+	if (g->reset.reg) {
+		clk_mgr_desc_set(&g->reset, 0);
+		udelay(1);
+		clk_mgr_desc_set(&g->reset, 1);
+	}
+}
+
+void rzn1_clk_reset_state(int clkdesc_id, int level)
+{
+	const struct rzn1_clkdesc *g = &rzn1_clock_list[clkdesc_id];
+
+	BUG_ON(!clk_mgr_base_addr);
+	BUG_ON(!g->clock.reg);
+
+	if (g->reset.reg)
+		clk_mgr_desc_set(&g->reset, level);
+}
diff --git a/arch/arm/cpu/armv7/rzn1/cpu.c b/arch/arm/cpu/armv7/rzn1/cpu.c
new file mode 100644
index 0000000..8f1f58a
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/cpu.c
@@ -0,0 +1,304 @@
+/*
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier:	BSD-2-Clause
+ */
+#include <common.h>
+#include <cadence_ddr_ctrl.h>
+#include <asm/armv7.h>
+#include <asm/io.h>
+#include <usb.h>
+#include "ipcm.h"
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-utils.h"
+#include "renesas/rzn1-clocks.h"
+#include "renesas/rzn1-sysctrl.h"
+
+void lowlevel_init(void)
+{
+}
+
+void rzn1_sysctrl_div(u32 reg, u32 div)
+{
+	/* Wait for busy bit to be cleared */
+	while (sysctrl_readl(reg) & (1 << 31))
+		;
+
+	/* New divider setting */
+	sysctrl_writel((1 << 31) | div, reg);
+
+	/* Wait for busy bit to be cleared */
+	while (sysctrl_readl(reg) & (1 << 31))
+		;
+}
+
+void rzn1_setup_pinmux(void);
+
+int arch_cpu_init(void)
+{
+	/* 500MHz clock input to the CPU clock divider */
+	rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV, 1);
+
+	/* Setup clocks to IP blocks, all are divided down from a 1GHz PLL */
+
+	rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV, 1000000000 / CONFIG_SYS_NS16550_CLK);
+
+	rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV, 1000000000 / CONFIG_SYS_NAND_CLOCK);
+
+	rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV, 1000000000 / CONFIG_CQSPI_REF_CLK);
+
+	if (!is_rzn1d())
+		rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV, 1000000000 / CONFIG_CQSPI_REF_CLK);
+
+	rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV, 1000 / IC_CLK);
+
+	rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV, 1000/SDHC_CLK_MHZ);
+	rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV, 1000/SDHC_CLK_MHZ);
+	sysctrl_writel(SDHC_CLK_MHZ, RZN1_SYSCTRL_REG_CFG_SDIO0);
+	sysctrl_writel(SDHC_CLK_MHZ, RZN1_SYSCTRL_REG_CFG_SDIO1);
+
+	/* Enable pinmux clocks and FlexWAY connection for UART */
+	rzn1_clk_set_gate(RZN1_HCLK_PINCONFIG_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_GPIO0_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_GPIO1_ID, 1);
+
+	/* Enable UART clock and FlexWAY connection */
+#if (CONFIG_CONS_INDEX == 1)
+	rzn1_clk_set_gate(RZN1_HCLK_UART0_ID, 1);
+	rzn1_clk_set_gate(RZN1_CLK_UART0_ID, 1);
+#elif (CONFIG_CONS_INDEX == 2)
+	rzn1_clk_set_gate(RZN1_HCLK_UART1_ID, 1);
+	rzn1_clk_set_gate(RZN1_CLK_UART1_ID, 1);
+#elif (CONFIG_CONS_INDEX == 3)
+	rzn1_clk_set_gate(RZN1_HCLK_UART2_ID, 1);
+	rzn1_clk_set_gate(RZN1_CLK_UART2_ID, 1);
+#endif
+	rzn1_setup_pinmux();
+
+	return 0;
+}
+
+/* Configure clocks for the USB blocks and reset IP */
+int rzn1_usb_init(int index, enum usb_init_type init)
+{
+#define USBFUNC_EPCTR		(RZN1_USB_DEV_BASE + 0x1000 + 0x10)
+
+	u32 val;
+
+	/* Enable USB clocks */
+	rzn1_clk_set_gate(RZN1_HCLK_USBPM_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_USBF_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_USBH_ID, 1);
+
+	/* USB Host clocks */
+	rzn1_clk_set_gate(RZN1_CLK_PCI_USB_ID, 1);
+	rzn1_clk_set_gate(RZN1_CLK_48MHZ_PG_F_ID, 1);
+
+	/*
+	 * Enable USB on port 1 as the Linux kernel doesn't deal with
+	 * these irregular register bits
+	 */
+	val = sysctrl_readl(RZN1_SYSCTRL_REG_CFG_USB);
+	val |= (1 << RZN1_SYSCTRL_REG_CFG_USB_DIRPD);
+	val |= (1 << RZN1_SYSCTRL_REG_CFG_USB_FRCLK48MOD);
+	if (index == 0 && init == USB_INIT_HOST)
+		val |= (1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE);
+	sysctrl_writel(val, RZN1_SYSCTRL_REG_CFG_USB);
+
+	/* Hold USBF in reset */
+	writel(5, USBFUNC_EPCTR);
+	udelay(100);
+
+	/* Power up USB PLL */
+	val = sysctrl_readl(RZN1_SYSCTRL_REG_CFG_USB);
+	val &= ~(1 << RZN1_SYSCTRL_REG_CFG_USB_DIRPD);
+	sysctrl_writel(val, RZN1_SYSCTRL_REG_CFG_USB);
+	udelay(100000);
+
+	/* Release USBF resets */
+	writel(0, USBFUNC_EPCTR);
+
+	/* Wait for USB PLL lock */
+	do {
+		val = sysctrl_readl(RZN1_SYSCTRL_REG_USBSTAT);
+	} while (!(val & (1 << RZN1_SYSCTRL_REG_USBSTAT_PLL_LOCK)));
+
+	return 0;
+}
+
+void reset_cpu(ulong addr)
+{
+	sysctrl_writel((1 << RZN1_SYSCTRL_REG_RSTEN_SWRST_EN) | (1 << RZN1_SYSCTRL_REG_RSTEN_MRESET_EN),
+			RZN1_SYSCTRL_REG_RSTEN);
+	sysctrl_writel((1 << RZN1_SYSCTRL_REG_RSTCTRL_SWRST_REQ), RZN1_SYSCTRL_REG_RSTCTRL);
+
+	while (1)
+		;
+}
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+void post_mmu_setup(void)
+{
+	/* Set on-chip SRAMs & QSPI as cached, but set them to write-through */
+	mmu_set_region_dcache_behaviour(RZN1_SRAM_ID_BASE,
+					RZN1_SRAM_ID_SIZE,
+					DCACHE_WRITETHROUGH);
+	mmu_set_region_dcache_behaviour(RZN1_SRAM_SYS_BASE,
+					RZN1_SRAM_SYS_SIZE,
+					DCACHE_WRITETHROUGH);
+	mmu_set_region_dcache_behaviour(RZN1_V_QSPI_BASE,
+					RZN1_V_QSPI_SIZE,
+					DCACHE_WRITETHROUGH);
+	if (!is_rzn1d()) {
+		mmu_set_region_dcache_behaviour(RZN1_V_QSPI1_BASE,
+					RZN1_V_QSPI1_SIZE,
+					DCACHE_WRITETHROUGH);
+	}
+}
+
+void enable_caches(void)
+{
+	/* Enable D-cache. I-cache is already enabled in start.S */
+	dcache_enable();
+}
+#endif
+
+#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
+#include <asm/secure.h>
+/* This is the location the smp_pen code will loop onto to find it's
+ * boot address. The address of /this/ variable is passed down to the
+ * kernel via the /chosen/rzn1,bootaddr property for the kernel to
+ * take over the parked core */
+u32 smp_secondary_bootaddr[10] __secure_data = { 0, 0x525a4e31 };
+
+/* Setting the address at which secondary core starts from */
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+	debug("%s: writing %08lx to SYSCTRL reg and 2nd bootaddr (%08x)\n",
+		__func__, addr, (u32)smp_secondary_bootaddr);
+
+	/*
+	 * To protect against spurious wake up events, the smp_waitloop will go
+	 * back into wfi/wfe if the jump address is the the address of where it
+	 * got the jump address. In our case, the jump address is stored in
+	 * smp_secondary_bootaddr[0], so that's why we set it here.
+	 */
+	smp_secondary_bootaddr[0] = addr;
+	flush_dcache_all();
+
+	/* BootROM holding pen */
+	writel(addr, RZN1_SYSTEM_CTRL_BASE + RZN1_SYSCTRL_REG_BOOTADDR);
+}
+
+#endif
+
+#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
+#include <fdt_support.h>
+
+/* this allows rzn1 boards to override and add properties */
+int __weak __ft_board_setup(void *blob, bd_t *bd)
+{
+	return 0;
+}
+
+/* This function updates the Device Tree that is passed to Linux for starting
+ * up core 1 (SMP). Note that full U-Boot may or may not switch to NONSEC, or
+ * NONSEC+HYP, depending on env variables.
+ */
+int ft_board_setup(void *blob, bd_t *bd)
+{
+#if defined(CONFIG_ARMV7_NONSEC)
+#if !defined(CONFIG_SPL_BUILD)
+	if (!armv7_boot_nonsec())
+		return 0;
+#endif
+
+	u32 bootaddr = htonl((u32)smp_secondary_bootaddr);
+
+	__ft_board_setup(blob, bd);
+
+	fdt_find_and_setprop(blob, "/chosen", "rzn1,bootaddr",
+			     &bootaddr, sizeof(bootaddr), 1);
+#endif
+	return 0;
+}
+#endif
+
+#define IPC_TX_MBOX		1
+#define IPC_RX_MBOX		0
+
+struct ipc_msg {
+	uint32_t	msg_type;	/* Number to allow different msgs */
+	uint32_t	wait_rsp;
+	uint32_t	env_ptr;
+	uint32_t	pad[4];
+};
+
+void rzn1_ddr_ctrl_init(const u32 *reg0, const u32 *reg350, u32 ddr_size)
+{
+	u32 ddr_start_addr = 0;
+
+	/*
+	 * On ES1.0 devices, the DDR start address that the DDR Controller sees
+	 * is the physical address of the DDR. However, later devices changed it
+	 * to be 0 in order to fix an issue with DDR out-of-range detection.
+	 */
+	if (sysctrl_readl(RZN1_SYSCTRL_REG_VERSION) == 0x10)
+		ddr_start_addr = RZN1_V_DDR_BASE;
+
+	/* DDR Controller is always in ASYNC mode */
+	cdns_ddr_ctrl_init((void *)RZN1_DDR_BASE, 1,  reg0, reg350,
+			   ddr_start_addr, ddr_size);
+}
+
+/* Enable the Cortex M3 clock and it starts executing, IVT is at 0x04000000 */
+static int do_rzn1_start_cm3(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct ipc_msg msg = { 0 };
+
+	msg.msg_type = 1;
+	msg.wait_rsp = 0;
+	msg.env_ptr = RZN1_V_QSPI_BASE + CONFIG_ENV_OFFSET;
+
+	/* Check the CM3 reset vector has something there */
+	if (readl(RZN1_SRAM_ID_BASE + 4) == 0) {
+		printf("Bad CM3 reset vector at 0x%x\n", RZN1_SRAM_ID_BASE + 4);
+		return -1;
+	}
+
+	if (argc >= 2) {
+		msg.wait_rsp = simple_strtoul(argv[1], NULL, 10);
+		if (!msg.wait_rsp)
+			return -1;
+	}
+	if (argc >= 3) {
+		msg.env_ptr = simple_strtoul(argv[2], NULL, 16);
+		if (!msg.env_ptr)
+			return -1;
+	}
+
+	ipc_init(RZN1_MAILBOX_BASE);
+	ipc_setup_1to1(IPC_TX_MBOX, IPC_RX_MBOX);
+	ipc_setup_1to1(IPC_RX_MBOX, IPC_TX_MBOX);
+
+	ipc_send(IPC_TX_MBOX, (void *)&msg);
+
+	/* Reset then enable the Cortex M3 clock */
+	sysctrl_writel(0x5, RZN1_SYSCTRL_REG_PWRCTRL_CM3);
+	udelay(10);
+	sysctrl_writel(0x3, RZN1_SYSCTRL_REG_PWRCTRL_CM3);
+
+	/* Wait for the CM3 to send a msg back */
+	if (msg.wait_rsp)
+		ipc_recv_all(IPC_RX_MBOX, (void *)&msg);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	rzn1_start_cm3, 3, 0, do_rzn1_start_cm3,
+	"Start Cortex M3 core",
+	   "<wait> 0x<address>\n"
+	   "    - wait = 0|1: Wait for cm3 to ack using IPCM register\n"
+	   "    - Pass the address specified via the IPCM register\n"
+);
diff --git a/arch/arm/cpu/armv7/rzn1/ddr_phy.c b/arch/arm/cpu/armv7/rzn1/ddr_phy.c
new file mode 100644
index 0000000..6ffc1a5
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/ddr_phy.c
@@ -0,0 +1,118 @@
+/*
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+#include <asm/io.h>
+#include <common.h>
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-utils.h"
+#include "renesas/rzn1-clocks.h"
+#include "renesas/rzn1-sysctrl.h"
+
+#define FUNCCTRL	0x00
+#define  FUNCCTRL_MASKSDLOFS	(0x18 << 16)
+#define  FUNCCTRL_DVDDQ_1_5V	(1 << 8)
+#define  FUNCCTRL_RESET_N	(1 << 0)
+#define DLLCTRL		0x04
+#define  DLLCTRL_ASDLLOCK	(1 << 26)
+#define  DLLCTRL_MFSL_500MHz	(2 << 1)
+#define  DLLCTRL_MDLLSTBY	(1 << 0)
+#define ZQCALCTRL	0x08
+#define  ZQCALCTRL_ZQCALEND	(1 << 30)
+#define  ZQCALCTRL_ZQCALRSTB	(1 << 0)
+#define ZQODTCTRL	0x0c
+#define RDCTRL		0x10
+#define RDTMG		0x14
+#define FIFOINIT	0x18
+#define  FIFOINIT_RDPTINITEXE	(1 << 8)
+#define  FIFOINIT_WRPTINITEXE	(1 << 0)
+#define OUTCTRL		0x1c
+#define  OUTCTRL_ADCMDOE	(1 << 0)
+#define WLCTRL1		0x40
+#define  WLCTRL1_WLSTR		(1 << 24)
+#define DQCALOFS1	0xe8
+
+/* DDR PHY setup */
+void ddr_phy_init(int ddr_type)
+{
+	u32 val;
+
+	/* Disable DDR Controller clock and FlexWAY connection */
+	rzn1_clk_set_gate(RZN1_HCLK_DDRC_ID, 0);
+	rzn1_clk_set_gate(RZN1_CLK_DDRC_ID, 0);
+
+	rzn1_clk_reset_state(RZN1_HCLK_DDRC_ID, 0);
+	rzn1_clk_reset_state(RZN1_CLK_DDRC_ID, 0);
+
+	/* Enable DDR Controller clock and FlexWAY connection */
+	rzn1_clk_set_gate(RZN1_CLK_DDRC_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_DDRC_ID, 1);
+
+	/* DDR PHY Soft reset assert */
+	writel(FUNCCTRL_MASKSDLOFS | FUNCCTRL_DVDDQ_1_5V, RZN1_DDRPHY_BASE + FUNCCTRL);
+
+	rzn1_clk_reset_state(RZN1_CLK_DDRC_ID, 1);
+	rzn1_clk_reset_state(RZN1_HCLK_DDRC_ID, 1);
+
+	/* DDR PHY setup */
+	writel(DLLCTRL_MFSL_500MHz | DLLCTRL_MDLLSTBY, RZN1_DDRPHY_BASE + DLLCTRL);
+	writel(0x00000186, RZN1_DDRPHY_BASE + ZQCALCTRL);
+	if (ddr_type == RZN1_DDR3_DUAL_BANK)
+		writel(0xAB330031, RZN1_DDRPHY_BASE + ZQODTCTRL);
+	else if (ddr_type == RZN1_DDR3_SINGLE_BANK)
+		writel(0xAB320051, RZN1_DDRPHY_BASE + ZQODTCTRL);
+	else /* DDR2 */
+		writel(0xAB330071, RZN1_DDRPHY_BASE + ZQODTCTRL);
+	writel(0xB545B544, RZN1_DDRPHY_BASE + RDCTRL);
+	writel(0x000000B0, RZN1_DDRPHY_BASE + RDTMG);
+	writel(0x020A0806, RZN1_DDRPHY_BASE + OUTCTRL);
+	if (ddr_type == RZN1_DDR3_DUAL_BANK)
+		writel(0x80005556, RZN1_DDRPHY_BASE + WLCTRL1);
+	else
+		writel(0x80005C5D, RZN1_DDRPHY_BASE + WLCTRL1);
+	writel(0x00000101, RZN1_DDRPHY_BASE + FIFOINIT);
+	writel(0x00004545, RZN1_DDRPHY_BASE + DQCALOFS1);
+
+	/* Step 9 MDLL reset release */
+	val = readl(RZN1_DDRPHY_BASE + DLLCTRL);
+	val &= ~DLLCTRL_MDLLSTBY;
+	writel(val, RZN1_DDRPHY_BASE + DLLCTRL);
+
+	/* Step 12 Soft reset release */
+	val = readl(RZN1_DDRPHY_BASE + FUNCCTRL);
+	val |= FUNCCTRL_RESET_N;
+	writel(val, RZN1_DDRPHY_BASE + FUNCCTRL);
+
+	/* Step 13 FIFO pointer initialize */
+	writel(FIFOINIT_RDPTINITEXE | FIFOINIT_WRPTINITEXE, RZN1_DDRPHY_BASE + FIFOINIT);
+
+	/* Step 14 Execute ZQ Calibration */
+	val = readl(RZN1_DDRPHY_BASE + ZQCALCTRL);
+	val |= ZQCALCTRL_ZQCALRSTB;
+	writel(val, RZN1_DDRPHY_BASE + ZQCALCTRL);
+
+	/* Step 15 Wait for 200us or more, or wait for DFIINITCOMPLETE to be "1" */
+	while (!(readl(RZN1_DDRPHY_BASE + DLLCTRL) & DLLCTRL_ASDLLOCK))
+		;
+	while (!(readl(RZN1_DDRPHY_BASE + ZQCALCTRL) & ZQCALCTRL_ZQCALEND))
+		;
+
+	/* Step 16 Enable Address and Command output */
+	val = readl(RZN1_DDRPHY_BASE + OUTCTRL);
+	val |= OUTCTRL_ADCMDOE;
+	writel(val, RZN1_DDRPHY_BASE + OUTCTRL);
+
+	/* Step 17 Wait for 200us or more(from MRESETB=0) */
+	udelay(200);
+}
+
+void ddr_phy_enable_wl(void)
+{
+	u32 val;
+
+	/* Step 26 (Set Write Leveling) */
+	val = readl(RZN1_DDRPHY_BASE + WLCTRL1);
+	val |= WLCTRL1_WLSTR;
+	writel(val, RZN1_DDRPHY_BASE + WLCTRL1);
+}
diff --git a/arch/arm/cpu/armv7/rzn1/eth.c b/arch/arm/cpu/armv7/rzn1/eth.c
new file mode 100644
index 0000000..ef5c386
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/eth.c
@@ -0,0 +1,257 @@
+/*
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier:	BSD-2-Clause
+ */
+#include <asm/io.h>
+#include <common.h>
+#include <miiphy.h>
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-utils.h"
+#include "renesas/rzn1-clocks.h"
+#include "renesas/rzn1-sysctrl.h"
+
+/* MoreThanIP 5pt Switch regs */
+#define MT5PT_REVISION		0x0
+#define MT5PT_SCRATCH		0x4
+#define MT5PT_PORT_ENA		0x8
+#define  MT5PT_PORT_ENA_TX(x)		(1 << ((x) + 16))
+#define  MT5PT_PORT_ENA_RX(x)		(1 << (x))
+#define  MT5PT_PORT_ENA_TXRX(x)		(MT5PT_PORT_ENA_TX(x) | MT5PT_PORT_ENA_RX(x))
+#define MT5PT_AUTH_PORT(x)	(0x240 + (x) * 4)
+#define  MT5PT_AUTH_PORT_AUTHORIZED	(1 << 0)
+#define  MT5PT_AUTH_PORT_CONTROLLED	(1 << 1)
+#define  MT5PT_AUTH_PORT_EAPOL_EN	(1 << 2)
+#define  MT5PT_AUTH_PORT_GUEST		(1 << 3)
+#define  MT5PT_AUTH_PORT_EAPOL_PORT(x)	((x) << 12)
+#define MT5PT_MAC_CMD_CFGn(x)	(0x808 + (x) * 0x400)
+#define  MT5PT_TX_ENA			(1 << 0)
+#define  MT5PT_RX_ENA			(1 << 1)
+#define  MT5PT_MBPS_1000		(1 << 3)
+#define MT5PT_MAC_FRM_LENGTHn(x)	(0x814 + (x) * 0x400)
+
+void rzn1_mt5pt_switch_enable_port(int port)
+{
+	u8 *regs = (u8 *)RZN1_SWITCH_BASE;
+	u32 val;
+
+	val = readl(regs + MT5PT_AUTH_PORT(port));
+	val |= MT5PT_AUTH_PORT_AUTHORIZED;
+	writel(val, regs + MT5PT_AUTH_PORT(port));
+
+	val = readl(regs + MT5PT_PORT_ENA);
+	val |= MT5PT_PORT_ENA_TXRX(port);
+	writel(val, regs + MT5PT_PORT_ENA);
+
+	/* Max frame size */
+	writel(9224, regs + MT5PT_MAC_FRM_LENGTHn(port));
+}
+
+void rzn1_mt5pt_switch_setup_port_speed(int port, int speed)
+{
+	u8 *regs = (u8 *)RZN1_SWITCH_BASE;
+	u32 val;
+
+	val = readl(regs + MT5PT_MAC_CMD_CFGn(port));
+	val &= ~MT5PT_MBPS_1000;
+	if (speed == SPEED_1000)
+		val |= MT5PT_MBPS_1000;
+	writel(val, regs + MT5PT_MAC_CMD_CFGn(port));
+}
+
+void rzn1_switch_setup_port_speed(int port, int speed, int enable)
+{
+	/*
+	 * The MoreThanIP 5 port switch has 5 ports. Port 4 is also known as
+	 * PORTIN and is connected to GMAC2 or MAC RTOS. The other 4 ports (0
+	 * to 3) are downstream and can connect to a PHY.
+	 */
+	rzn1_mt5pt_switch_setup_port_speed(port, speed);
+
+	if (enable)
+		rzn1_mt5pt_switch_enable_port(port);
+}
+
+void rzn1_mt5pt_switch_init(void)
+{
+	/* 5pt Switch clock divider setting */
+	rzn1_sysctrl_div(RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV, 5);
+
+	/* Enable 5pt Switch clocks */
+	rzn1_clk_set_gate(RZN1_CLK_SWITCH_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_SWITCH_ID, 1);
+	rzn1_clk_reset(RZN1_CLK_SWITCH_ID);
+}
+
+/* RIN Ether Accessory (Switch Control) regs */
+#define PRCMD			0x0		/* Ethernet Protect */
+#define IDCODE			0x4		/* EtherSwitch IDCODE */
+#define MODCTRL			0x8		/* Mode Control */
+#define PTP_MODE_CTRL		0xc		/* PTP Mode Control */
+#define PHY_LINK_MODE		0x14		/* Ethernet PHY Link Mode */
+
+/* RIN RGMII/RMII Converter regs */
+#define CONVCTRL(x)		(0x100 + ((x)) * 4) /* RGMII/RMII Converter */
+#define  CONVCTRL_10_MBPS		(0 << 0)
+#define  CONVCTRL_100_MBPS		(1 << 0)
+#define  CONVCTRL_1000_MBPS		(1 << 1)
+#define  CONVCTRL_MII			(0 << 2)
+#define  CONVCTRL_RMII			(1 << 2)
+#define  CONVCTRL_RGMII			(1 << 3)
+#define  CONVCTRL_REF_CLK_OUT		(1 << 4)
+#define  CONVCTRL_HALF_DUPLEX		(0 << 8)
+#define  CONVCTRL_FULL_DUPLEX		(1 << 8)
+#define CONVRST			0x114		/* RGMII/RMII Converter RST */
+#define  PHYIF_RST(x)			(1 << (x))
+
+/* RIN SwitchCore regs */
+#define RIN_SWCTRL		0x304		/* SwitchCore Control */
+#define  RIN_SWCTRL_MPBS_10(x)		(((0 << 4) | (1 << 0)) << (x))
+#define  RIN_SWCTRL_MPBS_100(x)		(((0 << 4) | (0 << 0)) << (x))
+#define  RIN_SWCTRL_MPBS_1000(x)	(((1 << 4) | (0 << 0)) << (x))
+#define  RIN_SWCTRL_MPBS_MASK(x)	(((1 << 4) | (1 << 0)) << (x))
+#define RIN_SWDUPC		0x308		/* SwitchCore Duplex Mode */
+#define  RIN_SWDUPC_DUPLEX_MASK(x)	(1 << (x))
+#define  RIN_SWDUPC_DUPLEX_FULL(x)	(1 << (x))
+
+void rzn1_rin_prot_writel(u32 val, u32 reg)
+{
+	u8 *regs = (u8 *)RZN1_SWITCH_CTRL_REG_BASE;
+
+	/* RIN: Unprotect register writes */
+	writel(0x00a5, regs + PRCMD);
+	writel(0x0001, regs + PRCMD);
+	writel(0xfffe, regs + PRCMD);
+	writel(0x0001, regs + PRCMD);
+
+	writel(val, regs + reg);
+
+	/* Enable protection */
+	writel(0x0000, regs + PRCMD);
+}
+
+void rzn1_rin_switchcore_setup(int port, int full_duplex, int speed)
+{
+	u8 *regs = (u8 *)RZN1_SWITCH_CTRL_REG_BASE;
+	u32 val;
+
+	/* speed */
+	val = readl(regs + RIN_SWCTRL);
+	val &= ~RIN_SWCTRL_MPBS_MASK(port);
+
+	if (speed == SPEED_1000)
+		val |= RIN_SWCTRL_MPBS_1000(port);
+	else if (speed == SPEED_100)
+		val |= RIN_SWCTRL_MPBS_100(port);
+	else
+		val |= RIN_SWCTRL_MPBS_10(port);
+
+	rzn1_rin_prot_writel(val, RIN_SWCTRL);
+
+	/* duplex */
+	val = readl(regs + RIN_SWDUPC);
+	val &= ~RIN_SWDUPC_DUPLEX_MASK(port);
+	if (full_duplex)
+		val |= RIN_SWDUPC_DUPLEX_FULL(port);
+	rzn1_rin_prot_writel(val, RIN_SWDUPC);
+}
+
+/*
+ * RIN RGMII/RMII Converter set speed
+ * RGMII/RMII Converter number: 0..4
+ * speed: 10, 100, 1000
+ */
+void rzn1_rgmii_rmii_conv_speed(int phy, int full_duplex, int speed)
+{
+	u8 *regs = (u8 *)RZN1_SWITCH_CTRL_REG_BASE;
+	u32 val = 0;
+
+	val = readl(regs + CONVCTRL(phy));
+
+	val &= CONVCTRL_MII | CONVCTRL_RMII | CONVCTRL_RGMII |
+		CONVCTRL_REF_CLK_OUT;
+
+	/* The interface type and speed bits are somewhat intertwined */
+	if (val != CONVCTRL_MII) {
+		if (speed == SPEED_1000)
+			val |= CONVCTRL_1000_MBPS;
+		else if (speed == SPEED_100)
+			val |= CONVCTRL_100_MBPS;
+		else if (speed == SPEED_10)
+			val |= CONVCTRL_10_MBPS;
+	}
+
+	if (full_duplex)
+		val |= CONVCTRL_FULL_DUPLEX;
+
+	writel(val, regs + CONVCTRL(phy));
+
+	if (phy > 0)
+		rzn1_rin_switchcore_setup(4 - phy, full_duplex, speed);
+}
+
+/*
+ * RIN RGMII/RMII Converter setup one
+ * RGMII/RMII Converter number: 0..4
+ * if_type: Type of PHY interface, see phy_interface_t
+ */
+void rzn1_rgmii_rmii_conv_setup(int phy, u32 if_type, int rmii_ref_clk_out)
+{
+	u8 *regs = (u8 *)RZN1_SWITCH_CTRL_REG_BASE;
+	u32 val = 0;
+	int is_rgmii = 0;
+
+	switch (if_type) {
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		val |= CONVCTRL_RGMII;
+		is_rgmii = 1;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		val |= CONVCTRL_RMII;
+		break;
+	case PHY_INTERFACE_MODE_MII:
+		val |= CONVCTRL_MII;
+		break;
+	};
+
+	if (if_type == PHY_INTERFACE_MODE_RMII && rmii_ref_clk_out)
+		val |= CONVCTRL_REF_CLK_OUT;
+
+	writel(val, regs + CONVCTRL(phy));
+
+	if (is_rgmii)
+		rzn1_rgmii_rmii_conv_speed(phy, DUPLEX_FULL, SPEED_1000);
+	else
+		rzn1_rgmii_rmii_conv_speed(phy, DUPLEX_FULL, SPEED_100);
+
+	/* reset */
+	val = readl(regs + CONVRST);
+	val &= ~PHYIF_RST(phy);
+	rzn1_rin_prot_writel(val, CONVRST);
+	udelay(1000);
+	val |= PHYIF_RST(phy);
+	rzn1_rin_prot_writel(val, CONVRST);
+}
+
+void rzn1_rin_init(void)
+{
+	/* Enable RIN clocks */
+	rzn1_clk_set_gate(RZN1_HCLK_SWITCH_RG_ID, 1);
+
+	/* Set PTP to use 25MHz PLL clock */
+	rzn1_rin_prot_writel(0x4, PTP_MODE_CTRL);
+}
+
+void rzn1_rin_reset_clks(void)
+{
+	u32 val;
+
+	/* Clear ETH and CLK25 resets */
+	val = readl(RZN1_SYSTEM_CTRL_BASE + RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL);
+	val |= (1 << RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_RSTN_ETH);
+	val |= (1 << RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_RSTN_CLK25);
+	writel(val, RZN1_SYSTEM_CTRL_BASE + RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL);
+}
diff --git a/arch/arm/cpu/armv7/rzn1/ipcm.c b/arch/arm/cpu/armv7/rzn1/ipcm.c
new file mode 100644
index 0000000..d46231c
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/ipcm.c
@@ -0,0 +1,96 @@
+/*
+ * Simple driver for the ARM PL320 IPCM
+ *
+ * Based on Linux drivers/mailbox/pl320-ipc.c
+ * Copyright 2012 Calxeda, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ */
+#include <common.h>
+#include <asm/io.h>
+#include "ipcm.h"
+
+#define IPCMxSOURCE(m)		((m) * 0x40)
+#define IPCMxDSET(m)		(((m) * 0x40) + 0x004)
+#define IPCMxDSTATUS(m)		(((m) * 0x40) + 0x00c)
+#define IPCMxMSET(m)		(((m) * 0x40) + 0x014)
+#define IPCMxSEND(m)		(((m) * 0x40) + 0x020)
+ #define IPCMxSEND_SEND		BIT(0)
+ #define IPCMxSEND_ACK		BIT(1)
+#define IPCMxDR(m, dr)		(((m) * 0x40) + ((dr) * 4) + 0x024)
+
+#define IPCMRIS(irq)		(((irq) * 8) + 0x804)
+#define IPCMCFGSTAT		0x900
+#define  NR_MBOXES(x)		(((x) >> 16) & 63)
+#define  NR_DATAWORDS(x)	((x) & 7)
+
+#define ALL_CHANS(x)		((1 << (x)) - 1)
+
+static uintptr_t ipc_base;
+static uint32_t nr_mboxes;
+static uint32_t nr_datawords;
+static uint32_t all_chans;
+
+void ipc_init(uintptr_t _ipc_base)
+{
+	ipc_base = _ipc_base;
+	nr_mboxes = NR_MBOXES(readl(ipc_base + IPCMCFGSTAT));
+	nr_datawords = NR_DATAWORDS(readl(ipc_base + IPCMCFGSTAT));
+	all_chans = ALL_CHANS(nr_mboxes);
+}
+
+void ipc_setup_1to1(uint32_t tx_mbox, uint32_t rx_mbox)
+{
+	uint32_t rx_mboxes = IPC_CHAN_MASK(rx_mbox);
+
+	ipc_setup_custom(tx_mbox, rx_mboxes);
+}
+
+void ipc_setup_broadcast(uint32_t tx_mbox)
+{
+	uint32_t rx_mboxes = all_chans - IPC_CHAN_MASK(tx_mbox);
+
+	ipc_setup_custom(tx_mbox, rx_mboxes);
+}
+
+void ipc_setup_custom(uint32_t tx_mbox, uint32_t rx_mboxes)
+{
+	writel(0, ipc_base + IPCMxSEND(tx_mbox));
+	writel(IPC_CHAN_MASK(tx_mbox), ipc_base + IPCMxSOURCE(tx_mbox));
+	writel(rx_mboxes, ipc_base + IPCMxDSET(tx_mbox));
+	writel(rx_mboxes, ipc_base + IPCMxMSET(tx_mbox));
+}
+
+void ipc_send(uint32_t tx_mbox, uint32_t *data)
+{
+	int i;
+
+	for (i = 0; i < nr_datawords; i++)
+		writel(data[i], ipc_base + IPCMxDR(tx_mbox, i));
+	writel(IPCMxSEND_SEND, ipc_base + IPCMxSEND(tx_mbox));
+}
+
+void ipc_wait_for_ack(uint32_t tx_mbox)
+{
+	while (!(readl(ipc_base + IPCMxSEND(tx_mbox)) & IPCMxSEND_ACK))
+		;
+}
+
+/* Note that this blocks */
+void ipc_recv(uint32_t rx_mbox, uint32_t from_mboxes, uint32_t *data)
+{
+	int i;
+
+	while (!(readl(ipc_base + IPCMxDSTATUS(rx_mbox)) & from_mboxes))
+		;
+
+	for (i = 0; i < nr_datawords; i++)
+		data[i] = readl(ipc_base + IPCMxDR(rx_mbox, i));
+
+	writel(IPCMxSEND_ACK, ipc_base + IPCMxSEND(rx_mbox));
+}
+
+void ipc_recv_all(uint32_t rx_mbox, uint32_t *data)
+{
+	ipc_recv(rx_mbox, all_chans, data);
+}
diff --git a/arch/arm/cpu/armv7/rzn1/ipcm.h b/arch/arm/cpu/armv7/rzn1/ipcm.h
new file mode 100644
index 0000000..beafdcb
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/ipcm.h
@@ -0,0 +1,25 @@
+/*
+ * Simple driver for the ARM PL320 IPCM
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ */
+#ifndef __IPCM_H__
+#define __IPCM_H__
+
+#define IPC_CHAN_MASK(n)	(1 << (n))
+
+void ipc_init(uintptr_t _ipc_base);
+void ipc_setup_1to1(uint32_t tx_mbox, uint32_t rx_mbox);
+void ipc_setup_broadcast(uint32_t tx_mbox);
+
+/* rx_mboxes is a bit mask for the mailboxes to send to */
+void ipc_setup_custom(uint32_t tx_mbox, uint32_t rx_mboxes);
+void ipc_send(uint32_t tx_mbox, uint32_t *data);
+void ipc_wait_for_ack(uint32_t tx_mbox);
+
+/* from_mboxes is a bit mask of the sending mailboxes to wait on */
+void ipc_recv(uint32_t rx_mbox, uint32_t from_mboxes, uint32_t *data);
+
+void ipc_recv_all(uint32_t rx_mbox, uint32_t *data);
+
+#endif /* __IPCM_H__ */
diff --git a/arch/arm/cpu/armv7/rzn1/pinmux.c b/arch/arm/cpu/armv7/rzn1/pinmux.c
new file mode 100644
index 0000000..29f0fb6
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/pinmux.c
@@ -0,0 +1,119 @@
+/*
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier:	BSD-2-Clause
+ */
+#include <asm/io.h>
+#include <common.h>
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-utils.h"
+#include "renesas/pinctrl-rzn1.h"
+
+#define GPIO_LVL1_CONFIG_B(x)		(RZN1_PINCTRL_BASE + (x << 2))
+#define GPIO_LVL2_CONFIG(x)		(RZN1_PINCTRL_L2_BASE + (x << 2))
+#define GPIO_LVL1_STATUS_PROTECT	(RZN1_PINCTRL_BASE + 0x400)
+#define GPIO_LVL2_STATUS_PROTECT	(RZN1_PINCTRL_L2_BASE + 0x400)
+#define WRITE_ACCESS_MASK		0xfffffff8
+#define DISABLE_WRITE_ACCESS		1
+#define PADS_FUNCTION_USE_L2_SEL	15
+#define RZN1_L1_PADFUNC_MASK		0xf
+#define RZN1_L2_PADFUNC_MASK		0x3f
+
+static void pinmux_unprotect(u32 reg)
+{
+	/* Enable write access to port multiplex registers */
+	/* write the address of the register to the register */
+	writel(reg & WRITE_ACCESS_MASK, reg);
+}
+
+static void pinmux_protect(u32 reg)
+{
+	/* Disable write access to port multiplex registers */
+	/* write the address of the register to the register */
+	u32 val = reg;
+	val &= WRITE_ACCESS_MASK;
+	val |= DISABLE_WRITE_ACCESS;
+	writel(val, reg);
+}
+
+static void set_lvl1_pinmux(u8 pin, u32 func, u32 attrib)
+{
+	u32 reg = readl(GPIO_LVL1_CONFIG_B(pin));
+
+	/* Set pad function */
+	reg &= ~RZN1_L1_PADFUNC_MASK;
+	reg |= func & RZN1_L1_PADFUNC_MASK;
+
+	if (attrib & RZN1_DRIVE_SET) {
+		reg &= ~RZN1_DRIVE_MASK;
+		reg |= attrib & RZN1_DRIVE_MASK;
+	}
+
+	if (attrib & RZN1_PULL_SET) {
+		reg &= ~RZN1_PULL_MASK;
+		reg |= attrib & RZN1_PULL_MASK;
+	}
+
+	pinmux_unprotect(GPIO_LVL1_STATUS_PROTECT);
+	writel(reg, GPIO_LVL1_CONFIG_B(pin));
+	pinmux_protect(GPIO_LVL1_STATUS_PROTECT);
+}
+
+static void rzn1_pinmux_mdio_select(u8 mdio, u32 func)
+{
+       pinmux_unprotect(GPIO_LVL2_STATUS_PROTECT);
+       writel(func, GPIO_LVL2_STATUS_PROTECT + 4 + (mdio * 4));
+       pinmux_protect(GPIO_LVL2_STATUS_PROTECT);
+}
+
+void rzn1_pinmux_select(u8 pin, u32 func, u32 attrib)
+{
+	/* Special 'virtual' pins for the MDIO muxing */
+	if (pin >= RZN1_MDIO_BUS0 && pin <= RZN1_MDIO_BUS1) {
+		if (func >= RZN1_FUNC_MDIO_MUX_HIGHZ &&
+				func <= RZN1_FUNC_MDIO_MUX_SWITCH) {
+			pin -= RZN1_MDIO_BUS0;
+			func -= RZN1_FUNC_MDIO_MUX_HIGHZ;
+			rzn1_pinmux_mdio_select(pin, func);
+		}
+		return;
+	}
+
+	if (func >= RZN1_FUNC_LEVEL2_OFFSET) {
+		func -= RZN1_FUNC_LEVEL2_OFFSET;
+
+		/* Level 1 to High-Z just in case */
+		set_lvl1_pinmux(pin, RZN1_FUNC_HIGHZ, attrib);
+
+		/* Level 2 */
+		pinmux_unprotect(GPIO_LVL2_STATUS_PROTECT);
+		writel(func, GPIO_LVL2_CONFIG(pin));
+		pinmux_protect(GPIO_LVL2_STATUS_PROTECT);
+
+		/* Level 1 */
+		set_lvl1_pinmux(pin, PADS_FUNCTION_USE_L2_SEL, attrib);
+	} else {
+		/* Level 1 */
+		set_lvl1_pinmux(pin, func, attrib);
+	}
+}
+
+void rzn1_pinmux_set(u32 setting)
+{
+	u8 pin = setting & 0xff;
+	u32 func = (setting >> RZN1_MUX_FUNC_BIT) & 0x7f;
+	u32 attrib = 0;
+	u32 tmp;
+
+	if (setting & (1 << RZN1_MUX_HAS_DRIVE_BIT)) {
+		tmp = (setting >> RZN1_MUX_DRIVE_BIT) & 3;
+		attrib |= RZN1_DRIVE_SET | (tmp << 10);
+	}
+
+	if (setting & (1 << RZN1_MUX_HAS_PULL_BIT)) {
+		tmp = (setting >> RZN1_MUX_PULL_BIT) & 3;
+		attrib |= RZN1_PULL_SET | (tmp << 8);
+	}
+
+	rzn1_pinmux_select(pin, func, attrib);
+}
diff --git a/arch/arm/cpu/armv7/rzn1/spl.c b/arch/arm/cpu/armv7/rzn1/spl.c
new file mode 100644
index 0000000..a9b421a
--- /dev/null
+++ b/arch/arm/cpu/armv7/rzn1/spl.c
@@ -0,0 +1,45 @@
+/*
+ * common spl init code
+ *
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+#include <asm/io.h>
+#include <common.h>
+#include <config.h>
+#include <spl.h>
+#include "renesas/rzn1-sysctrl.h"
+#include "renesas/rzn1-utils.h"
+
+u32 spl_boot_device(void)
+{
+	u32 opmode = (sysctrl_readl(RZN1_SYSCTRL_REG_OPMODE) >> 2) & 3;
+	switch (opmode) {
+#if defined(CONFIG_SPL_SPI_LOAD)
+	case 0:
+		return BOOT_DEVICE_SPI;
+#endif
+#if defined(CONFIG_SPL_NAND_LOAD)
+	case 1:
+		return BOOT_DEVICE_NAND;
+#endif
+	}
+	/* fallback to hard coded */
+#if defined(CONFIG_SPL_SPI_LOAD)
+	return BOOT_DEVICE_SPI;
+#else
+	return BOOT_DEVICE_NAND;
+#endif
+}
+
+#ifdef CONFIG_SPL_OS_BOOT
+int spl_start_uboot(void)
+{
+	mdelay(50);
+	/* break into full u-boot on 'u' */
+	if (serial_tstc() && serial_getc() == 'u')
+		return 1;
+	return 0;
+}
+#endif
diff --git a/arch/arm/cpu/armv7/start.S b/arch/arm/cpu/armv7/start.S
index 7eee54b..77aa43b 100644
--- a/arch/arm/cpu/armv7/start.S
+++ b/arch/arm/cpu/armv7/start.S
@@ -133,6 +133,19 @@ ENDPROC(switch_to_hypervisor)
  *
  *************************************************************************/
 ENTRY(cpu_init_cp15)
+#if defined(CONFIG_CORTEX_A7)
+	/* Cortex A7 needs SMP bit setting before enabling the MMU/caches */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	bic	r0, r0, #0x00000800	@ clear bit 11 (Z---) BTB
+	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
+	mcr	p15, 0, r0, c1, c0, 0
+
+	mrc	p15, 0, r0, c1, c0, 1
+	orr	r0, r0, #0x00000040	@ set SMP bit
+	mcr	p15, 0, r0, c1, c0, 1
+#endif
+
 	/*
 	 * Invalidate L1 I/D
 	 */
diff --git a/arch/arm/cpu/armv7m/Makefile b/arch/arm/cpu/armv7m/Makefile
index aff60e8..f2b50a7 100644
--- a/arch/arm/cpu/armv7m/Makefile
+++ b/arch/arm/cpu/armv7m/Makefile
@@ -7,3 +7,10 @@
 
 extra-y := start.o
 obj-y += cpu.o
+
+obj-$(CONFIG_SYS_ARCH_TIMER) += systick-timer.o
+
+# Re-use the RZ/N1 armv7 code
+obj-$(CONFIG_ARCH_RZN1) += ../armv7/rzn1/
+
+
diff --git a/arch/arm/cpu/armv7m/cpu.c b/arch/arm/cpu/armv7m/cpu.c
index 58cde93..c3e4734 100644
--- a/arch/arm/cpu/armv7m/cpu.c
+++ b/arch/arm/cpu/armv7m/cpu.c
@@ -24,7 +24,7 @@ int cleanup_before_linux(void)
 /*
  * Perform the low-level reset.
  */
-void reset_cpu(ulong addr)
+__weak void reset_cpu(ulong addr)
 {
 	/*
 	 * Perform reset but keep priority group unchanged.
diff --git a/arch/arm/cpu/armv7m/start.S b/arch/arm/cpu/armv7m/start.S
index 49f2720..d79adb5 100644
--- a/arch/arm/cpu/armv7m/start.S
+++ b/arch/arm/cpu/armv7m/start.S
@@ -8,7 +8,8 @@
 .globl	reset
 .type reset, %function
 reset:
-	b	_main
+	ldr	r0, =_main
+	mov	pc, r0
 
 .globl	c_runtime_cpu_setup
 c_runtime_cpu_setup:
diff --git a/arch/arm/cpu/armv7m/systick-timer.c b/arch/arm/cpu/armv7m/systick-timer.c
new file mode 100644
index 0000000..23244c3
--- /dev/null
+++ b/arch/arm/cpu/armv7m/systick-timer.c
@@ -0,0 +1,116 @@
+/*
+ * ARM Cortex M3/M4/M7 SysTick timer driver
+ * (C) Copyright 2017 Renesas Electronics Europe Ltd
+ *
+ * Based on arch/arm/mach-stm32/stm32f1/timer.c
+ * (C) Copyright 2015
+ * Kamil Lulko, <kamil.lulko@gmail.com>
+ *
+ * Copyright 2015 ATS Advanced Telematics Systems GmbH
+ * Copyright 2015 Konsulko Group, Matt Porter <mporter@konsulko.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ *
+ * The SysTick timer is a 24-bit count down timer. The clock can be either the
+ * CPU clock or a reference clock. Since the timer will wrap around very quickly
+ * when using the CPU clock, and we do not handle the timer interrupts, it is
+ * expected that this driver is only ever used with a slow reference clock.
+ *
+ * The number of reference clock ticks that correspond to 10ms is normally
+ * defined in the SysTick Calibration register's TENMS field. However, on some
+ * devices this is wrong, so this driver allows the clock rate to be defined
+ * using CONFIG_SYS_HZ_CLOCK.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* SysTick Base Address - fixed for all Cortex M3, M4 and M7 devices */
+#define SYSTICK_BASE		0xE000E010
+
+struct cm3_systick {
+	uint32_t ctrl;
+	uint32_t reload_val;
+	uint32_t current_val;
+	uint32_t calibration;
+};
+
+#define TIMER_MAX_VAL		0x00FFFFFF
+#define SYSTICK_CTRL_EN		BIT(0)
+/* Clock source: 0 = Ref clock, 1 = CPU clock */
+#define SYSTICK_CTRL_CPU_CLK	BIT(2)
+#define SYSTICK_CAL_NOREF	BIT(31)
+#define SYSTICK_CAL_SKEW	BIT(30)
+#define SYSTICK_CAL_TENMS_MASK	0x00FFFFFF
+
+/* read the 24-bit timer */
+static ulong read_timer(void)
+{
+	struct cm3_systick *systick = (struct cm3_systick *)SYSTICK_BASE;
+
+	/* The timer counts down, therefore convert to an incrementing timer */
+	return TIMER_MAX_VAL - readl(&systick->current_val);
+}
+
+int timer_init(void)
+{
+	struct cm3_systick *systick = (struct cm3_systick *)SYSTICK_BASE;
+	u32 cal;
+
+	writel(TIMER_MAX_VAL, &systick->reload_val);
+	/* Any write to current_val reg clears it to 0 */
+	writel(0, &systick->current_val);
+
+	cal = readl(&systick->calibration);
+	if (cal & SYSTICK_CAL_NOREF)
+		/* Use CPU clock, no interrupts */
+		writel(SYSTICK_CTRL_EN | SYSTICK_CTRL_CPU_CLK, &systick->ctrl);
+	else
+		/* Use external clock, no interrupts */
+		writel(SYSTICK_CTRL_EN, &systick->ctrl);
+
+	/*
+	 * If the TENMS field is inexact or wrong, specify the clock rate using
+	 * CONFIG_SYS_HZ_CLOCK.
+	 */
+#if defined(CONFIG_SYS_HZ_CLOCK)
+	gd->arch.timer_rate_hz = CONFIG_SYS_HZ_CLOCK;
+#else
+	gd->arch.timer_rate_hz = (cal & SYSTICK_CAL_TENMS_MASK) * 100;
+#endif
+
+	gd->arch.tbl = 0;
+	gd->arch.tbu = 0;
+	gd->arch.lastinc = read_timer();
+
+	return 0;
+}
+
+/* return milli-seconds timer value */
+ulong get_timer(ulong base)
+{
+	unsigned long long t = get_ticks() * 1000;
+
+	return (ulong)((t / gd->arch.timer_rate_hz)) - base;
+}
+
+unsigned long long get_ticks(void)
+{
+	u32 now = read_timer();
+
+	if (now >= gd->arch.lastinc)
+		gd->arch.tbl += (now - gd->arch.lastinc);
+	else
+		gd->arch.tbl += (TIMER_MAX_VAL - gd->arch.lastinc) + now;
+
+	gd->arch.lastinc = now;
+
+	return gd->arch.tbl;
+}
+
+ulong get_tbclk(void)
+{
+	return gd->arch.timer_rate_hz;
+}
diff --git a/arch/arm/cpu/u-boot-spl.lds b/arch/arm/cpu/u-boot-spl.lds
index 068163b..be28734 100644
--- a/arch/arm/cpu/u-boot-spl.lds
+++ b/arch/arm/cpu/u-boot-spl.lds
@@ -23,6 +23,78 @@ SECTIONS
 		*(.text*)
 	}
 
+#ifdef CONFIG_ARMV7_NONSEC
+
+	/* Align the secure section only if we're going to use it in situ */
+	.__secure_start :
+#ifndef CONFIG_ARMV7_SECURE_BASE
+	/*	ALIGN(CONSTANT(COMMONPAGESIZE)) */
+		ALIGN(32)
+#endif
+	{
+		KEEP(*(.__secure_start))
+	}
+
+#ifndef CONFIG_ARMV7_SECURE_BASE
+#define CONFIG_ARMV7_SECURE_BASE
+#define __ARMV7_PSCI_STACK_IN_RAM
+#endif
+
+	.secure_text CONFIG_ARMV7_SECURE_BASE :
+		AT(ADDR(.__secure_start) + SIZEOF(.__secure_start))
+	{
+		*(._secure.text)
+	}
+
+	.secure_data : AT(LOADADDR(.secure_text) + SIZEOF(.secure_text))
+	{
+		*(._secure.data)
+	}
+
+#ifdef CONFIG_ARMV7_PSCI
+	.secure_stack ALIGN(ADDR(.secure_data) + SIZEOF(.secure_data),
+			    CONSTANT(COMMONPAGESIZE)) (NOLOAD) :
+#ifdef __ARMV7_PSCI_STACK_IN_RAM
+		AT(ADDR(.secure_stack))
+#else
+		AT(LOADADDR(.secure_data) + SIZEOF(.secure_data))
+#endif
+	{
+		KEEP(*(.__secure_stack_start))
+
+		/* Skip addreses for stack */
+		. = . + CONFIG_ARMV7_PSCI_NR_CPUS * ARM_PSCI_STACK_SIZE;
+
+		/* Align end of stack section to page boundary */
+		. = ALIGN(CONSTANT(COMMONPAGESIZE));
+
+		KEEP(*(.__secure_stack_end))
+
+#ifdef CONFIG_ARMV7_SECURE_MAX_SIZE
+		/*
+		 * We are not checking (__secure_end - __secure_start) here,
+		 * as these are the load addresses, and do not include the
+		 * stack section. Instead, use the end of the stack section
+		 * and the start of the text section.
+		 */
+		ASSERT((. - ADDR(.secure_text)) <= CONFIG_ARMV7_SECURE_MAX_SIZE,
+		       "Error: secure section exceeds secure memory size");
+#endif
+	}
+
+#ifndef __ARMV7_PSCI_STACK_IN_RAM
+	/* Reset VMA but don't allocate space if we have secure SRAM */
+	. = LOADADDR(.secure_stack);
+#endif
+
+#endif
+
+	.__secure_end : AT(ADDR(.__secure_end)) {
+		*(.__secure_end)
+		LONG(0x1d1071c);	/* Must output something to reset LMA */
+	}
+#endif
+
 	. = ALIGN(4);
 	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
 
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 3ee608b..f3723d9 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -163,6 +163,9 @@ dtb-$(CONFIG_FSL_LSCH2) += fsl-ls1043a-qds-duart.dtb \
 	fsl-ls1012a-rdb.dtb \
 	fsl-ls1012a-frdm.dtb
 
+dtb-$(CONFIG_TARGET_RENESAS_RZN1D400_DB) += rzn1d400-db.dtb
+dtb-$(CONFIG_TARGET_RENESAS_RZN1S324_DB) += rzn1s324-db.dtb
+
 dtb-$(CONFIG_ARCH_SNAPDRAGON) += dragonboard410c.dtb
 
 dtb-$(CONFIG_MACH_SUN4I) += \
diff --git a/arch/arm/dts/rzn1-clocks.dtsi b/arch/arm/dts/rzn1-clocks.dtsi
new file mode 100644
index 0000000..2ccbcd9
--- /dev/null
+++ b/arch/arm/dts/rzn1-clocks.dtsi
@@ -0,0 +1,1069 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+
+&clocks {
+	clk_25_pg4: clk_25_pg4@RZN1_CLK_25MHZ_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG4_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_25_pg5: clk_25_pg5@RZN1_CLK_25MHZ_PG5_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG5_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_25_pg6: clk_25_pg6@RZN1_CLK_25MHZ_PG6_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG6_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_25_pg7: clk_25_pg7@RZN1_CLK_25MHZ_PG7_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG7_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_25_pg8: clk_25_pg8@RZN1_CLK_25MHZ_PG8_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG8_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_48_pg4: clk_48_pg4@RZN1_CLK_48MHZ_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_48MHZ_PG4_ID>;
+		clocks = <&clk_48>;
+	};
+	clk_48_pg_f: clk_48_pg_f@RZN1_CLK_48MHZ_PG_F_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_48MHZ_PG_F_ID>;
+		clocks = <&clk_48>;
+	};
+	clk_adc: clk_adc@RZN1_CLK_ADC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_ADC_ID>;
+		clocks = <&div_adc>;
+	};
+	clk_cm3: clk_cm3@RZN1_CLK_CM3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_CM3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	clk_ddrc: clk_ddrc@RZN1_CLK_DDRC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_DDRC_ID>;
+		clocks = <&clk_ddrphy_pllclk_d4>;
+	};
+	clk_ddrphy_pllclk_d4: clk_ddrphy_pllclk_d4 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <4>;
+		clock-mult = <1>;
+		clocks = <&clk_ddrphy_pllclk>;
+	};
+	clk_ecat100: clk_ecat100@RZN1_CLK_ECAT100_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_ECAT100_ID>;
+		clocks = <&clkout_d10>;
+	};
+	clk_ecat100_d4: clk_ecat100_d4 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <4>;
+		clock-mult = <1>;
+		clocks = <&clk_ecat100>;
+	};
+	clk_ecat25: clk_ecat25@RZN1_CLK_ECAT25_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_ECAT25_ID>;
+		clocks = <&clk_ecat100_d4>;
+	};
+	clk_hsr: clk_hsr {
+		#clock-cells = <0>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	clk_hsr50: clk_hsr50@RZN1_CLK_HSR50_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_HSR50_ID>;
+		clocks = <&clk_hsr_dup_d2>;
+	};
+	clk_hsr_dup: clk_hsr_dup@RZN1_CLK_HSR_DUP_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_HSR_DUP_ID>;
+		clocks = <&clkout_d10>;
+	};
+	clk_rxgmii_switch: clk_hsr_dup_d2: clk_hsr_dup_d2 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <2>;
+		clock-mult = <1>;
+		clocks = <&clk_hsr_dup>;
+	};
+	clk_hw_rtos: clk_hw_rtos@RZN1_CLK_HW_RTOS_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_HW_RTOS_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	clk_i2c0: clk_i2c0@RZN1_CLK_I2C0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_I2C0_ID>;
+		clocks = <&div_i2c>;
+	};
+	clk_i2c1: clk_i2c1@RZN1_CLK_I2C1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_I2C1_ID>;
+		clocks = <&div_i2c>;
+	};
+	clk_mii_ref: clk_mii_ref@RZN1_CLK_MII_REF_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_MII_REF_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_nand: clk_nand@RZN1_CLK_NAND_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_NAND_ID>;
+		clocks = <&div_nand>;
+	};
+	clk_nousbp2_pg6: clk_nousbp2_pg6@RZN1_CLK_NOUSBP2_PG6_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_NOUSBP2_PG6_ID>;
+		clocks = <&div_p2_pg>;
+	};
+	clk_p1_pg2: clk_p1_pg2@RZN1_CLK_P1_PG2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P1_PG2_ID>;
+		clocks = <&div_p1_pg>;
+	};
+	clk_p1_pg3: clk_p1_pg3@RZN1_CLK_P1_PG3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P1_PG3_ID>;
+		clocks = <&div_p1_pg>;
+	};
+	clk_p1_pg4: clk_p1_pg4@RZN1_CLK_P1_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P1_PG4_ID>;
+		clocks = <&div_p1_pg>;
+	};
+	clk_p4_pg3: clk_p4_pg3@RZN1_CLK_P4_PG3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P4_PG3_ID>;
+		clocks = <&div_p4_pg>;
+	};
+	clk_p4_pg4: clk_p4_pg4@RZN1_CLK_P4_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P4_PG4_ID>;
+		clocks = <&div_p4_pg>;
+	};
+	clk_p6_pg1: clk_p6_pg1@RZN1_CLK_P6_PG1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P6_PG1_ID>;
+		clocks = <&div_p6_pg>;
+	};
+	clk_p6_pg2: clk_p6_pg2@RZN1_CLK_P6_PG2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P6_PG2_ID>;
+		clocks = <&div_p6_pg>;
+	};
+	clk_p6_pg3: clk_p6_pg3@RZN1_CLK_P6_PG3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P6_PG3_ID>;
+		clocks = <&div_p6_pg>;
+	};
+	clk_p6_pg4: clk_p6_pg4@RZN1_CLK_P6_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P6_PG4_ID>;
+		clocks = <&div_p6_pg>;
+	};
+	clk_pci_usb: clk_pci_usb@RZN1_CLK_PCI_USB_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_PCI_USB_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_48: clk_pll_usb: clk_pll_usb {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <48000000>;
+		clocks = <&clkin_d2>;
+	};
+	clk_ptp_mac0: clk_ptp_mac0 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk25>, <&clk50>;
+	};
+	clk_ptp_mac1: clk_ptp_mac1 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk25>, <&clk50>;
+	};
+	clk_ptp_switch: clk_ptp_switch {
+		#clock-cells = <0>;
+	};
+	clk_qspi0: clk_qspi0@RZN1_CLK_QSPI0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_QSPI0_ID>;
+		clocks = <&div_qspi0>;
+	};
+	clk_qspi1: clk_qspi1@RZN1_CLK_QSPI1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_QSPI1_ID>;
+		clocks = <&div_qspi1>;
+	};
+	clk_ddrphy_pclk: clk_fw_ace: clk_cm3_dapclk_apb: 
+		clk_cm3_dapclk_ahb: clk_cm3_dapclk_axi: clk_cm3_hclk: 
+		clk_cm3_atclk: clk_cm3_dapclk: clk_ram_sys: clk_fw: 
+		clk_fw_ddr_ahb: clk_crypto_pe: clk_crypto_aes: 
+		clk_crypto_des: clk_crypto_arc4: clk_crypto_hash: clk_ref_sync_d4: clk_ref_sync_d4 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <4>;
+		clock-mult = <1>;
+		clocks = <&clk_ref_sync>;
+	};
+	clk_fwdiv2: clk_ref_sync_d8: clk_ref_sync_d8 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <8>;
+		clock-mult = <1>;
+		clocks = <&clk_ref_sync>;
+	};
+	clk_rgmii_ref: clk_rgmii_ref@RZN1_CLK_RGMII_REF_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_RGMII_REF_ID>;
+		clocks = <&clkout_d8>;
+	};
+	clk_rmii_ref: clk_rmii_ref@RZN1_CLK_RMII_REF_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_RMII_REF_ID>;
+		clocks = <&clkout_d20>;
+	};
+	clk_rxgmii_mac0: clk_rxgmii_mac0 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&eth_tx_clk>, <&clk50>;
+	};
+	clk_rxgmii_mac1: clk_rxgmii_mac1 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&clk125>, <&clk50>;
+	};
+	clk_sdio0: clk_sdio0@RZN1_CLK_SDIO0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SDIO0_ID>;
+		clocks = <&div_sdio0>;
+	};
+	clk_sdio1: clk_sdio1@RZN1_CLK_SDIO1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SDIO1_ID>;
+		clocks = <&div_sdio1>;
+	};
+	clk_sercos100: clk_sercos100@RZN1_CLK_SERCOS100_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SERCOS100_ID>;
+		clocks = <&clkout_d10>;
+	};
+	clk_sercos100_d2: clk_sercos100_d2 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <2>;
+		clock-mult = <1>;
+		clocks = <&clk_sercos100>;
+	};
+	clk_sercos50: clk_sercos50@RZN1_CLK_SERCOS50_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SERCOS50_ID>;
+		clocks = <&clk_sercos100_d2>;
+	};
+	clk_slcd: clk_slcd@RZN1_CLK_SLCD_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SLCD_ID>;
+		clocks = <&div_p1_pg>;
+	};
+	clk_spi0: clk_spi0@RZN1_CLK_SPI0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI0_ID>;
+		clocks = <&div_p3_pg>;
+	};
+	clk_spi1: clk_spi1@RZN1_CLK_SPI1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI1_ID>;
+		clocks = <&div_p3_pg>;
+	};
+	clk_spi2: clk_spi2@RZN1_CLK_SPI2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI2_ID>;
+		clocks = <&div_p3_pg>;
+	};
+	clk_spi3: clk_spi3@RZN1_CLK_SPI3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI3_ID>;
+		clocks = <&div_p3_pg>;
+	};
+	clk_spi4: clk_spi4@RZN1_CLK_SPI4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI4_ID>;
+		clocks = <&div_p4_pg>;
+	};
+	clk_spi5: clk_spi5@RZN1_CLK_SPI5_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI5_ID>;
+		clocks = <&div_p4_pg>;
+	};
+	clk_switch: clk_switch@RZN1_CLK_SWITCH_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SWITCH_ID>;
+		clocks = <&div_switch>;
+	};
+	clk_txgmii_mac0: clk_txgmii_mac0 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk50>, <&clk25>,
+			 <&clk2_5>, <&eth_rx_clk>, <&eth_tx_clk>;
+	};
+	clk_txgmii_mac1: clk_txgmii_mac1 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk50>, <&clk25>,
+			 <&clk2_5>, <&eth_rx_clk>, <&eth_tx_clk>;
+	};
+	clk_txgmii_switch: clk_txgmii_switch {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk50>, <&clk25>,
+			 <&clk2_5>, <&eth_rx_clk>, <&eth_tx_clk>;
+	};
+	clk_40_sysctrl: clkin: clkin {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <40000000>;
+	};
+	clk_20_otp: clkin_d2: clkin_d2 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <2>;
+		clock-mult = <1>;
+		clocks = <&clkin>;
+	};
+	clkout: clkout {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <1000000000>;
+	};
+	clkout_d10: clkout_d10 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <10>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	msebis_clk: msebim_clk: clkout_d16: clkout_d16 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <16>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk_cm3_stclk: clkout_d160: clkout_d160 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <160>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk_ddrphy_sr_hrclk: clk_ddrphy_pllclk: clkout_d1or2: clkout_d1or2 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3>;
+		renesas,rzn1-div-min = <1>;
+		renesas,rzn1-div-max = <2>;
+		clocks = <&clkout>;
+	};
+	clk50: clkout_d20: clkout_d20 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <20>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk25: clk_25: clkout_d40: clkout_d40 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <40>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk2_5: clkout_d400: clkout_d400 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <400>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clkout_d5: clkout_d5 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <5>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk125: clkout_d8: clkout_d8 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <8>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	ddr_pll_nr: ddr_pll_nr {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+	};
+	div_adc: div_adc@RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <50>;
+		renesas,rzn1-div-max = <250>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV>;
+		clocks = <&clkout>;
+	};
+	clk_a7mp: div_ca7: div_ca7@RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x7>;
+		renesas,rzn1-div-min = <1>;
+		renesas,rzn1-div-max = <4>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV>;
+		renesas,rzn1-div-table = <1 2 4>;
+		clocks = <&clk_ref_sync>;
+	};
+	div_i2c: div_i2c@RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x1f>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <16>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV>;
+		clocks = <&clkout>;
+	};
+	clk_motordiv: clk_motor: div_motor: div_motor@RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xf>;
+		renesas,rzn1-div-min = <2>;
+		renesas,rzn1-div-max = <8>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV>;
+		clocks = <&clkout_d5>;
+	};
+	div_nand: div_nand@RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3f>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <32>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV>;
+		clocks = <&clkout>;
+	};
+	div_p1_pg: div_p1_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <200>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV>;
+		clocks = <&clkout>;
+	};
+	div_p2_pg: div_p2_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV>;
+		clocks = <&clkout>;
+	};
+	div_p3_pg: div_p3_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <8>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV>;
+		clocks = <&clkout>;
+	};
+	div_p4_pg: div_p4_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <8>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV>;
+		clocks = <&clkout>;
+	};
+	clk_p5_pg1: div_p5_pg: div_p5_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3f>;
+		renesas,rzn1-div-min = <10>;
+		renesas,rzn1-div-max = <40>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV>;
+		clocks = <&clkout>;
+	};
+	div_p6_pg: div_p6_pg@RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x7f>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <64>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV>;
+		clocks = <&clkout>;
+	};
+	div_qspi0: div_qspi0@RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x7>;
+		renesas,rzn1-div-min = <3>;
+		renesas,rzn1-div-max = <7>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV>;
+		clocks = <&clkout>;
+	};
+	div_qspi1: div_qspi1@RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x7>;
+		renesas,rzn1-div-min = <3>;
+		renesas,rzn1-div-max = <7>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV>;
+		clocks = <&clkout>;
+	};
+	clk_ref_sync: ddr_clk_div: div_ref_sync: div_ref_sync@RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x1f>;
+		renesas,rzn1-div-min = <2>;
+		renesas,rzn1-div-max = <16>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV>;
+		renesas,rzn1-div-table = <2 4 8 16>;
+		clocks = <&clkout>;
+	};
+	div_sdio0: div_sdio0@RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <20>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV>;
+		clocks = <&clkout>;
+	};
+	div_sdio1: div_sdio1@RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <20>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV>;
+		clocks = <&clkout>;
+	};
+	div_switch: div_switch@RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3f>;
+		renesas,rzn1-div-min = <5>;
+		renesas,rzn1-div-max = <40>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV>;
+		clocks = <&clkout>;
+	};
+	div_uart: div_uart@RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV>;
+		clocks = <&clkout>;
+	};
+	eth_rx_clk: eth_rx_clk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+	};
+	eth_tx_clk: eth_tx_clk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+	};
+	hclk_adc: hclk_adc@RZN1_HCLK_ADC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_ADC_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_can0: hclk_can0@RZN1_HCLK_CAN0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CAN0_ID>;
+		clocks = <&clk_48>;
+	};
+	hclk_can1: hclk_can1@RZN1_HCLK_CAN1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CAN1_ID>;
+		clocks = <&clk_48>;
+	};
+	hclk_cm3: hclk_cm3@RZN1_HCLK_CM3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CM3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_crypto_eip150: hclk_crypto_eip150@RZN1_HCLK_CRYPTO_EIP150_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CRYPTO_EIP150_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_crypto_eip93: hclk_crypto_eip93@RZN1_HCLK_CRYPTO_EIP93_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CRYPTO_EIP93_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_ddrc: hclk_ddrc@RZN1_HCLK_DDRC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_DDRC_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_deltasigma: hclk_deltasigma@RZN1_HCLK_DELTASIGMA_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_DELTASIGMA_ID>;
+		clocks = <&div_motor>;
+	};
+	hclk_dma0: hclk_dma0@RZN1_HCLK_DMA0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_DMA0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_dma1: hclk_dma1@RZN1_HCLK_DMA1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_DMA1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_ecat125: hclk_ecat125@RZN1_HCLK_ECAT125_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_ECAT125_ID>;
+		clocks = <&clkout_d8>;
+	};
+	hclk_gmac0: hclk_gmac0@RZN1_HCLK_GMAC0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GMAC0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_gmac1: hclk_gmac1@RZN1_HCLK_GMAC1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GMAC1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_gpio0: hclk_gpio0@RZN1_HCLK_GPIO0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GPIO0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_gpio1: hclk_gpio1@RZN1_HCLK_GPIO1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GPIO1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_gpio2: hclk_gpio2@RZN1_HCLK_GPIO2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GPIO2_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_hsr: hclk_hsr@RZN1_HCLK_HSR_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_HSR_ID>;
+		clocks = <&clk_hsr_dup_d2>;
+	};
+	hclk_i2c0: hclk_i2c0@RZN1_HCLK_I2C0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_I2C0_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_i2c1: hclk_i2c1@RZN1_HCLK_I2C1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_I2C1_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_lcd: hclk_lcd@RZN1_HCLK_LCD_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_LCD_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_msebi_m: hclk_msebi_m@RZN1_HCLK_MSEBI_M_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_MSEBI_M_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_msebi_s: hclk_msebi_s@RZN1_HCLK_MSEBI_S_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_MSEBI_S_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_nand: hclk_nand@RZN1_HCLK_NAND_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_NAND_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg19: hclk_pg19@RZN1_HCLK_PG19_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG19_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg20: hclk_pg20@RZN1_HCLK_PG20_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG20_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg3: hclk_pg3@RZN1_HCLK_PG3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg4: hclk_pg4@RZN1_HCLK_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG4_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg_i: hclk_pg_i@RZN1_HCLK_PG_I_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG_I_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pinconfig: hclk_pinconfig@RZN1_HCLK_PINCONFIG_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PINCONFIG_ID>;
+		clocks = <&clkout_d40>;
+	};
+	hclk_pwmpto: hclk_pwmpto@RZN1_HCLK_PWMPTO_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PWMPTO_ID>;
+		clocks = <&div_motor>;
+	};
+	hclk_qspi0: hclk_qspi0@RZN1_HCLK_QSPI0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_QSPI0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_qspi1: hclk_qspi1@RZN1_HCLK_QSPI1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_QSPI1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_rom: hclk_rom@RZN1_HCLK_ROM_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_ROM_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_rsv: hclk_rsv@RZN1_HCLK_RSV_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_RSV_ID>;
+		clocks = <&clk_48>;
+	};
+	hclk_rtc: hclk_rtc@RZN1_HCLK_RTC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_RTC_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_sdio0: hclk_sdio0@RZN1_HCLK_SDIO0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SDIO0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_sdio1: hclk_sdio1@RZN1_HCLK_SDIO1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SDIO1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_semap: hclk_semap@RZN1_HCLK_SEMAP_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SEMAP_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_sercos: hclk_sercos@RZN1_HCLK_SERCOS_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SERCOS_ID>;
+		clocks = <&clkout_d10>;
+	};
+	hclk_sgpio0: hclk_sgpio0@RZN1_HCLK_SGPIO0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO0_ID>;
+		clocks = <&div_motor>;
+	};
+	hclk_sgpio1: hclk_sgpio1@RZN1_HCLK_SGPIO1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO1_ID>;
+		clocks = <&div_motor>;
+	};
+	hclk_sgpio2: hclk_sgpio2@RZN1_HCLK_SGPIO2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO2_ID>;
+		clocks = <&div_p5_pg>;
+	};
+	hclk_sgpio3: hclk_sgpio3@RZN1_HCLK_SGPIO3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO3_ID>;
+		clocks = <&div_p5_pg>;
+	};
+	hclk_sgpio4: hclk_sgpio4@RZN1_HCLK_SGPIO4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO4_ID>;
+		clocks = <&div_p5_pg>;
+	};
+	hclk_spi0: hclk_spi0@RZN1_HCLK_SPI0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi1: hclk_spi1@RZN1_HCLK_SPI1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi2: hclk_spi2@RZN1_HCLK_SPI2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI2_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi3: hclk_spi3@RZN1_HCLK_SPI3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi4: hclk_spi4@RZN1_HCLK_SPI4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI4_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi5: hclk_spi5@RZN1_HCLK_SPI5_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI5_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_switch: hclk_switch@RZN1_HCLK_SWITCH_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SWITCH_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_switch_rg: hclk_switch_rg@RZN1_HCLK_SWITCH_RG_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SWITCH_RG_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_timer0: hclk_timer0@RZN1_HCLK_TIMER0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_TIMER0_ID>;
+		clocks = <&clkout_d40>;
+	};
+	hclk_timer1: hclk_timer1@RZN1_HCLK_TIMER1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_TIMER1_ID>;
+		clocks = <&clkout_d40>;
+	};
+	hclk_uart0: hclk_uart0@RZN1_HCLK_UART0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART0_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_uart1: hclk_uart1@RZN1_HCLK_UART1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART1_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_uart2: hclk_uart2@RZN1_HCLK_UART2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART2_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_uart3: hclk_uart3@RZN1_HCLK_UART3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_uart4: hclk_uart4@RZN1_HCLK_UART4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART4_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_uart5: hclk_uart5@RZN1_HCLK_UART5_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART5_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_uart6: hclk_uart6@RZN1_HCLK_UART6_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART6_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_uart7: hclk_uart7@RZN1_HCLK_UART7_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART7_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_usbf: hclk_usbf@RZN1_HCLK_USBF_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_USBF_ID>;
+		clocks = <&clkout_d8>;
+	};
+	hclk_usbh: hclk_usbh@RZN1_HCLK_USBH_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_USBH_ID>;
+		clocks = <&clkout_d8>;
+	};
+	hclk_usbpm: hclk_usbpm@RZN1_HCLK_USBPM_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_USBPM_ID>;
+		clocks = <&clkout_d8>;
+	};
+	rgmii_refclk: rgmii_refclk {
+		#clock-cells = <0>;
+	};
+	rtos_mdc: rtos_mdc@RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3ff>;
+		renesas,rzn1-div-min = <80>;
+		renesas,rzn1-div-max = <640>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV>;
+		renesas,rzn1-div-table = <80 160 320 640>;
+		clocks = <&clk_ref_sync>;
+	};
+};
diff --git a/arch/arm/dts/rzn1.dtsi b/arch/arm/dts/rzn1.dtsi
new file mode 100644
index 0000000..bf40fdd
--- /dev/null
+++ b/arch/arm/dts/rzn1.dtsi
@@ -0,0 +1,929 @@
+/*
+ * Device Tree Source for the Renesas RZ/N1 SoC
+ *
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <renesas/pinctrl-rzn1.h>
+#include <renesas/rzn1-clocks.h>
+#include <renesas/rzn1-irq.h>
+#include <renesas/rzn1-memory-map.h>
+#include <renesas/rzn1-sysctrl.h>
+
+#include "skeleton.dtsi"
+
+/ {
+	compatible = "renesas,rzn1";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen {
+		/* These nodes are specific to the rzn1, and are CAN by the
+		 * bootloader. They are optional
+		   rzn1,bootaddr = <0xxxxxxxxx>  -- this property is set
+		        by the bootloader when it starts in NONSEC mode, this
+		        property will contain the address that the second CA7
+		        core is 'parked' at, and where it is looking for the
+		        boot address code the kernel will pass to it to start it.
+		        This property should not be set manually.
+		   rzn1,h2mode   -- this bool property, if present, will force
+		        the kernel to configure the USB subsystem in 'host' mode,
+		        this mode will prevent the usbf 'device' driver to start.
+		        This property can be set by the bootloader in case there
+		        is a GPIO for this configutation, otherwise, it can also
+		        be set manually in the device tree to force a config.
+		 */
+	};
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&clk_a7mp>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0>;
+		};
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <1>;
+		};
+	};
+	aliases {
+		serial0 = &uart0;
+		pinctrl = &pinctrl;
+		clocks = &clocks;
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		spi0 = &qspi0;
+	};
+	clocks: clocks@0 {
+		compatible = "renesas,rzn1-clock";
+		reg = <RZN1_SYSTEM_CTRL_BASE RZN1_SYSTEM_CTRL_SIZE>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		/* Most of the clock definition is declared in the
+		 * autogenerated file rzn1-clocks.dtsi
+		 * Here we find the 'exceptions' - mostly grouping clocks
+		 * together to attach to drivers */
+
+		/* Needed for pinctrl access !*/
+		hclk_pinconfig { renesas,no-disable; };
+
+		clk_ddr_grp: clk_ddr_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_ddrc &hclk_ddrc>;
+		};
+		all_usbf: all_usbf {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&hclk_usbf &hclk_usbpm &clk_48_pg_f>;
+		};
+		/* USB Host Needs the USB Device clocks(!) since the EPCTR
+		 * register is in the USBF register map, and that register is
+		 * needed to start the PLL */
+		all_usbh: all_usbh {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&hclk_usbh &hclk_usbpm &clk_pci_usb &all_usbf>;
+		};
+		all_lcd: all_lcd {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&hclk_lcd &hclk_pg_i>;
+		};
+		clk_switch_all: clk_switch_all {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&hclk_switch &clk_switch>;
+		};
+		clk_rgmii_conv_all: clk_rgmii_conv_all {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_mii_ref &clk_rmii_ref &clk_rgmii_ref &hclk_switch_rg>;
+		};
+		uart_group_34567: uart_group_34567 {
+			#clock-cells = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "renesas,rzn1-clock-bitselect";
+			/* Bit 24 is UARTCLKSEL */
+			reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2>;
+			renesas,rzn1-sel-bit = <24>;
+
+			/* If that bit is zero, use first parent, else,
+			 * use second parent */
+			clocks = <&div_p2_pg>, <&clk_48>;
+
+			/* First group are gates for when selector bit
+			 * is zero, second group is the gates to use when
+			 * bit is 'one' */
+			renesas,rzn1-gates =
+			      <RZN1_CLK_UART3_ID RZN1_CLK_UART4_ID
+				RZN1_CLK_UART5_ID RZN1_CLK_UART6_ID
+				RZN1_CLK_UART7_ID>,
+			      <RZN1_CLK_USBUART3_ID RZN1_CLK_USBUART4_ID
+				RZN1_CLK_USBUART5_ID RZN1_CLK_USBUART6_ID
+				RZN1_CLK_USBUART7_ID>;
+
+			gsclk_uart3: gsclk_uart3@0 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <0>;
+			 };
+			gsclk_uart4: gsclk_uart4@1 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <1>;
+			 };
+			gsclk_uart5: gsclk_uart5@2 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <2>;
+			 };
+			gsclk_uart6: gsclk_uart6@3 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <3>;
+			 };
+			gsclk_uart7: gsclk_uart7@4 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <4>;
+			 };
+		 };
+		 uart_group_012: uart_group_012@RZN1_SYSCTRL_REG_PWRCTRL_PG0_0 {
+			#clock-cells = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "renesas,rzn1-clock-bitselect";
+			/* Bit 24 is UARTCLKSEL */
+			reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_0>;
+			renesas,rzn1-sel-bit = <30>;
+
+			/* If that bit is zero, use first parent, else,
+			 * use second parent */
+			clocks = <&div_uart>, <&clk_48>;
+
+			/* First group are gates for when selector bit
+			 * is zero, second group is the gates to use when
+			 * bit is 'one' */
+			renesas,rzn1-gates =
+			      <RZN1_CLK_UART0_ID RZN1_CLK_UART1_ID
+				RZN1_CLK_UART2_ID>,
+			      <RZN1_CLK_USBUART0_ID RZN1_CLK_USBUART1_ID
+				RZN1_CLK_USBUART2_ID>;
+			gsclk_uart0: gsclk_uart0@0 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_012>;
+				reg = <0>;
+			 };
+			gsclk_uart1: gsclk_uart1@1 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_012>;
+				reg = <1>;
+			 };
+			gsclk_uart2: gsclk_uart2@2 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_012>;
+				reg = <2>;
+			};
+		};
+		sclk_uart0_grp: sclk_uart0_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart0 &hclk_uart0>;
+		};
+		sclk_uart1_grp: sclk_uart1_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart1 &hclk_uart1>;
+		};
+		sclk_uart2_grp: sclk_uart2_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart2 &hclk_uart2>;
+		};
+		sclk_uart3_grp: sclk_uart3_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart3 &hclk_uart3>;
+		};
+		sclk_uart4_grp: sclk_uart4_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart4 &hclk_uart4>;
+		};
+		sclk_uart5_grp: sclk_uart5_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart5 &hclk_uart5>;
+		};
+		sclk_uart6_grp: sclk_uart6_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart6 &hclk_uart6>;
+		};
+		sclk_uart7_grp: sclk_uart7_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart7 &hclk_uart7>;
+		};
+		clk_i2c0_grp: clk_i2c0_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_i2c0 &hclk_i2c0>;
+		};
+		clk_i2c1_grp: clk_i2c1_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_i2c1 &hclk_i2c1>;
+		};
+		clk_spi0_grp: clk_spi0_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi0>, <&hclk_spi0>;
+		};
+		clk_spi1_grp: clk_spi1_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi1>, <&hclk_spi1>;
+		};
+		clk_spi2_grp: clk_spi2_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi2>, <&hclk_spi2>;
+		};
+		clk_spi3_grp: clk_spi3_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi3>, <&hclk_spi3>;
+		};
+		clk_spi4_grp: clk_spi4_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi4>, <&hclk_spi4>;
+		};
+		clk_spi5_grp: clk_spi5_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi5>, <&hclk_spi5>;
+		};
+	};
+
+	arm_timer: timer {
+		compatible = "arm,armv7-timer";
+		arm,cpu-registers-not-fw-configured;
+		interrupts =
+			<GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	gic: interrupt-controller@RZN1_GIC_BASE {
+		compatible = "arm,cortex-a7-gic";
+		reg = <0x44101000 0x1000>,	/* Distributer */
+		      <0x44102000 0x1000>,	/* CPU interface */
+		      <0x44104000 0x2000>,	/* Virt interface control */
+		      <0x44106000 0x2000>;	/* Virt CPU interface */
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		interrupts =
+			<GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(2) |
+				IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	ipc: mailbox@RZN1_MAILBOX_BASE {
+	    compatible = "arm,pl320", "arm,primecell";
+	    reg = <RZN1_MAILBOX_BASE RZN1_MAILBOX_SIZE>;
+	    interrupts = <GIC_SPI RZN1_IRQ_IPCM_1 IRQ_TYPE_LEVEL_HIGH>;
+	    clocks = <&clk_fw>;
+	    clock-names = "apb_pclk";
+	};
+
+	gpioirq: gpioirq@RZN1_GPIO0_BASE {
+		compatible = "renesas,rzn1-gpioirq";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+
+		interrupts =
+			<GIC_SPI RZN1_IRQ_GPIO_0 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_1 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_2 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_3 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_4 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_5 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_6 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_7 IRQ_TYPE_LEVEL_HIGH>;
+
+		reg = <RZN1_GPIO0_BASE RZN1_GPIO0_SIZE>,
+			<RZN1_GPIO1_BASE RZN1_GPIO1_SIZE>,
+			<RZN1_GPIO2_BASE RZN1_GPIO2_SIZE>;
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		/* gpioirq-3 = <&gpio1a 12 GPIO_ACTIVE_HIGH>; */
+	};
+
+	bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		u-boot,dm-pre-reloc;
+
+		memory-controller@RZN1_DDR_BASE {
+			compatible = "cadence,ddr-ctrl";
+			reg = <RZN1_DDR_BASE RZN1_DDR_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_DDRSUB IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clk_ddr_grp>;
+			status = "okay";
+		};
+		pinctrl: pinctrl@RZN1_PINCTRL_BASE {
+			compatible = "renesas,rzn1-pinctrl";
+			reg = <RZN1_PINCTRL_BASE RZN1_PINCTRL_SIZE>,
+				<RZN1_PINCTRL_L2_BASE RZN1_PINCTRL_L2_SIZE>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+		};
+		timer0: timer@RZN1_TIMER0_BASE {
+			compatible = "renesas,rzn1-timer";
+			reg = <RZN1_TIMER0_BASE RZN1_TIMER0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_TIMER0_0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_2 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_3 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_4 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_5 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_6 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_timer0>;
+			renesas,use-prescaler;
+			status = "disabled";
+		};
+		timer1: timer@RZN1_TIMER1_BASE {
+			compatible = "renesas,rzn1-timer";
+			reg = <RZN1_TIMER1_BASE RZN1_TIMER1_SIZE>;
+			renesas,timer-number = <1>;
+			interrupts = <GIC_SPI RZN1_IRQ_TIMER1_0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_2 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_3 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_4 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_5 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_6 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_timer1>;
+			renesas,use-prescaler;
+			status = "disabled";
+		};
+		uart0: serial@RZN1_UART0_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART0_BASE RZN1_UART0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART0 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart0_grp>;
+			status = "disabled";
+		};
+		uart1: serial@RZN1_UART1_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART1_BASE RZN1_UART1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART1 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart1_grp>;
+			status = "disabled";
+		};
+		uart2: serial@RZN1_UART2_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART2_BASE RZN1_UART2_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART2 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart2_grp>;
+			status = "disabled";
+		};
+		uart3: serial@RZN1_UART3_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART3_BASE RZN1_UART3_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART3 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart3_grp>;
+			status = "disabled";
+		};
+		uart4: serial@RZN1_UART4_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART4_BASE RZN1_UART4_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART4 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart4_grp>;
+			status = "disabled";
+		};
+		uart5: serial@RZN1_UART5_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART5_BASE RZN1_UART5_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART5 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart5_grp>;
+			status = "disabled";
+		};
+		uart6: serial@RZN1_UART6_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART6_BASE RZN1_UART6_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART6 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart6_grp>;
+			status = "disabled";
+		};
+		uart7: serial@RZN1_UART7_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART7_BASE RZN1_UART7_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART7 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart7_grp>;
+			status = "disabled";
+		};
+		i2c0: i2c@RZN1_I2C0_BASE {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <RZN1_I2C0_BASE RZN1_I2C0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_I2C0 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_i2c0_grp>;
+			clock-frequency = <100000>;
+			status = "disabled";
+		};
+		i2c1: i2c@RZN1_I2C1_BASE {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <RZN1_I2C1_BASE RZN1_I2C1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_I2C1 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_i2c1_grp>;
+			clock-frequency = <100000>;
+			status = "disabled";
+		};
+		rtc0: rtc@RZN1_RTC_BASE {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "renesas,rzn1-rtc";
+			reg = <RZN1_RTC_BASE RZN1_RTC_SIZE>;
+			clock-names = "axi";
+			clocks = <&hclk_rtc>;
+			interrupt-names = "alarm", "intr", "1hz";
+			interrupts =
+				<GIC_SPI RZN1_IRQ_RTCATINTAL IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI RZN1_IRQ_RTCATINTR IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI RZN1_IRQ_RTCATINT1S IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+		};
+		gmac0: ethernet@RZN1_GMAC0_BASE {
+			compatible = "snps,dwmac-3.72a", "snps,dwmac";
+			reg = <RZN1_GMAC0_BASE RZN1_GMAC0_SIZE>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI RZN1_IRQ_SBD0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_LPI0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_PMT0 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq", "eth_lpi", "eth_wake_irq";
+			clock-names = "stmmaceth";
+			clocks = <&hclk_gmac0>;
+			status = "disabled";
+		};
+		gmac1: ethernet@RZN1_GMAC1_BASE {
+			compatible = "snps,dwmac-3.72a", "snps,dwmac";
+			reg = <RZN1_GMAC1_BASE RZN1_GMAC1_SIZE>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI RZN1_IRQ_SBD1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_LPI1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_PMT1 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq", "eth_lpi", "eth_wake_irq";
+			clock-names = "stmmaceth";
+			clocks = <&hclk_gmac1>;
+			status = "disabled";
+		};
+		switch: ethswitch: eth-switch@RZN1_SWITCH_BASE {
+			compatible = "mtip,5pt_switch";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <RZN1_SWITCH_BASE RZN1_SWITCH_SIZE>;
+			clock-names = "fck";
+			clocks = <&clk_switch_all>;
+			status = "disabled";
+		};
+		eth_miic: eth-miic@RZN1_SWITCH_CTRL_REG_BASE {
+			compatible = "renesas,rzn1-miic";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <RZN1_SWITCH_CTRL_REG_BASE RZN1_SWITCH_CTRL_REG_SIZE>;
+			status = "disabled";
+			clocks = <&clk_rgmii_conv_all>;
+		};
+
+		dma0: dma-controller@RZN1_DMA0_BASE {
+			compatible = "snps,dma-rzn1";
+			reg = <RZN1_DMA0_BASE RZN1_DMA0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_DMA0 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "hclk";
+			clocks = <&hclk_dma0>;
+			dma-channels = <8>;
+			dma-requests = <16>;
+			dma-masters = <1>;
+			#dma-cells = <3>;
+			block_size = <0xfff>;
+			data_width = <3>;
+			status = "disabled";
+		};
+		dma1: dma-controller@RZN1_DMA1_BASE {
+			compatible = "snps,dma-rzn1";
+			reg = <RZN1_DMA1_BASE RZN1_DMA1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_DMA1 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "hclk";
+			clocks = <&hclk_dma1>;
+			dma-channels = <8>;
+			dma-requests = <16>;
+			dma-masters = <1>;
+			#dma-cells = <3>;
+			block_size = <0xfff>;
+			data_width = <3>;
+			status = "disabled";
+		};
+		sdio0: sdhci@RZN1_SDIO0_BASE {
+			compatible = "arasan,sdhci-8.9a";
+			reg = <RZN1_SDIO0_BASE RZN1_SDIO0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SDIO0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_SDIO0_WKUP IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "clk_xin", "clk_ahb";
+			clocks = <&clk_sdio0>, <&hclk_sdio0>;
+			no-1-8-v;
+			status = "disabled";
+		};
+		sdio1: sdhci@RZN1_SDIO1_BASE {
+			compatible = "arasan,sdhci-8.9a";
+			reg = <RZN1_SDIO1_BASE RZN1_SDIO1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SDIO1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_SDIO1_WKUP IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "clk_xin", "clk_ahb";
+			clocks = <&clk_sdio1>, <&hclk_sdio1>;
+			no-1-8-v;
+			status = "disabled";
+		};
+		qspi: qspi0: spi@RZN1_QSPI_BASE {
+			compatible = "renesas,rzn1-qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <RZN1_QSPI_BASE RZN1_QSPI_SIZE
+				RZN1_V_QSPI_BASE RZN1_V_QSPI_SIZE>;
+			reg-names = "qspi", "qspi-mapping";
+			interrupts = <GIC_SPI RZN1_IRQ_QSPI0 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_qspi0>, <&clk_qspi0>;
+			clock-names = "flexway", "pclk";
+			status = "disabled";
+		};
+		nand: nand@RZN1_NAND_BASE {
+			compatible = "evatronix,nandflash-ctrl";
+			reg = <RZN1_NAND_BASE RZN1_NAND_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_NAND IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_nand>, <&clk_nand>;
+			clock-names = "clka", "clkb";
+			#address-cells		= <1>;
+			#size-cells		= <1>;
+			status = "disabled";
+		};
+		/*
+		 * SPI 0-3 are Master; 4-5 are Slave. 4-16 bits data width
+		 * dw_apb-ssi is configured with 16*16 bits FIFO in both
+		 * directions.
+		 * 4 Chipselects for the master interfaces, 1 for slaves
+		 */
+		spi0: spi@RZN1_SPI0_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI0_BASE RZN1_SPI0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI0 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi0_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <4>;
+			status = "disabled";
+		};
+		spi1: spi@RZN1_SPI1_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI1_BASE RZN1_SPI1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI1 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi1_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <4>;
+			status = "disabled";
+		};
+		spi2: spi@RZN1_SPI2_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI2_BASE RZN1_SPI2_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI2 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi2_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <4>;
+			status = "disabled";
+		};
+		spi3: spi@RZN1_SPI3_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI3_BASE RZN1_SPI3_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI3 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi3_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <4>;
+			status = "disabled";
+		};
+		spi4: spi@RZN1_SPI4_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI4_BASE RZN1_SPI4_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI4 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi4_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <1>; /* Slave interface */
+			status = "disabled";
+		};
+		spi5: spi@RZN1_SPI5_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI5_BASE RZN1_SPI5_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI5 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi5_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <1>; /* Slave interface */
+			status = "disabled";
+		};
+		usbphy: usbphy0: usbphy@0 {
+			#phy-cells = <0>;
+			compatible = "usb-nop-xceiv";
+			status = "disabled";
+		};
+		usbf: usbf@RZN1_USB_DEV_BASE {
+			compatible = "renesas,rzn1-usbf";
+			reg = <RZN1_USB_DEV_BASE RZN1_USB_DEV_SIZE>;
+			interrupts =
+				<GIC_SPI RZN1_IRQ_USBF_EPC IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI RZN1_IRQ_USBF IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "axi";
+			clocks = <&all_usbf>;
+
+			renesas,sram-size = <5024>; /* 32 bits words */
+			/* Allow 4 x 512 byte packets per endpoint to support MTU of 1500.
+			Due to protocol overheads, 3 x 512 byte packets is not enough. */
+			renesas,sram-conf,g_ether = <4 2 0>;
+			renesas,sram-conf,g_mass_storage = <8 8 0 0 0 0>;
+			status = "disabled";
+		};
+		usbh_pci: pci@RZN1_USB_HOST_BASE {
+			compatible = "renesas,pci-rzn1";
+			device_type = "pci";
+			clock-names = "axi";
+			clocks = <&all_usbh>;
+			reg = <(RZN1_USB_HOST_BASE+0x10000) 0xc00>,
+			      <RZN1_USB_HOST_BASE 0x1100>;
+			interrupts = <GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+
+			bus-range = <0 0>;
+			#address-cells = <3>;
+			#size-cells = <1>;
+			#interrupt-cells = <1>;
+			ranges = <0x02000000 0 RZN1_USB_HOST_BASE RZN1_USB_HOST_BASE 0x00010000>;
+			/* Should map all possible DDR as inbound ranges, but
+			   the IP only supports a 256MB, 512MB, or 1GB window */
+			/* flags, PCI addr (64-bit), CPU addr, PCI size (64-bit) */
+			dma-ranges = <0x42000000 0 0x80000000 0x80000000 0 0x40000000>;
+			interrupt-map-mask = <0xff00 0 0 0x7>;
+			interrupt-map = <0x0000 0 0 1 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH
+					 0x0800 0 0 1 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH
+					 0x1000 0 0 2 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH>;
+
+			usb@0,1 {
+				reg = <0x800 0 0 0>;
+				device_type = "pci";
+				phys = <&usbphy 0 0>;
+				phy-names = "usb";
+			};
+
+			usb@0,2 {
+				reg = <0x1000 0 0 0>;
+				device_type = "pci";
+				phys = <&usbphy 0 0>;
+				phy-names = "usb";
+			};
+		};
+		reset: reset@RZN1_RESET_BASE {
+			reg = <RZN1_RESET_BASE RZN1_RESET_SIZE>;
+			clocks = <&hclk_pinconfig>;
+		};
+		wdtsafe0: wdtsafe0@RZN1_WATCHDOGSAFE0_BASE {
+			compatible = "renesas,rzn1-watchdogsafe";
+			reg = <RZN1_WATCHDOGSAFE0_BASE RZN1_WATCHDOGSAFE0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_WATCHDOGSAFE0 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_pinconfig>;
+			status = "disabled";
+		};
+		wdtsafe1: wdtsafe1@RZN1_WATCHDOGSAFE1_BASE {
+			compatible = "renesas,rzn1-watchdogsafe";
+			reg = <RZN1_WATCHDOGSAFE1_BASE RZN1_WATCHDOGSAFE1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_WATCHDOGSAFE1 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_pinconfig>;
+			status = "disabled";
+		};
+		/*
+		 * The GPIO mapping to the corresponding pins is complicted,
+		 * see the hardware documentation for details.
+		 */
+		gpio0: gpio@RZN1_GPIO0_BASE {
+			compatible = "snps,dw-apb-gpio";
+			reg = <RZN1_GPIO0_BASE RZN1_GPIO0_SIZE>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&hclk_gpio0>;
+			status = "disabled";
+
+			gpio0a: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio0a";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&gpioirq>;
+				interrupts = <8>;
+			};
+			gpio0b: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio0b";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <1>;
+			};
+		};
+		gpio1: gpio@RZN1_GPIO1_BASE {
+			compatible = "snps,dw-apb-gpio";
+			reg = <RZN1_GPIO1_BASE RZN1_GPIO1_SIZE>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&hclk_gpio1>;
+			status = "disabled";
+
+			/* GPIO1a[0..4] corresponds to pins 45..49 */
+			/* GPIO1a[5..31] corresponds to pins 71..121 */
+			gpio1a: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio1a";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&gpioirq>;
+				interrupts = <9>;
+			};
+			/* GPIO1b[0..1] corresponds to pins 31..32 */
+			/* GPIO1b[2..4] corresponds to pins 35..37 */
+			/* GPIO1b[5..25] corresponds to pins 50..70 */
+			/* GPIO1b[26..31] corresponds to pins 150..155 */
+			gpio1b: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio1b";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <1>;
+			};
+		};
+		gpio2: gpio@RZN1_GPIO2_BASE {
+			compatible = "snps,dw-apb-gpio";
+			reg = <RZN1_GPIO2_BASE RZN1_GPIO2_SIZE>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&hclk_gpio2>;
+			status = "disabled";
+
+			/* GPIO2a[0..27] corresponds to pins 122..149 */
+			/* GPIO2a[28..31] corresponds to pins 156..159 */
+			gpio2a: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio2a";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&gpioirq>;
+				interrupts = <10>;
+			};
+			/* GPIO2b[0..9] corresponds to pins 160..169 */
+			gpio2b: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio2b";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <10>;
+				reg = <1>;
+			};
+		};
+		sgpio0: gpio@RZN1_SGPIO0_BASE {
+			reg = <RZN1_SGPIO0_BASE RZN1_SGPIO0_SIZE>;
+		};
+		sgpio1: gpio@RZN1_SGPIO1_BASE {
+			reg = <RZN1_SGPIO1_BASE RZN1_SGPIO1_SIZE>;
+		};
+		can0: can@RZN1_CAN0_BASE {
+			compatible = "nxp,sja1000";
+			reg = <RZN1_CAN0_BASE RZN1_CAN0_SIZE>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI RZN1_IRQ_CAN0 IRQ_TYPE_LEVEL_HIGH>;
+			nxp,no-cdr;
+			nxp,no-loopback;
+			clocks = <&hclk_can0>;
+			status = "disabled";
+		};
+		can1: can@RZN1_CAN1_BASE {
+			compatible = "nxp,sja1000";
+			reg = <RZN1_CAN1_BASE RZN1_CAN1_SIZE>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI RZN1_IRQ_CAN1 IRQ_TYPE_LEVEL_HIGH>;
+			nxp,no-cdr;
+			nxp,no-loopback;
+			clocks = <&hclk_can1>;
+			status = "disabled";
+		};
+		fb0: fb@RZN1_LCD_BASE {
+			compatible = "digitalblocks,db9000-clcd";
+			interrupts = <GIC_SPI RZN1_IRQ_LCD IRQ_TYPE_LEVEL_HIGH>;
+			reg = <RZN1_LCD_BASE RZN1_LCD_SIZE>;
+			clock-names = "pclk", "ahb";
+			clocks = <&clk_slcd>, <&all_lcd>;
+			status = "disabled";
+		};
+		msebi: msebim: memory-controller@RZN1_MSEBI_M0_BASE {
+			compatible = "renesas,rzn1-msebi";
+			#address-cells = <2>;
+			#size-cells = <1>;
+			reg = <RZN1_MSEBI_M0_BASE RZN1_MSEBI_M0_SIZE>;
+			clocks = <&hclk_msebi_m>;
+			interrupts = <GIC_SPI RZN1_IRQ_MSEBIM IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		/* These nodes are placeholders; they are refered to by the
+		 * pinmux file, but have no driver just yet, so we create
+		 * empty nodes for them until we can flesh it up */
+		unknown: s3: dsigma: mii: motor: unknown {
+		};
+	};
+
+};
+
+#include "rzn1-clocks.dtsi"
diff --git a/arch/arm/dts/rzn1d400-db.dts b/arch/arm/dts/rzn1d400-db.dts
new file mode 100644
index 0000000..4ddd9f4
--- /dev/null
+++ b/arch/arm/dts/rzn1d400-db.dts
@@ -0,0 +1,422 @@
+/*
+ * Device Tree Source for the RZN1-400 Demo Board
+ * This dts is for use when the Cortex M3 is controls GMAC1, the 5-Port Switch
+ * and the RGMII/GMII Converters.
+ *
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/dts-v1/;
+
+#include "rzn1.dtsi"
+#include "rzn1-clocks.dtsi"
+
+/ {
+	model = "RZ/N1D Demo Board";
+	compatible = "renesas,rzn1d-db", "renesas,rzn1";
+
+	chosen {
+		/*
+		 * This is a default command line to help with booting using
+		 * qemu and a ramdisk, it is not meant to stay in the final
+		 * file
+		 g_mass_storage.removable=y g_mass_storage.stall=n
+		 */
+		bootargs = "console=ttyS0,115200 earlyprintk debug rdinit=/linuxrc";
+		stdout-path = &uart0;
+		linux,stdout-path = &uart0;
+	};
+	c2c_sram@20080000 {
+		compatible = "mmio-sram";
+		reg = <0x20080000 0x3000>;
+	};
+	hoard: cat: nmi: rmii {
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+	leds {
+		compatible = "gpio-leds";
+
+		led_1 {
+			label = "pl_gpio92";
+			gpios = <&gpio1b 23 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "cpu0";
+		};
+		led_2 {
+			label = "pl_gpio93";
+			gpios = <&gpio1b 24 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "cpu1";
+		};
+		pca0 {
+			label = "pca0";
+			gpios = <&pca9698 0 GPIO_ACTIVE_HIGH>;
+		};
+		pca1 {
+			label = "pca1";
+			gpios = <&pca9698 1 GPIO_ACTIVE_HIGH>;
+		};
+		pca2 {
+			label = "pca2";
+			gpios = <&pca9698 2 GPIO_ACTIVE_HIGH>;
+		};
+		pca3 {
+			label = "pca3";
+			gpios = <&pca9698 3 GPIO_ACTIVE_HIGH>;
+		};
+		pca4 {
+			label = "pca4";
+			gpios = <&pca9698 4 GPIO_ACTIVE_HIGH>;
+		};
+		pca5 {
+			label = "pca5";
+			gpios = <&pca9698 5 GPIO_ACTIVE_HIGH>;
+		};
+		pca6 {
+			label = "pca6";
+			gpios = <&pca9698 6 GPIO_ACTIVE_HIGH>;
+		};
+		pca7 {
+			label = "pca7";
+			gpios = <&pca9698 7 GPIO_ACTIVE_HIGH>;
+		};
+
+		/* These aren't LEDs, they are gpios attached to the pca9698
+		 * port expander. They select the I2C master used to access the
+		 * EEPROM device. The ACTIVE LOW/HIGH settings ensures Linux
+		 * sets the correctly if not done by U-Boot.
+		 */
+		ctrl0 {
+			label = "ctrl0";
+			gpios = <&pca9698 16 GPIO_ACTIVE_LOW>;
+		};
+		ctrl1 {
+			label = "ctrl1";
+			gpios = <&pca9698 17 GPIO_ACTIVE_HIGH>;
+		};
+		ctrl2 {
+			label = "ctrl2";
+			gpios = <&pca9698 18 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+/* Map the USB pinmux to the peripheral port */
+#define usb usbh_pci
+/* ethX refers to the physical pins for each ethernet interface. Here we simply
+ * place them in the hoard node, and the users of the pins will then indicate
+ * are needed by adding a pinctrl-0 entry for them.
+ */
+#define eth0 hoard
+#define eth1 hoard
+#define eth2 hoard
+#define eth3 hoard
+#define eth4 hoard
+#define refclk hoard
+#define mdio0 hoard
+#define mdio1 hoard
+#define lcd fb0
+
+#include "rzn1d400_preset_db.dts"
+
+&gpioirq {
+	status = "okay";
+	gpioirq-0 = <&gpio2a 24 GPIO_ACTIVE_LOW>;	/* 146: ETH Port 1 IRQ */
+	gpioirq-1 = <&gpio2a 4 GPIO_ACTIVE_LOW>;	/* 126: ETH Port 2 IRQ */
+	gpioirq-2 = <&gpio1a 28 GPIO_ACTIVE_LOW>;	/* 118: ETH Port 3 IRQ */
+	gpioirq-3 = <&gpio2a 25 GPIO_ACTIVE_LOW>;	/* 147: ETH Port 4 IRQ */
+	gpioirq-4 = <&gpio2a 27 GPIO_ACTIVE_LOW>;	/* 149: ETH Port 5 IRQ */
+	gpioirq-5 = <&gpio2a 26 GPIO_ACTIVE_LOW>;	/* 148: TouchSCRN_IRQ  */
+};
+
+&uart0 {
+	status = "okay";
+	u-boot,dm-pre-reloc;
+};
+&uart2 {
+	status = "okay";
+};
+&uart3 {
+	status = "okay";
+};
+&i2c1 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pca9698: gpio@20 {
+		compatible = "nxp,pca9698";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		gpio-bank-name="pca";
+	};
+	lm75: lm75@49 {
+		/* Ext Board: Temperature sensor */
+		compatible = "lm75";
+		reg = <0x49>;
+	};
+	at24@50 {
+		compatible = "at24,24c64";
+		pagesize = <32>;
+		reg = <0x50>;
+	};
+	polytouch: edt-ft5x06@38 {
+		/* Ext Board: touch sensor on LCD */
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <5 0>;
+		touchscreen-size-x = <800>;
+		touchscreen-size-y = <480>;
+		// touchscreen-swapped-x-y;
+	};
+};
+&gpio1 {
+	status = "okay";
+};
+&gpio2 {
+	status = "okay";
+};
+
+&gmac0 {
+	/* Only accessible from the Ext Board */
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio0>, <&pins_eth0>;
+
+	phy-handle = <&phy_mii0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy_mii0: ethernet-phy@8 {
+			/* Ext Board: Marvell 88E1512 PHY on J22 */
+			device_type = "ethernet-phy";
+			phy-mode = "rgmii-id";
+			reg = <8>;
+			/* Set LED0 as active low link status, LED2 as interrupt */
+			marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+			interrupt-parent = <&gpioirq>;
+			interrupts = <0>;
+		};
+	};
+};
+&gmac1 {
+	status = "disabled";
+
+	/* Fixed 1Gbps link to the 5-port switch */
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+&ethswitch {
+	status = "disabled";
+	bus_freq = <2500000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio1>,
+		<&pins_eth1>, <&pins_eth2>, <&pins_eth3>, <&pins_eth4>;
+
+	phy-reset-gpios = <&gpio1b 25 GPIO_ACTIVE_HIGH>;
+	phy-reset-duration = <15>;
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	portA: phy_mii4: ethernet-phy@5 {
+		device_type = "ethernet-phy";
+		phy-mode = "mii";
+		reg = <5>;
+		/* Set LED0 as active low link status */
+		micrel,led-mode = <1>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <4>;
+	};
+	portB: phy_mii3: ethernet-phy@4 {
+		device_type = "ethernet-phy";
+		phy-mode = "mii";
+		reg = <4>;
+		/* Set LED0 as active low link status */
+		micrel,led-mode = <1>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <3>;
+	};
+	portC: phy_mii2: ethernet-phy@10 {
+		/* Ext Board: Marvell 88E1512 PHY on J24 */
+		device_type = "ethernet-phy";
+		phy-mode = "rgmii-id";
+		reg = <10>;
+		/* Set LED0 as active low link status, LED2 as interrupt */
+		marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <2>;
+	};
+	portD: phy_mii1: ethernet-phy@1 {
+		/* Ext Board: Marvell 88E1512 PHY on J23 */
+		device_type = "ethernet-phy";
+		phy-mode = "rgmii-id";
+		reg = <1>;
+		/* Set LED0 as active low link status, LED2 as interrupt */
+		marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <1>;
+	};
+};
+&eth_miic {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_refclk>;
+	/* RIN Mode Control - GMAC1 on all Switch ports */
+	mode_control = <0x13>;
+
+	mii0: eth-mii0 {
+		phy-handle = <&phy_mii0>;
+	};
+	mii1: eth-mii1 {
+		phy-handle = <&phy_mii1>;
+	};
+	mii2: eth-mii2 {
+		phy-handle = <&phy_mii2>;
+	};
+	mii3: eth-mii3 {
+		phy-handle = <&phy_mii3>;
+	};
+	mii4: eth-mii4 {
+		phy-handle = <&phy_mii4>;
+	};
+};
+&qspi0 {
+	status = "okay";
+	u-boot,dm-pre-reloc;
+
+	flash: mx25l25635@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "macronix,mx25l25635e", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <62500000>;
+		spi-cpha;
+		spi-cpol;
+		spi-rx-bus-width = <4>;
+		renesas,rzn1-read-cmd = <0x6b 8 0>;
+		renesas,rzn1-readcap-delay = <1>;
+		/* The properties below are used by U-Boot */
+		tshsl-ns = <30>;
+		tsd2d-ns = <3>;
+		tchsh-ns = <3>;
+		tslch-ns = <3>;
+		memory-map = <RZN1_V_QSPI_BASE RZN1_V_QSPI_SIZE>;
+		memory-map-write = <1>;
+		u-boot,dm-pre-reloc;
+
+		partition@0 {
+			/* 64KB */
+			label = "qspi0:spl";
+			reg = <0x0000000 0x00010000>;
+		};
+		partition@1 {
+			/* 64KB */
+			label = "qspi0:pkgt";
+			reg = <0x0010000 0x00010000>;
+		};
+		partition@2 {
+			/* 512KB */
+			label = "qspi0:u-boot";
+			reg = <0x0020000 0x00080000>;
+		};
+		partition@3 {
+			/* 64KB */
+			label = "qspi0:env";
+			reg = <0x00a0000 0x00010000>;
+		};
+		partition@4 {
+			/* 128KB */
+			label = "qspi0:dtb";
+			reg = <0x00b0000 0x00020000>;
+		};
+		partition@5 {
+			/* 1MB */
+			label = "qspi0:cm3";
+			reg = <0x00d0000 0x00100000>;
+		};
+		partition@6 {
+			/* 6MB */
+			label = "qspi0:kernel";
+			reg = <0x01d0000 0x00600000>;
+		};
+		partition@7 {
+			/* Remaining */
+			label = "qspi0:data";
+			reg = <0x07d0000 0>;
+		};
+	};
+};
+&usbf {
+	status = "okay";
+};
+&usbh_pci {
+	/* Ext Board */
+	status = "okay";
+};
+&wdtsafe0 {
+	status = "okay";
+};
+&dma0 {
+	status = "okay";
+	/* Select spi0, spi1, spi2, spi3, uart3, uart4, uart5, uart6 */
+	rzn1_cfg_dmamux = <0x0000ffff>;
+	rzn1_cfg_dmamux_mask = <0x0000ffff>;
+};
+&spi0 {
+	status = "okay";
+	dmas =  <&dma0 8 0 0>,
+		<&dma0 9 0 0>;
+	dma-names = "rx", "tx";
+
+	/* Ext Board: Serial (SPI) F-RAM device (FM25V10-G) */
+	fram: fm25@0 {
+		compatible = "cypress,fm25";
+		reg = <0>;
+		/* Reduced clock rate due to quickswitch */
+		spi-max-frequency = <21000000>;
+	};
+};
+&sdio0 {
+	/* Ext Board */
+	status = "okay";
+};
+&rtc0 {
+	status = "okay";
+};
+&can1 {
+	/* Ext Board */
+	status = "okay";
+};
+&fb0 {
+	status = "okay";
+
+	bits-per-pixel = <32>;
+	bus-width = <24>;
+
+	/* Ext Board: NewHaven 5" LCD module NHD-5.0-800480TF-ATXL#-CTP  */
+	backlight-pwm-clock = <300>;
+	display-timings {
+		native-mode = <&timing0>;
+		timing0: timing0 {
+			clock-frequency = <33400000>;
+			hactive = <800>;
+			vactive = <480>;
+			hback-porch = <88>;
+			hfront-porch = <40>;
+			vback-porch = <32>;
+			vfront-porch = <13>;
+			hsync-len = <1>;
+			vsync-len = <3>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+		};
+	};
+};
diff --git a/arch/arm/dts/rzn1d400_preset_db.dts b/arch/arm/dts/rzn1d400_preset_db.dts
new file mode 100644
index 0000000..d6a7fdf
--- /dev/null
+++ b/arch/arm/dts/rzn1d400_preset_db.dts
@@ -0,0 +1,502 @@
+﻿/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <rzn1.dtsi>
+
+/*
+ * AUTOGENERATED DO NOT EDIT
+ *
+ * Renesas RZ/N1D Demo Board
+ * This file only sets the pin function by default.
+ *
+ * You can override the default mux pullup/down and drive by
+ * defining the following macros in the board file before
+ * including this.
+ */
+
+#ifndef RZN1_MUX_DEFAULT
+#define RZN1_MUX_DEFAULT RZN1_MUX
+#endif
+
+#ifndef RZN1_MUX_CAN0
+#define RZN1_MUX_CAN0 RZN1_MUX_6MA
+#endif
+#ifndef RZN1_MUX_CAN1
+#define RZN1_MUX_CAN1 RZN1_MUX_6MA
+#endif
+#ifndef RZN1_MUX_ETH0
+#define RZN1_MUX_ETH0 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH1
+#define RZN1_MUX_ETH1 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH2
+#define RZN1_MUX_ETH2 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH3
+#define RZN1_MUX_ETH3 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH4
+#define RZN1_MUX_ETH4 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_GPIO
+#define RZN1_MUX_GPIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_GPIO1
+#define RZN1_MUX_GPIO1 RZN1_MUX_GPIO
+#endif
+#ifndef RZN1_MUX_GPIO2
+#define RZN1_MUX_GPIO2 RZN1_MUX_GPIO
+#endif
+#ifndef RZN1_MUX_I2C1
+#define RZN1_MUX_I2C1 RZN1_MUX_12MA
+#endif
+#ifndef RZN1_MUX_LCD
+#define RZN1_MUX_LCD RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_MDIO
+#define RZN1_MUX_MDIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_MDIO0
+#define RZN1_MUX_MDIO0 RZN1_MUX_MDIO
+#endif
+#ifndef RZN1_MUX_MDIO1
+#define RZN1_MUX_MDIO1 RZN1_MUX_MDIO
+#endif
+#ifndef RZN1_MUX_NMI
+#define RZN1_MUX_NMI RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_QSPI0
+#define RZN1_MUX_QSPI0 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_REFCLK
+#define RZN1_MUX_REFCLK RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_SDIO
+#define RZN1_MUX_SDIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_SDIO0
+#define RZN1_MUX_SDIO0 RZN1_MUX_SDIO
+#endif
+#ifndef RZN1_MUX_SPI
+#define RZN1_MUX_SPI RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_SPI0
+#define RZN1_MUX_SPI0 RZN1_MUX_SPI
+#endif
+#ifndef RZN1_MUX_SWITCH
+#define RZN1_MUX_SWITCH RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_UART0
+#define RZN1_MUX_UART0 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_UART2
+#define RZN1_MUX_UART2 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_UART
+#define RZN1_MUX_UART RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_UART3
+#define RZN1_MUX_UART3 RZN1_MUX_UART
+#endif
+#ifndef RZN1_MUX_USB
+#define RZN1_MUX_USB RZN1_MUX_DEFAULT
+#endif
+
+&pinctrl {
+	pins_can0: pins_can0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_CAN0(162, CAN)		/* CAN0_TXD */
+			RZN1_MUX_CAN0(163, CAN)		/* CAN0_RXD */
+		>;
+	};
+	pins_can1: pins_can1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_CAN1(109, CAN)		/* CAN1_TXD */
+			RZN1_MUX_CAN1(110, CAN)		/* CAN1_RXD */
+		>;
+	};
+	pins_eth0: pins_eth0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH0(0, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXCLK */
+			RZN1_MUX_ETH0(1, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXD[0] */
+			RZN1_MUX_ETH0(2, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXD[1] */
+			RZN1_MUX_ETH0(3, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXD[2] */
+			RZN1_MUX_ETH0(4, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXD[3] */
+			RZN1_MUX_ETH0(5, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXEN */
+			RZN1_MUX_ETH0(6, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXCLK */
+			RZN1_MUX_ETH0(7, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXD[0] */
+			RZN1_MUX_ETH0(8, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXD[1] */
+			RZN1_MUX_ETH0(9, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXD[2] */
+			RZN1_MUX_ETH0(10, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXD[3] */
+			RZN1_MUX_ETH0(11, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXDV */
+		>;
+	};
+	pins_eth1: pins_eth1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH1(12, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXCLK */
+			RZN1_MUX_ETH1(13, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXD[0] */
+			RZN1_MUX_ETH1(14, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXD[1] */
+			RZN1_MUX_ETH1(15, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXD[2] */
+			RZN1_MUX_ETH1(16, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXD[3] */
+			RZN1_MUX_ETH1(17, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXEN */
+			RZN1_MUX_ETH1(18, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXCLK */
+			RZN1_MUX_ETH1(19, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXD[0] */
+			RZN1_MUX_ETH1(20, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXD[1] */
+			RZN1_MUX_ETH1(21, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXD[2] */
+			RZN1_MUX_ETH1(22, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXD[3] */
+			RZN1_MUX_ETH1(23, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXDV */
+		>;
+	};
+	pins_eth2: pins_eth2 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH2(24, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXCLK */
+			RZN1_MUX_ETH2(25, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXD[0] */
+			RZN1_MUX_ETH2(26, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXD[1] */
+			RZN1_MUX_ETH2(27, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXD[2] */
+			RZN1_MUX_ETH2(28, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXD[3] */
+			RZN1_MUX_ETH2(29, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXEN */
+			RZN1_MUX_ETH2(30, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXCLK */
+			RZN1_MUX_ETH2(31, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXD[0] */
+			RZN1_MUX_ETH2(32, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXD[1] */
+			RZN1_MUX_ETH2(33, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXD[2] */
+			RZN1_MUX_ETH2(34, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXD[3] */
+			RZN1_MUX_ETH2(35, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXDV */
+		>;
+	};
+	pins_eth3: pins_eth3 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH3(36, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXCLK */
+			RZN1_MUX_ETH3(37, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXD[0] */
+			RZN1_MUX_ETH3(38, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXD[1] */
+			RZN1_MUX_ETH3(39, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXD[2] */
+			RZN1_MUX_ETH3(40, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXD[3] */
+			RZN1_MUX_ETH3(41, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXEN */
+			RZN1_MUX_ETH3(42, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXCLK */
+			RZN1_MUX_ETH3(43, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXD[0] */
+			RZN1_MUX_ETH3(44, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXD[1] */
+			RZN1_MUX_ETH3(45, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXD[2] */
+			RZN1_MUX_ETH3(46, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXD[3] */
+			RZN1_MUX_ETH3(47, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXDV */
+		>;
+	};
+	pins_eth4: pins_eth4 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH4(48, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXCLK */
+			RZN1_MUX_ETH4(49, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXD[0] */
+			RZN1_MUX_ETH4(50, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXD[1] */
+			RZN1_MUX_ETH4(51, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXD[2] */
+			RZN1_MUX_ETH4(52, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXD[3] */
+			RZN1_MUX_ETH4(53, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXEN */
+			RZN1_MUX_ETH4(54, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXCLK */
+			RZN1_MUX_ETH4(55, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXD[0] */
+			RZN1_MUX_ETH4(56, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXD[1] */
+			RZN1_MUX_ETH4(57, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXD[2] */
+			RZN1_MUX_ETH4(58, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXD[3] */
+			RZN1_MUX_ETH4(59, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXDV */
+		>;
+	};
+	pins_gpio1: pins_gpio1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_GPIO1(83, GPIO)	/* PMOD_1 (GPIO1B[14]) */
+			RZN1_MUX_GPIO1(84, GPIO)	/* PMOD_2 (GPIO1B[15]) */
+			RZN1_MUX_GPIO1(85, GPIO)	/* PMOD_2 (GPIO1B[16]) */
+			RZN1_MUX_GPIO1(86, GPIO)	/* PMOD_2 (GPIO1B[17]) */
+			RZN1_MUX_GPIO1(87, GPIO)	/* PMOD_2 (GPIO1B[18]) */
+			RZN1_MUX_GPIO1(88, GPIO)	/* PMOD_3 (GPIO1B[19]) */
+			RZN1_MUX_GPIO1(89, GPIO)	/* PMOD_3 (GPIO1B[20]) */
+			RZN1_MUX_GPIO1(90, GPIO)	/* PMOD_3 (GPIO1B[21]) */
+			RZN1_MUX_GPIO1(91, GPIO)	/* PMOD_3 (GPIO1B[22]) */
+			RZN1_MUX_GPIO1(92, GPIO)	/* LED_2R (GPIO1B[23]) */
+			RZN1_MUX_GPIO1(93, GPIO)	/* LED_2G (GPIO1B[24]) */
+			RZN1_MUX_GPIO1(94, GPIO)	/* ETH_PHY_RESET (GPIO1B[25]) */
+			RZN1_MUX_GPIO1(117, GPIO)	/* GPIO1A[27] */
+			RZN1_MUX_GPIO1(118, GPIO)	/* ETHERNET Port3 IRQ (GPIO1A[28]) */
+			RZN1_MUX_GPIO1(154, GPIO)	/* GPIO2 (GPIO1B[30]) */
+			RZN1_MUX_GPIO1(155, GPIO)	/* GPIO (GPIO1B[31]) */
+		>;
+	};
+	pins_gpio2: pins_gpio2 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_GPIO2(126, GPIO)	/* ETHERNET Port2 IRQ (GPIO2A[4]) */
+			RZN1_MUX_GPIO2(146, GPIO)	/* ETHERNET Port1  IRQ (GPIO2A[24]) */
+			RZN1_MUX_GPIO2(147, GPIO)	/* Eth Port4 IRQ (GPIO2A[25]) */
+			RZN1_MUX_GPIO2(148, GPIO)	/* TouchSCRN_IRQ (GPIO2A[26]) */
+			RZN1_MUX_GPIO2(149, GPIO)	/* Eth Port5 IRQ (GPIO2A[27]) */
+		>;
+	};
+	pins_i2c1: pins_i2c1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_I2C1(115, I2C)		/* I2C1_SCL */
+			RZN1_MUX_I2C1(116, I2C)		/* I2C1_SDA */
+		>;
+	};
+	pins_lcd: pins_lcd {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_LCD(62, LCD)		/* LCD_R[1] */
+			RZN1_MUX_LCD(63, LCD)		/* LCD_G[1] */
+			RZN1_MUX_LCD(64, LCD)		/* LCD_B[1] */
+			RZN1_MUX_LCD(65, LCD)		/* LCD_R[2] */
+			RZN1_MUX_LCD(66, LCD)		/* LCD_G[2] */
+			RZN1_MUX_LCD(67, LCD)		/* LCD_B[2] */
+			RZN1_MUX_LCD(68, LCD)		/* LCD_R[3] */
+			RZN1_MUX_LCD(69, LCD)		/* LCD_G[3] */
+			RZN1_MUX_LCD(70, LCD)		/* LCD_B[3] */
+			RZN1_MUX_LCD(71, LCD)		/* LCD_R[4] */
+			RZN1_MUX_LCD(72, LCD)		/* LCD_G[4] */
+			RZN1_MUX_LCD(73, LCD)		/* LCD_B[4] */
+			RZN1_MUX_LCD(127, LCD)		/* LCD_PWM[0] */
+			RZN1_MUX_LCD(128, LCD)		/* LCD_PCLK */
+			RZN1_MUX_LCD(129, LCD)		/* LCD_HSYNC */
+			RZN1_MUX_LCD(130, LCD)		/* LCD_VSYNC */
+			RZN1_MUX_LCD(131, LCD)		/* LCD_DE */
+			RZN1_MUX_LCD(132, LCD)		/* LCD_PE */
+			RZN1_MUX_LCD(133, LCD)		/* LCD_PWM[1] */
+			RZN1_MUX_LCD(134, LCD)		/* LCD_R[5] */
+			RZN1_MUX_LCD(135, LCD)		/* LCD_R[0] */
+			RZN1_MUX_LCD(136, LCD)		/* LCD_G[0] */
+			RZN1_MUX_LCD(137, LCD)		/* LCD_B[0] */
+			RZN1_MUX_LCD(138, LCD)		/* LCD_R[6] */
+			RZN1_MUX_LCD(139, LCD)		/* LCD_G[6] */
+			RZN1_MUX_LCD(140, LCD)		/* LCD_B[6] */
+			RZN1_MUX_LCD(141, LCD)		/* LCD_R[7] */
+			RZN1_MUX_LCD(142, LCD)		/* LCD_G[7] */
+			RZN1_MUX_LCD(143, LCD)		/* LCD_B[7] */
+			RZN1_MUX_LCD(144, LCD)		/* LCD_G[5] */
+			RZN1_MUX_LCD(145, LCD)		/* LCD_B[5] */
+		>;
+	};
+	pins_mdio0: pins_mdio0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_MDIO0(150, ETH_MDIO)	/* MDIO0_MDC */
+			RZN1_MUX_MDIO0(151, ETH_MDIO)	/* MDIO0_MDIO */
+			RZN1_MUX_MDIO0(170, MDIO_MUX_MAC0)	/* MDIO0_MUX_MAC0 */
+		>;
+	};
+	pins_mdio1: pins_mdio1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_MDIO1(152, ETH_MDIO_E1)	/* MDIO1_MDC */
+			RZN1_MUX_MDIO1(153, ETH_MDIO)	/* MDIO1_MDIO */
+			RZN1_MUX_MDIO1(171, MDIO_MUX_SWITCH)	/* MDIO1_MUX_SWITCH */
+		>;
+	};
+	pins_nmi: pins_nmi {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_NMI(111, ETHERCAT)	/* NMI_CORTEXM[3] */
+		>;
+	};
+	pins_qspi0: pins_qspi0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_QSPI0(74, QSPI)	/* QSPI0_CS_N[0] */
+			RZN1_MUX_QSPI0(75, QSPI)	/* QSPI0_IO[3] */
+			RZN1_MUX_QSPI0(76, QSPI)	/* QSPI0_IO[2] */
+			RZN1_MUX_QSPI0(77, QSPI)	/* QSPI0_IO[1] */
+			RZN1_MUX_QSPI0(78, QSPI)	/* QSPI0_IO[0] */
+			RZN1_MUX_QSPI0(79, QSPI)	/* QSPI0_CLK */
+		>;
+	};
+	pins_refclk: pins_refclk {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_REFCLK(60, CLK_ETH_MII_RGMII_RMII)	/* REFCLK_RGMII */
+			RZN1_MUX_REFCLK(61, CLK_ETH_NAND)	/* REFCLK_MII */
+		>;
+	};
+	pins_sdio0: pins_sdio0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_SDIO0(95, SDIO)	/* SDIO0_CMD */
+			RZN1_MUX_12MA(96, SDIO)		/* SDIO0_CLK */
+			RZN1_MUX_SDIO0(97, SDIO)	/* SDIO0_IO[0] */
+			RZN1_MUX_SDIO0(98, SDIO)	/* SDIO0_IO[1] */
+			RZN1_MUX_SDIO0(99, SDIO)	/* SDIO0_IO[2] */
+			RZN1_MUX_SDIO0(100, SDIO)	/* SDIO0_IO[3] */
+			RZN1_MUX_SDIO0(101, SDIO_E)	/* SDIO0_CD_N */
+			RZN1_MUX_SDIO0(102, SDIO_E)	/* SDIO0_WP */
+		>;
+	};
+	pins_spi0: pins_spi0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_SPI0(156, SPI0_M)	/* SPI0_CLK */
+			RZN1_MUX_SPI0(157, SPI0_M)	/* SPI0_MOSI */
+			RZN1_MUX_SPI0(158, SPI0_M)	/* SPI0_MISO */
+			RZN1_MUX_SPI0(159, SPI0_M)	/* SPI0_SS_N[0] */
+		>;
+	};
+	pins_switch: pins_switch {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_SWITCH(80, MAC_MTIP_SWITCH)	/* SWITCH_MII_LINK[5] */
+			RZN1_MUX_SWITCH(81, MAC_MTIP_SWITCH)	/* SWITCH_MII_LINK[4] */
+			RZN1_MUX_SWITCH(82, MAC_MTIP_SWITCH)	/* SWITCH_MII_LINK[3] */
+			RZN1_MUX_SWITCH(114, MAC_MTIP_SWITCH)	/* SWITCH_MII_LINK[2] */
+		>;
+	};
+	pins_uart0: pins_uart0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_UART0(103, UART0_I)	/* UART0_TXD */
+			RZN1_MUX_UART0(104, UART0_I)	/* UART0_RXD */
+		>;
+	};
+	pins_uart2: pins_uart2 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_UART2(105, UART2)	/* UART2_TXD */
+			RZN1_MUX_UART2(106, UART2)	/* UART2_RXD */
+			RZN1_MUX_UART2(107, UART2)	/* UART2_RTS_N */
+			RZN1_MUX_UART2(108, UART2)	/* UART2_CTS_N */
+		>;
+	};
+	pins_uart3: pins_uart3 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_UART3(123, UART3)	/* UART3_TXD */
+			RZN1_MUX_UART3(124, UART3)	/* UART3_RXD */
+			RZN1_MUX_UART3(125, UART3)	/* UART3_RTS_N */
+		>;
+	};
+	pins_usb: pins_usb {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_USB(119, USB)		/* USB_PPON[1] */
+			RZN1_MUX_USB(120, USB)		/* USB_OC[1] */
+			RZN1_MUX_USB(121, USB)		/* USB_PPON[2] */
+			RZN1_MUX_USB(122, USB)		/* USB_OC[2] */
+		>;
+	};
+};
+
+&can0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_can0>;
+};
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_can1>;
+};
+&eth0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth0>;
+};
+&eth1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth1>;
+};
+&eth2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth2>;
+};
+&eth3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth3>;
+};
+&eth4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth4>;
+};
+&gpio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_gpio1>;
+};
+&gpio2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_gpio2>;
+};
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_i2c1>;
+};
+&lcd {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_lcd>;
+};
+&mdio0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio0>;
+};
+&mdio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio1>;
+};
+&nmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_nmi>;
+};
+&qspi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_qspi0>;
+};
+&refclk {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_refclk>;
+};
+&sdio0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_sdio0>;
+};
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_spi0>;
+};
+&switch {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_switch>;
+};
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_uart0>;
+};
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_uart2>;
+};
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_uart3>;
+};
+&usb {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_usb>;
+};
+
+/* 
+ * this is the compressed Renesas Pinmux Web App data structure; this is
+ * used to allow uploading this file back into the web app, make some
+ * more changes and generate/save the DTS again. It is not used by linux
+ * in any way.
+ */
+#ifdef JSON_PRESET
+N4IgdghgtgpiBcIBKMwwM4XQAiQLQHoA5ARgBFsyYoB7bAIRogCcATEAGhAAcIBjANYQA5nEQwALAAYpnHjGYBLbgAsFEADboEAb
+RABhAIKk5RogCY5AUQAqACRLX7lrrbsBmJ3YleArHIBxAAUASQB5FxBg8M8uEPN9SIAZfTI5AFkycMcuTPDIonSQuQBFAGVQnOQr
+ADF9JIBpOTKssKqKkPaAdRCbfTs5AFVDJBsq4dHYkAmbHy5BsvoQAF0uYW5FGgB9SFhteFAATktENyskIltsIJpmABd3bBCkErkS
+KQB2BBAg9LCyLZVd4ADm+v3+gLeUkOYL+AKB71hEIRjkQ4IBkRIJBOPzhW0xJE8aLxBJ8xIhBP85IBUyxADYkTS3iQvtStrSSKC2
+RyYYgklYMUg3uZZHyBfiAsLUSA3FsgnYAJpbJBWMq2YUMxDRCLC1lRUJhN7uHFnC5XG73cxPF5vXwm+znS42a63O4kbDW15cEi+I
+kyu4qF33CSe21kkA2GgAVz4KjK+guW2eXpAPqp/sDFruvlDAF81hsaPsdB9fBIWXSOKXyx8PlWyyzgfWa4dm5ypG3gSRO+ZO+5Ox
+JO75O5Xq5y62PgU3J62x4cO3Pu3Pe3P+3PB3Ph3PRw3DhPd9Pd7OyyKFyepEvzyvz2vzxvz1vzzuJCL9y+pIf38eX+9m+YsX+2KA
+beP73j+j4/s+/5vv+n7/t+5gin+/7IdeL7mCBiFgYhEGIVB5gweYcHmAh7hni+7iXhRaEYZh7jYe4w6+L4Hx0kRHDMR8U7DvR7h0
+pWvF0nWglNoJra8R8HYSd2Em9hJ/YSYOEk8RI7isRwEl1sxXZlhxvg6Ux+k+pW2k+lpRn6XpOmtr47zmIOtlSOYTF2ZWEisYcrbu
+ZJHbeReHB+b2fn9n5g5+cOflubWnwBdFTZ+V5ta/vRJCqQFxzAocAnlhIKmpdlqXCTlol0iQe4aaVhxNr4bEfIc3Y1QRxwcXSvq+
+i1bUOa1jFMd1NUcPZuWZQNEi5fOGk1YcPGTQJk1ae8lm+FIdKeUxy2eVFHzuCFtb0RVVUKStwJKUdPFHW5PpTQFl0Xb45XeS+Gmj
+ZRT2qXJz0Kc9SnPSpqnZapRWqaJz3iaN0iveWEPvc9EPfaNv0SP97kQ8Do2JaxQW1nSO2sWFWNnUtcmtVIh2sVJxMRbWkmxUlAXl
+lOdOcl55bjaNZXdoNdKPZzaW2WxJl2liyy5kAA==
+#endif
diff --git a/arch/arm/dts/rzn1s.dtsi b/arch/arm/dts/rzn1s.dtsi
new file mode 100644
index 0000000..6e4df6d
--- /dev/null
+++ b/arch/arm/dts/rzn1s.dtsi
@@ -0,0 +1,34 @@
+/*
+ * Device Tree Source for the RZ/N1S devices.
+ *
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include "rzn1.dtsi"
+
+/ {
+	compatible = "renesas,rzn1s";
+
+	aliases {
+		spi1 = &qspi1;
+	};
+
+	bus {
+		qspi1: spi@RZN1_QSPI1_BASE {
+			compatible = "renesas,rzn1-qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <RZN1_QSPI1_BASE RZN1_QSPI_SIZE
+				RZN1_V_QSPI1_BASE RZN1_V_QSPI_SIZE>;
+			reg-names = "qspi", "qspi-mapping";
+			interrupts = <GIC_SPI RZN1_IRQ_QSPI1 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_qspi1>, <&clk_qspi1>;
+			clock-names = "flexway", "pclk";
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/dts/rzn1s324-db.dts b/arch/arm/dts/rzn1s324-db.dts
new file mode 100644
index 0000000..a5875cd
--- /dev/null
+++ b/arch/arm/dts/rzn1s324-db.dts
@@ -0,0 +1,441 @@
+/*
+ * Device Tree Source for the RZN1S-324 Demo Board
+ * This dts is for use when the Cortex M3 controls GMAC1, the 5-Port Switch
+ * and the RGMII/GMII Converters.
+ *
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/dts-v1/;
+
+#include "rzn1s.dtsi"
+#include "rzn1-clocks.dtsi"
+
+/ {
+	model = "RZ/N1S Demo Board";
+	compatible = "renesas,rzn1s-db", "renesas,rzn1";
+
+	chosen {
+		/*
+		 * This is a default command line to help with booting using
+		 * qemu and a ramdisk, it is not meant to stay in the final
+		 * file
+		 g_mass_storage.removable=y g_mass_storage.stall=n
+		 */
+		bootargs = "console=ttyS0,115200";
+		stdout-path = &uart0;
+		linux,stdout-path = &uart0;
+	};
+	hoard: cat: nmi: rmii {
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+	leds {
+		compatible = "gpio-leds";
+
+		led_1 {
+			label = "pl_gpio92";
+			gpios = <&gpio1b 23 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "cpu0";
+		};
+		led_2 {
+			label = "pl_gpio93";
+			gpios = <&gpio1b 24 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "cpu1";
+		};
+		pca0 {
+			label = "pca0";
+			gpios = <&pca9698 0 GPIO_ACTIVE_HIGH>;
+		};
+		pca1 {
+			label = "pca1";
+			gpios = <&pca9698 1 GPIO_ACTIVE_HIGH>;
+		};
+		pca2 {
+			label = "pca2";
+			gpios = <&pca9698 2 GPIO_ACTIVE_HIGH>;
+		};
+		pca3 {
+			label = "pca3";
+			gpios = <&pca9698 3 GPIO_ACTIVE_HIGH>;
+		};
+		pca4 {
+			label = "pca4";
+			gpios = <&pca9698 4 GPIO_ACTIVE_HIGH>;
+		};
+		pca5 {
+			label = "pca5";
+			gpios = <&pca9698 5 GPIO_ACTIVE_HIGH>;
+		};
+		pca6 {
+			label = "pca6";
+			gpios = <&pca9698 6 GPIO_ACTIVE_HIGH>;
+		};
+		pca7 {
+			label = "pca7";
+			gpios = <&pca9698 7 GPIO_ACTIVE_HIGH>;
+		};
+
+		/* These aren't LEDs, they are gpios attached to the pca9698
+		 * port expander. They select the I2C master used to access the
+		 * EEPROM device. The ACTIVE LOW/HIGH settings ensures Linux
+		 * sets the correctly if not done by U-Boot.
+		 */
+		ctrl0 {
+			label = "ctrl0";
+			gpios = <&pca9698 16 GPIO_ACTIVE_LOW>;
+		};
+		ctrl1 {
+			label = "ctrl1";
+			gpios = <&pca9698 17 GPIO_ACTIVE_HIGH>;
+		};
+		ctrl2 {
+			label = "ctrl2";
+			gpios = <&pca9698 18 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+/* Map the USB pinmux to the peripheral port */
+#define usb usbh_pci
+/* ethX refers to the physical pins for each ethernet interface. Here we simply
+ * place them in the hoard node, and the users of the pins will then indicate
+ * are needed by adding a pinctrl-0 entry for them.
+ */
+#define eth0 hoard
+#define eth1 hoard
+#define eth2 hoard
+#define eth3 hoard
+#define eth4 hoard
+#define refclk hoard
+#define mdio0 hoard
+#define mdio1 hoard
+#define lcd fb0
+
+#include "rzn1d400_preset_db.dts"
+
+&gpioirq {
+	status = "okay";
+	gpioirq-0 = <&gpio2a 24 GPIO_ACTIVE_LOW>;	/* 146: ETH Port 1 IRQ */
+	gpioirq-1 = <&gpio2a 4 GPIO_ACTIVE_LOW>;	/* 126: ETH Port 2 IRQ */
+	gpioirq-2 = <&gpio1a 28 GPIO_ACTIVE_LOW>;	/* 118: ETH Port 3 IRQ */
+	gpioirq-3 = <&gpio2a 25 GPIO_ACTIVE_LOW>;	/* 147: ETH Port 4 IRQ */
+	gpioirq-4 = <&gpio2a 27 GPIO_ACTIVE_LOW>;	/* 149: ETH Port 5 IRQ */
+	gpioirq-5 = <&gpio2a 26 GPIO_ACTIVE_LOW>;	/* 148: TouchSCRN_IRQ  */
+};
+
+&uart0 {
+	status = "okay";
+	u-boot,dm-pre-reloc;
+};
+&uart2 {
+	status = "okay";
+};
+&uart3 {
+	status = "okay";
+};
+&i2c1 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pca9698: gpio@20 {
+		compatible = "nxp,pca9698";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		gpio-bank-name="pca";
+	};
+	lm75: lm75@49 {
+		/* Ext Board: Temperature sensor */
+		compatible = "lm75";
+		reg = <0x49>;
+	};
+	at24@50 {
+		compatible = "at24,24c64";
+		pagesize = <32>;
+		reg = <0x50>;
+	};
+	polytouch: edt-ft5x06@38 {
+		/* Ext Board: touch sensor on LCD */
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <5 0>;
+		touchscreen-size-x = <800>;
+		touchscreen-size-y = <480>;
+		// touchscreen-swapped-x-y;
+	};
+};
+&gpio1 {
+	status = "okay";
+};
+&gpio2 {
+	status = "okay";
+};
+
+&gmac0 {
+	/* Only accessible from the Ext Board */
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio0>, <&pins_eth0>;
+
+	phy-handle = <&phy_mii0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy_mii0: ethernet-phy@8 {
+			/* Ext Board: Marvell 88E1512 PHY on J22 */
+			device_type = "ethernet-phy";
+			phy-mode = "rgmii-id";
+			reg = <8>;
+			/* Set LED0 as active low link status, LED2 as interrupt */
+			marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+			interrupt-parent = <&gpioirq>;
+			interrupts = <0>;
+		};
+	};
+};
+&gmac1 {
+	status = "disabled";
+
+	/* Fixed 1Gbps link to the 5-port switch */
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+&ethswitch {
+	status = "disabled";
+	bus_freq = <2500000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio1>,
+		<&pins_eth1>, <&pins_eth2>, <&pins_eth3>, <&pins_eth4>;
+
+	phy-reset-gpios = <&gpio1b 25 GPIO_ACTIVE_HIGH>;
+	phy-reset-duration = <15>;
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	portA: phy_mii4: ethernet-phy@5 {
+		device_type = "ethernet-phy";
+		phy-mode = "mii";
+		reg = <5>;
+		/* Set LED0 as active low link status */
+		micrel,led-mode = <1>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <4>;
+	};
+	portB: phy_mii3: ethernet-phy@4 {
+		device_type = "ethernet-phy";
+		phy-mode = "mii";
+		reg = <4>;
+		/* Set LED0 as active low link status */
+		micrel,led-mode = <1>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <3>;
+	};
+	portC: phy_mii2: ethernet-phy@10 {
+		/* Ext Board: Marvell 88E1512 PHY on J24 */
+		device_type = "ethernet-phy";
+		phy-mode = "rgmii-id";
+		reg = <10>;
+		/* Set LED0 as active low link status, LED2 as interrupt */
+		marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <2>;
+	};
+	portD: phy_mii1: ethernet-phy@1 {
+		/* Ext Board: Marvell 88E1512 PHY on J23 */
+		device_type = "ethernet-phy";
+		phy-mode = "rgmii-id";
+		reg = <1>;
+		/* Set LED0 as active low link status, LED2 as interrupt */
+		marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <1>;
+	};
+};
+&eth_miic {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_refclk>;
+	/* RIN Mode Control - GMAC1 on all Switch ports */
+	mode_control = <0x13>;
+
+	mii0: eth-mii0 {
+		phy-handle = <&phy_mii0>;
+	};
+	mii1: eth-mii1 {
+		phy-handle = <&phy_mii1>;
+	};
+	mii2: eth-mii2 {
+		phy-handle = <&phy_mii2>;
+	};
+	mii3: eth-mii3 {
+		phy-handle = <&phy_mii3>;
+	};
+	mii4: eth-mii4 {
+		phy-handle = <&phy_mii4>;
+	};
+};
+&qspi0 {
+	status = "okay";
+	u-boot,dm-pre-reloc;
+
+	flash: mx25l25635@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "macronix,mx25l25635e", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <62500000>;
+		spi-cpha;
+		spi-cpol;
+		spi-rx-bus-width = <4>;
+		renesas,rzn1-read-cmd = <0x6b 8 0>;
+		renesas,rzn1-readcap-delay = <1>;
+		/* The properties below are used by U-Boot */
+		tshsl-ns = <30>;
+		tsd2d-ns = <3>;
+		tchsh-ns = <3>;
+		tslch-ns = <3>;
+		memory-map = <RZN1_V_QSPI_BASE RZN1_V_QSPI_SIZE>;
+		memory-map-write = <1>;
+		u-boot,dm-pre-reloc;
+
+		partition@0 {
+			/* 64KB */
+			label = "qspi0:spl";
+			reg = <0x0000000 0x00010000>;
+		};
+		partition@1 {
+			/* 64KB */
+			label = "qspi0:pkgt";
+			reg = <0x0010000 0x00010000>;
+		};
+		partition@2 {
+			/* 512KB */
+			label = "qspi0:u-boot";
+			reg = <0x0020000 0x00080000>;
+		};
+		partition@3 {
+			/* 64KB */
+			label = "qspi0:env";
+			reg = <0x00a0000 0x00010000>;
+		};
+		partition@4 {
+			/* 128KB */
+			label = "qspi0:dtb";
+			reg = <0x00b0000 0x00020000>;
+		};
+		partition@5 {
+			/* 1MB */
+			label = "qspi0:cm3";
+			reg = <0x00d0000 0x00100000>;
+		};
+		partition@6 {
+			/* 6MB */
+			label = "qspi0:kernel";
+			reg = <0x01d0000 0x00600000>;
+		};
+		partition@7 {
+			/* Remaining */
+			label = "qspi0:data";
+			reg = <0x07d0000 0>;
+		};
+	};
+};
+&qspi1 {
+	status = "okay";
+
+	flash1: mx25l12805@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "macronix,mx25l25635e", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <62500000>;
+		spi-cpha;
+		spi-cpol;
+		spi-rx-bus-width = <4>;
+		renesas,rzn1-read-cmd = <0x6b 8 0>;
+		renesas,rzn1-readcap-delay = <1>;
+		/* The properties below are used by U-Boot */
+		tshsl-ns = <30>;
+		tsd2d-ns = <3>;
+		tchsh-ns = <3>;
+		tslch-ns = <3>;
+		memory-map = <RZN1_V_QSPI1_BASE RZN1_V_QSPI1_SIZE>;
+		memory-map-write = <1>;
+	};
+};
+&usbf {
+	status = "okay";
+};
+&usbh_pci {
+	/* Ext Board */
+	status = "okay";
+};
+&wdtsafe0 {
+	status = "okay";
+};
+&dma0 {
+	status = "okay";
+	/* Select spi0, spi1, spi2, spi3, uart3, uart4, uart5, uart6 */
+	rzn1_cfg_dmamux = <0x0000ffff>;
+	rzn1_cfg_dmamux_mask = <0x0000ffff>;
+};
+&spi0 {
+	status = "okay";
+	dmas =  <&dma0 8 0 0>,
+		<&dma0 9 0 0>;
+	dma-names = "rx", "tx";
+
+	/* Ext Board: Serial (SPI) F-RAM device (FM25V10-G) */
+	fram: fm25@0 {
+		compatible = "cypress,fm25";
+		reg = <0>;
+		/* Reduced clock rate due to quickswitch */
+		spi-max-frequency = <21000000>;
+	};
+};
+&sdio0 {
+	/* Ext Board */
+	status = "okay";
+};
+&rtc0 {
+	status = "okay";
+};
+&can1 {
+	/* Ext Board */
+	status = "okay";
+};
+&fb0 {
+	status = "okay";
+
+	bits-per-pixel = <32>;
+	bus-width = <24>;
+
+	/* Ext Board: NewHaven 5" LCD module NHD-5.0-800480TF-ATXL#-CTP  */
+	backlight-pwm-clock = <300>;
+	display-timings {
+		native-mode = <&timing0>;
+		timing0: timing0 {
+			clock-frequency = <33400000>;
+			hactive = <800>;
+			vactive = <480>;
+			hback-porch = <88>;
+			hfront-porch = <40>;
+			vback-porch = <32>;
+			vfront-porch = <13>;
+			hsync-len = <1>;
+			vsync-len = <3>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+		};
+	};
+};
diff --git a/arch/arm/include/asm/arch-rzn1/gpio.h b/arch/arm/include/asm/arch-rzn1/gpio.h
new file mode 100644
index 0000000..763babd
--- /dev/null
+++ b/arch/arm/include/asm/arch-rzn1/gpio.h
@@ -0,0 +1,12 @@
+/*
+* Copyright (C) 2016 Renesas Electronics Europe Ltd
+*
+* SPDX-License-Identifier:	GPL-2.0+
+*/
+
+#ifndef _RZN1_GPIO_H_
+#define _RZN1_GPIO_H_
+
+#include <asm-generic/gpio.h>
+
+#endif /* _RZN1_GPIO_H_ */
diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
index 0051f76..ee07b65 100644
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -30,12 +30,12 @@ obj-$(CONFIG_CMD_BOOTI) += bootm.o
 obj-$(CONFIG_CMD_BOOTM) += bootm.o
 obj-$(CONFIG_CMD_BOOTZ) += bootm.o zimage.o
 obj-$(CONFIG_SYS_L2_PL310) += cache-pl310.o
-obj-$(CONFIG_USE_ARCH_MEMSET) += memset.o
-obj-$(CONFIG_USE_ARCH_MEMCPY) += memcpy.o
 else
 obj-$(CONFIG_SPL_FRAMEWORK) += spl.o
 obj-$(CONFIG_SPL_FRAMEWORK) += zimage.o
 endif
+obj-$(CONFIG_$(SPL_)USE_ARCH_MEMSET) += memset.o
+obj-$(CONFIG_$(SPL_)USE_ARCH_MEMCPY) += memcpy.o
 obj-$(CONFIG_SEMIHOSTING) += semihosting.o
 
 obj-y	+= sections.o
diff --git a/arch/arm/lib/bootm-fdt.c b/arch/arm/lib/bootm-fdt.c
index e261d4f..515edf2 100644
--- a/arch/arm/lib/bootm-fdt.c
+++ b/arch/arm/lib/bootm-fdt.c
@@ -27,6 +27,7 @@ DECLARE_GLOBAL_DATA_PTR;
 
 int arch_fixup_fdt(void *blob)
 {
+#ifdef CONFIG_NR_DRAM_BANKS
 	bd_t *bd = gd->bd;
 	int bank, ret;
 	u64 start[CONFIG_NR_DRAM_BANKS];
@@ -58,6 +59,7 @@ int arch_fixup_fdt(void *blob)
 	if (ret)
 		return ret;
 #endif
+#endif
 
 	return 0;
 }
diff --git a/arch/arm/lib/bootm.c b/arch/arm/lib/bootm.c
index 43cc83e..ab8fe8d 100644
--- a/arch/arm/lib/bootm.c
+++ b/arch/arm/lib/bootm.c
@@ -58,10 +58,12 @@ void arch_lmb_reserve(struct lmb *lmb)
 	sp = get_sp();
 	debug("## Current stack ends at 0x%08lx ", sp);
 
+#ifdef CONFIG_NR_DRAM_BANKS
 	/* adjust sp by 4K to be safe */
 	sp -= 4096;
 	lmb_reserve(lmb, sp,
 		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
+#endif
 }
 
 __weak void board_quiesce_devices(void)
@@ -110,6 +112,7 @@ static void setup_start_tag (bd_t *bd)
 
 static void setup_memory_tags(bd_t *bd)
 {
+#ifdef CONFIG_NR_DRAM_BANKS
 	int i;
 
 	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
@@ -121,6 +124,7 @@ static void setup_memory_tags(bd_t *bd)
 
 		params = tag_next (params);
 	}
+#endif
 }
 
 static void setup_commandline_tag(bd_t *bd, char *commandline)
@@ -298,6 +302,10 @@ static void switch_to_el1(void)
 #endif
 #endif
 
+#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
+extern int nonsec_and_hyp;
+#endif
+
 /* Subcommand: GO */
 static void boot_jump_linux(bootm_headers_t *images, int flag)
 {
@@ -368,8 +376,9 @@ static void boot_jump_linux(bootm_headers_t *images, int flag)
 		r2 = gd->bd->bi_boot_params;
 
 	if (!fake) {
-#ifdef CONFIG_ARMV7_NONSEC
+#if defined(CONFIG_ARMV7_NONSEC) && !defined(CONFIG_ARMV7_NONSEC_AT_BOOT)
 		if (armv7_boot_nonsec()) {
+			nonsec_and_hyp = getenv_yesno("boot_hyp");
 			armv7_init_nonsec();
 			secure_ram_addr(_do_nonsec_entry)(kernel_entry,
 							  0, machid, r2);
diff --git a/arch/arm/lib/cache-cp15.c b/arch/arm/lib/cache-cp15.c
index e9bbcf5..5bcee38 100644
--- a/arch/arm/lib/cache-cp15.c
+++ b/arch/arm/lib/cache-cp15.c
@@ -94,6 +94,7 @@ void mmu_set_region_dcache_behaviour(phys_addr_t start, size_t size,
 	mmu_page_table_flush(startpt, stoppt);
 }
 
+#ifdef CONFIG_NR_DRAM_BANKS
 __weak void dram_bank_mmu_setup(int bank)
 {
 	bd_t *bd = gd->bd;
@@ -113,6 +114,11 @@ __weak void dram_bank_mmu_setup(int bank)
 #endif
 	}
 }
+#endif
+
+__weak void post_mmu_setup(void)
+{
+}
 
 /* to activate the MMU we need to set up virtual memory: use 1M areas */
 static inline void mmu_setup(void)
@@ -125,9 +131,12 @@ static inline void mmu_setup(void)
 	for (i = 0; i < ((4096ULL * 1024 * 1024) >> MMU_SECTION_SHIFT); i++)
 		set_section_dcache(i, DCACHE_OFF);
 
+	post_mmu_setup();
+#ifdef CONFIG_NR_DRAM_BANKS
 	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
 		dram_bank_mmu_setup(i);
 	}
+#endif
 
 #ifdef CONFIG_ARMV7_LPAE
 	/* Set up 4 PTE entries pointing to our 4 1GB page tables */
diff --git a/arch/arm/mach-rmobile/include/mach/ehci-rmobile.h b/arch/arm/mach-rmobile/include/mach/ehci-rmobile.h
deleted file mode 100644
index 463654e..0000000
--- a/arch/arm/mach-rmobile/include/mach/ehci-rmobile.h
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- *  Copyright (C) 2013,2014 Renesas Electronics Corporation
- *  Copyright (C) 2014 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
- *
- *  SPDX-License-Identifier:     GPL-2.0
- */
-
-#ifndef __EHCI_RMOBILE_H__
-#define __EHCI_RMOBILE_H__
-
-/* Register offset */
-#define OHCI_OFFSET	0x00
-#define OHCI_SIZE	0x1000
-#define EHCI_OFFSET	0x1000
-#define EHCI_SIZE	0x1000
-
-#define EHCI_USBCMD	(EHCI_OFFSET + 0x0020)
-
-/* USBCTR */
-#define DIRPD		(1 << 8)
-#define PLL_RST		(1 << 2)
-#define PCICLK_MASK	(1 << 1)
-#define USBH_RST	(1 << 0)
-
-/* CMND_STS */
-#define SERREN		(1 << 8)
-#define PERREN		(1 << 6)
-#define MASTEREN	(1 << 2)
-#define MEMEN		(1 << 1)
-
-/* PCIAHB_WIN1_CTR and PCIAHB_WIN2_CTR */
-#define PCIAHB_WIN_PREFETCH	((1 << 1)|(1 << 0))
-
-/* AHBPCI_WIN1_CTR */
-#define PCIWIN1_PCICMD		((1 << 3)|(1 << 1))
-#define AHB_CFG_AHBPCI		0x40000000
-#define AHB_CFG_HOST		0x80000000
-
-/* AHBPCI_WIN2_CTR */
-#define PCIWIN2_PCICMD		((1 << 2)|(1 << 1))
-
-/* PCI_INT_ENABLE */
-#define USBH_PMEEN		(1 << 19)
-#define USBH_INTBEN		(1 << 17)
-#define USBH_INTAEN		(1 << 16)
-
-/* AHB_BUS_CTR */
-#define SMODE_READY_CTR		(1 << 17)
-#define SMODE_READ_BURST	(1 << 16)
-#define MMODE_HBUSREQ		(1 << 7)
-#define MMODE_BOUNDARY		((1 << 6)|(1 << 5))
-#define MMODE_BURST_WIDTH	((1 << 4)|(1 << 3))
-#define MMODE_SINGLE_MODE	((1 << 4)|(1 << 3))
-#define MMODE_WR_INCR		(1 << 2)
-#define MMODE_BYTE_BURST	(1 << 1)
-#define MMODE_HTRANS		(1 << 0)
-
-/* PCI_ARBITER_CTR */
-#define PCIBUS_PARK_TIMER       0x00FF0000
-#define PCIBUS_PARK_TIMER_SET   0x00070000
-#define PCIBP_MODE		(1 << 12)
-#define PCIREQ7                 (1 << 7)
-#define PCIREQ6                 (1 << 6)
-#define PCIREQ5                 (1 << 5)
-#define PCIREQ4                 (1 << 4)
-#define PCIREQ3                 (1 << 3)
-#define PCIREQ2                 (1 << 2)
-#define PCIREQ1                 (1 << 1)
-#define PCIREQ0                 (1 << 0)
-
-#define SMSTPCR7        0xE615014C
-#define SMSTPCR703      (1 << 3)
-
-/* Init AHB master and slave functions of the host logic */
-#define AHB_BUS_CTR_INIT \
-	(SMODE_READY_CTR | MMODE_HBUSREQ | MMODE_WR_INCR | \
-	 MMODE_BYTE_BURST | MMODE_HTRANS)
-
-#define USBCTR_WIN_SIZE_1GB	0x800
-
-/* PCI Configuration Registers */
-#define PCI_CONF_OHCI_OFFSET	0x10000
-#define PCI_CONF_EHCI_OFFSET	0x10100
-struct ahb_pciconf {
-	u32 vid_did;
-	u32 cmnd_sts;
-	u32 rev;
-	u32 cache_line;
-	u32 basead;
-};
-
-/* PCI Configuration Registers for AHB-PCI Bridge Registers */
-#define PCI_CONF_AHBPCI_OFFSET	0x10000
-struct ahbconf_pci_bridge {
-	u32 vid_did;		/* 0x00 */
-	u32 cmnd_sts;
-	u32 revid_cc;
-	u32 cls_lt_ht_bist;
-	u32 basead;		/* 0x10 */
-	u32 win1_basead;
-	u32 win2_basead;
-	u32 dummy0[5];
-	u32 ssvdi_ssid;		/* 0x2C */
-	u32 dummy1[4];
-	u32 intr_line_pin;
-};
-
-/* AHB-PCI Bridge PCI Communication Registers */
-#define AHBPCI_OFFSET	0x10800
-struct ahbcom_pci_bridge {
-	u32 pciahb_win1_ctr;	/* 0x00 */
-	u32 pciahb_win2_ctr;
-	u32 pciahb_dct_ctr;
-	u32 dummy0;
-	u32 ahbpci_win1_ctr;	/* 0x10 */
-	u32 ahbpci_win2_ctr;
-	u32 dummy1;
-	u32 ahbpci_dct_ctr;
-	u32 pci_int_enable;	/* 0x20 */
-	u32 pci_int_status;
-	u32 dummy2[2];
-	u32 ahb_bus_ctr;	/* 0x30 */
-	u32 usbctr;
-	u32 dummy3[2];
-	u32 pci_arbiter_ctr;	/* 0x40 */
-	u32 dummy4;
-	u32 pci_unit_rev;	/* 0x48 */
-};
-
-struct rmobile_ehci_reg {
-	u32 hciversion;		/* hciversion/caplength */
-	u32 hcsparams;		/* hcsparams */
-	u32 hccparams;		/* hccparams */
-	u32 hcsp_portroute;	/* hcsp_portroute */
-	u32 usbcmd;		/* usbcmd */
-	u32 usbsts;		/* usbsts */
-	u32 usbintr;		/* usbintr */
-	u32 frindex;		/* frindex */
-	u32 ctrldssegment;	/* ctrldssegment */
-	u32 periodiclistbase;	/* periodiclistbase */
-	u32 asynclistaddr;	/* asynclistaddr */
-	u32 dummy[9];
-	u32 configflag;		/* configflag */
-	u32 portsc;		/* portsc */
-};
-
-#endif /* __EHCI_RMOBILE_H__ */
diff --git a/board/renesas/rzn1d400-db/Kconfig b/board/renesas/rzn1d400-db/Kconfig
new file mode 100644
index 0000000..530525f
--- /dev/null
+++ b/board/renesas/rzn1d400-db/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_RENESAS_RZN1D400_DB
+
+config SYS_BOARD
+	default "rzn1d400-db"
+
+config SYS_VENDOR
+	default "renesas"
+
+config SYS_SOC
+	default "rzn1"
+
+config SYS_CONFIG_NAME
+	default "rzn1d400-db"
+
+endif
diff --git a/board/renesas/rzn1d400-db/Makefile b/board/renesas/rzn1d400-db/Makefile
new file mode 100644
index 0000000..0b5527b
--- /dev/null
+++ b/board/renesas/rzn1d400-db/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright (C) 2016 Renesas Electronics Europe Ltd
+#
+# SPDX-License-Identifier: GPL-2.0
+#
+
+obj-y	:= rzn1d-db.o
+obj-y	+= ddr-async.o
diff --git a/board/renesas/rzn1d400-db/ddr-async.c b/board/renesas/rzn1d400-db/ddr-async.c
new file mode 100644
index 0000000..75ba417
--- /dev/null
+++ b/board/renesas/rzn1d400-db/ddr-async.c
@@ -0,0 +1,148 @@
+/*
+ * RZ/N1 DDR Controller initialisation
+ *
+ * The DDR Controller register values for a specific DDR device, mode and
+ * frequency are generated using a Cadence tool.
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ */
+#include <common.h>
+#include "renesas/jedec_ddr3_2g_x16_1333h_500_cl8.h"
+
+u32 ddr_00_87_async[] = {
+	DENALI_CTL_00_DATA,
+	DENALI_CTL_01_DATA,
+	DENALI_CTL_02_DATA,
+	DENALI_CTL_03_DATA,
+	DENALI_CTL_04_DATA,
+	DENALI_CTL_05_DATA,
+	DENALI_CTL_06_DATA,
+	DENALI_CTL_07_DATA,
+	DENALI_CTL_08_DATA,
+	DENALI_CTL_09_DATA,
+
+	DENALI_CTL_10_DATA,
+	DENALI_CTL_11_DATA,
+	DENALI_CTL_12_DATA,
+	DENALI_CTL_13_DATA,
+	DENALI_CTL_14_DATA,
+	DENALI_CTL_15_DATA,
+	DENALI_CTL_16_DATA,
+	DENALI_CTL_17_DATA,
+	DENALI_CTL_18_DATA,
+	DENALI_CTL_19_DATA,
+
+	DENALI_CTL_20_DATA,
+	DENALI_CTL_21_DATA,
+	DENALI_CTL_22_DATA,
+	DENALI_CTL_23_DATA,
+	DENALI_CTL_24_DATA,
+	DENALI_CTL_25_DATA,
+	DENALI_CTL_26_DATA,
+	DENALI_CTL_27_DATA,
+	DENALI_CTL_28_DATA,
+	DENALI_CTL_29_DATA,
+
+	DENALI_CTL_30_DATA,
+	DENALI_CTL_31_DATA,
+	DENALI_CTL_32_DATA,
+	DENALI_CTL_33_DATA,
+	DENALI_CTL_34_DATA,
+	DENALI_CTL_35_DATA,
+	DENALI_CTL_36_DATA,
+	DENALI_CTL_37_DATA,
+	DENALI_CTL_38_DATA,
+	DENALI_CTL_39_DATA,
+
+	DENALI_CTL_40_DATA,
+	DENALI_CTL_41_DATA,
+	DENALI_CTL_42_DATA,
+	DENALI_CTL_43_DATA,
+	DENALI_CTL_44_DATA,
+	DENALI_CTL_45_DATA,
+	DENALI_CTL_46_DATA,
+	DENALI_CTL_47_DATA,
+	DENALI_CTL_48_DATA,
+	DENALI_CTL_49_DATA,
+
+	DENALI_CTL_50_DATA,
+	DENALI_CTL_51_DATA,
+	DENALI_CTL_52_DATA,
+	DENALI_CTL_53_DATA,
+	DENALI_CTL_54_DATA,
+	DENALI_CTL_55_DATA,
+	DENALI_CTL_56_DATA,
+	DENALI_CTL_57_DATA,
+	DENALI_CTL_58_DATA,
+	DENALI_CTL_59_DATA,
+
+	DENALI_CTL_60_DATA,
+	DENALI_CTL_61_DATA,
+	DENALI_CTL_62_DATA,
+	DENALI_CTL_63_DATA,
+	DENALI_CTL_64_DATA,
+	DENALI_CTL_65_DATA,
+	DENALI_CTL_66_DATA,
+	DENALI_CTL_67_DATA,
+	DENALI_CTL_68_DATA,
+	DENALI_CTL_69_DATA,
+
+	DENALI_CTL_70_DATA,
+	DENALI_CTL_71_DATA,
+	DENALI_CTL_72_DATA,
+	DENALI_CTL_73_DATA,
+	DENALI_CTL_74_DATA,
+	DENALI_CTL_75_DATA,
+	DENALI_CTL_76_DATA,
+	DENALI_CTL_77_DATA,
+	DENALI_CTL_78_DATA,
+	DENALI_CTL_79_DATA,
+
+	DENALI_CTL_80_DATA,
+	DENALI_CTL_81_DATA,
+	DENALI_CTL_82_DATA,
+	DENALI_CTL_83_DATA,
+	DENALI_CTL_84_DATA,
+	DENALI_CTL_85_DATA,
+	DENALI_CTL_86_DATA,
+	DENALI_CTL_87_DATA,
+	DENALI_CTL_88_DATA,
+	DENALI_CTL_89_DATA,
+
+	DENALI_CTL_90_DATA,
+	DENALI_CTL_91_DATA,
+	DENALI_CTL_92_DATA,
+};
+
+u32 ddr_350_374_async[] = {
+	DENALI_CTL_350_DATA,
+	DENALI_CTL_351_DATA,
+	DENALI_CTL_352_DATA,
+	DENALI_CTL_353_DATA,
+	DENALI_CTL_354_DATA,
+	DENALI_CTL_355_DATA,
+	DENALI_CTL_356_DATA,
+	DENALI_CTL_357_DATA,
+	DENALI_CTL_358_DATA,
+	DENALI_CTL_359_DATA,
+
+	DENALI_CTL_360_DATA,
+	DENALI_CTL_361_DATA,
+	DENALI_CTL_362_DATA,
+	DENALI_CTL_363_DATA,
+	DENALI_CTL_364_DATA,
+	DENALI_CTL_365_DATA,
+	DENALI_CTL_366_DATA,
+	DENALI_CTL_367_DATA,
+	DENALI_CTL_368_DATA,
+	DENALI_CTL_369_DATA,
+
+	DENALI_CTL_370_DATA,
+	DENALI_CTL_371_DATA,
+	DENALI_CTL_372_DATA,
+	DENALI_CTL_373_DATA,
+	DENALI_CTL_374_DATA,
+};
diff --git a/board/renesas/rzn1d400-db/rzn1-board-pinmux.h b/board/renesas/rzn1d400-db/rzn1-board-pinmux.h
new file mode 100755
index 0000000..c9e95b4
--- /dev/null
+++ b/board/renesas/rzn1d400-db/rzn1-board-pinmux.h
@@ -0,0 +1,378 @@
+﻿/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_BOARD_PINMUX_H__
+#define __RZN1_BOARD_PINMUX_H__
+/*
+ * AUTOGENERATED DO NOT EDIT
+ *
+ * Renesas RZ/N1D Demo Board
+ * This file only sets the pin function by default.
+ *
+ * You can override the default mux pullup/down and drive by
+ * defining the following macros in the board file before
+ * including this.
+ */
+
+#ifndef RZN1_MUX_DEFAULT
+#define RZN1_MUX_DEFAULT RZN1_MUX
+#endif
+
+#include "renesas/pinctrl-rzn1.h"
+
+#ifndef RZN1_MUX_CAN0
+#define RZN1_MUX_CAN0 RZN1_MUX_6MA
+#endif
+#ifndef RZN1_MUX_CAN1
+#define RZN1_MUX_CAN1 RZN1_MUX_6MA
+#endif
+#ifndef RZN1_MUX_ETH0
+#define RZN1_MUX_ETH0 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH1
+#define RZN1_MUX_ETH1 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH2
+#define RZN1_MUX_ETH2 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH3
+#define RZN1_MUX_ETH3 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH4
+#define RZN1_MUX_ETH4 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_GPIO
+#define RZN1_MUX_GPIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_GPIO1
+#define RZN1_MUX_GPIO1 RZN1_MUX_GPIO
+#endif
+#ifndef RZN1_MUX_GPIO2
+#define RZN1_MUX_GPIO2 RZN1_MUX_GPIO
+#endif
+#ifndef RZN1_MUX_I2C1
+#define RZN1_MUX_I2C1 RZN1_MUX_12MA
+#endif
+#ifndef RZN1_MUX_LCD
+#define RZN1_MUX_LCD RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_MDIO
+#define RZN1_MUX_MDIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_MDIO0
+#define RZN1_MUX_MDIO0 RZN1_MUX_MDIO
+#endif
+#ifndef RZN1_MUX_MDIO1
+#define RZN1_MUX_MDIO1 RZN1_MUX_MDIO
+#endif
+#ifndef RZN1_MUX_NMI
+#define RZN1_MUX_NMI RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_QSPI0
+#define RZN1_MUX_QSPI0 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_REFCLK
+#define RZN1_MUX_REFCLK RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_SDIO
+#define RZN1_MUX_SDIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_SDIO0
+#define RZN1_MUX_SDIO0 RZN1_MUX_SDIO
+#endif
+#ifndef RZN1_MUX_SPI
+#define RZN1_MUX_SPI RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_SPI0
+#define RZN1_MUX_SPI0 RZN1_MUX_SPI
+#endif
+#ifndef RZN1_MUX_SWITCH
+#define RZN1_MUX_SWITCH RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_UART0
+#define RZN1_MUX_UART0 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_UART2
+#define RZN1_MUX_UART2 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_UART
+#define RZN1_MUX_UART RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_UART3
+#define RZN1_MUX_UART3 RZN1_MUX_UART
+#endif
+#ifndef RZN1_MUX_USB
+#define RZN1_MUX_USB RZN1_MUX_DEFAULT
+#endif
+
+#define RZN1_MUX_PERIPH_BIT	24
+
+/*
+ * These numbers are arbitrary and do not correspond to anything
+ * on the hardware, they are for the application convenience only
+ * and *will* change if the pinmux is regenerated by the Webapp.
+ */
+enum {
+	RZN1_P_CAN0 = 0, RZN1_P_CAN1, RZN1_P_ETH0, RZN1_P_ETH1, RZN1_P_ETH2, RZN1_P_ETH3,
+	RZN1_P_ETH4, RZN1_P_GPIO1, RZN1_P_GPIO2, RZN1_P_I2C1, RZN1_P_LCD, RZN1_P_MDIO0,
+	RZN1_P_MDIO1, RZN1_P_NMI, RZN1_P_QSPI0, RZN1_P_REFCLK, RZN1_P_SDIO0, RZN1_P_SPI0,
+	RZN1_P_SWITCH, RZN1_P_UART0, RZN1_P_UART2, RZN1_P_UART3, RZN1_P_USB, 
+};
+
+/*
+ * A peripheral number is also encoded in these constants to
+ * help parsing in case your code wishes to do pinmux selectively
+ */
+#define _RZP(_P, _M) ((_M) | (RZN1_##_P << RZN1_MUX_PERIPH_BIT))
+
+static const uint32_t rzn1_pinmux_map[] = {
+	_RZP(P_CAN0, RZN1_MUX_CAN0(162, CAN)),			/* CAN0_TXD */
+	_RZP(P_CAN0, RZN1_MUX_CAN0(163, CAN)),			/* CAN0_RXD */
+	_RZP(P_CAN1, RZN1_MUX_CAN1(109, CAN)),			/* CAN1_TXD */
+	_RZP(P_CAN1, RZN1_MUX_CAN1(110, CAN)),			/* CAN1_RXD */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(0, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXCLK */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(1, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[0] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(2, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[1] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(3, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[2] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(4, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[3] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(5, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXEN */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(6, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXCLK */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(7, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[0] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(8, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[1] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(9, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[2] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(10, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[3] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(11, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXDV */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(12, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXCLK */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(13, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[0] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(14, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[1] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(15, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[2] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(16, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[3] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(17, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXEN */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(18, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXCLK */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(19, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[0] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(20, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[1] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(21, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[2] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(22, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[3] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(23, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXDV */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(24, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXCLK */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(25, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[0] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(26, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[1] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(27, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[2] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(28, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[3] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(29, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXEN */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(30, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXCLK */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(31, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[0] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(32, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[1] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(33, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[2] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(34, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[3] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(35, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXDV */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(36, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXCLK */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(37, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[0] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(38, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[1] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(39, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[2] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(40, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[3] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(41, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXEN */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(42, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXCLK */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(43, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[0] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(44, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[1] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(45, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[2] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(46, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[3] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(47, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXDV */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(48, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXCLK */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(49, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[0] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(50, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[1] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(51, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[2] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(52, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[3] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(53, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXEN */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(54, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXCLK */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(55, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[0] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(56, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[1] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(57, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[2] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(58, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[3] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(59, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXDV */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(83, GPIO)),		/* PMOD_1 (GPIO1B[14]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(84, GPIO)),		/* PMOD_2 (GPIO1B[15]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(85, GPIO)),		/* PMOD_2 (GPIO1B[16]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(86, GPIO)),		/* PMOD_2 (GPIO1B[17]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(87, GPIO)),		/* PMOD_2 (GPIO1B[18]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(88, GPIO)),		/* PMOD_3 (GPIO1B[19]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(89, GPIO)),		/* PMOD_3 (GPIO1B[20]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(90, GPIO)),		/* PMOD_3 (GPIO1B[21]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(91, GPIO)),		/* PMOD_3 (GPIO1B[22]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(92, GPIO)),		/* LED_2R (GPIO1B[23]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(93, GPIO)),		/* LED_2G (GPIO1B[24]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(94, GPIO)),		/* ETH_PHY_RESET (GPIO1B[25]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(117, GPIO)),		/* GPIO1A[27] */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(118, GPIO)),		/* ETHERNET Port3 IRQ (GPIO1A[28]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(154, GPIO)),		/* GPIO2 (GPIO1B[30]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(155, GPIO)),		/* GPIO (GPIO1B[31]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(126, GPIO)),		/* ETHERNET Port2 IRQ (GPIO2A[4]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(146, GPIO)),		/* ETHERNET Port1  IRQ (GPIO2A[24]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(147, GPIO)),		/* Eth Port4 IRQ (GPIO2A[25]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(148, GPIO)),		/* TouchSCRN_IRQ (GPIO2A[26]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(149, GPIO)),		/* Eth Port5 IRQ (GPIO2A[27]) */
+	_RZP(P_I2C1, RZN1_MUX_I2C1(115, I2C)),			/* I2C1_SCL */
+	_RZP(P_I2C1, RZN1_MUX_I2C1(116, I2C)),			/* I2C1_SDA */
+	_RZP(P_LCD, RZN1_MUX_LCD(62, LCD)),			/* LCD_R[1] */
+	_RZP(P_LCD, RZN1_MUX_LCD(63, LCD)),			/* LCD_G[1] */
+	_RZP(P_LCD, RZN1_MUX_LCD(64, LCD)),			/* LCD_B[1] */
+	_RZP(P_LCD, RZN1_MUX_LCD(65, LCD)),			/* LCD_R[2] */
+	_RZP(P_LCD, RZN1_MUX_LCD(66, LCD)),			/* LCD_G[2] */
+	_RZP(P_LCD, RZN1_MUX_LCD(67, LCD)),			/* LCD_B[2] */
+	_RZP(P_LCD, RZN1_MUX_LCD(68, LCD)),			/* LCD_R[3] */
+	_RZP(P_LCD, RZN1_MUX_LCD(69, LCD)),			/* LCD_G[3] */
+	_RZP(P_LCD, RZN1_MUX_LCD(70, LCD)),			/* LCD_B[3] */
+	_RZP(P_LCD, RZN1_MUX_LCD(71, LCD)),			/* LCD_R[4] */
+	_RZP(P_LCD, RZN1_MUX_LCD(72, LCD)),			/* LCD_G[4] */
+	_RZP(P_LCD, RZN1_MUX_LCD(73, LCD)),			/* LCD_B[4] */
+	_RZP(P_LCD, RZN1_MUX_LCD(127, LCD)),			/* LCD_PWM[0] */
+	_RZP(P_LCD, RZN1_MUX_LCD(128, LCD)),			/* LCD_PCLK */
+	_RZP(P_LCD, RZN1_MUX_LCD(129, LCD)),			/* LCD_HSYNC */
+	_RZP(P_LCD, RZN1_MUX_LCD(130, LCD)),			/* LCD_VSYNC */
+	_RZP(P_LCD, RZN1_MUX_LCD(131, LCD)),			/* LCD_DE */
+	_RZP(P_LCD, RZN1_MUX_LCD(132, LCD)),			/* LCD_PE */
+	_RZP(P_LCD, RZN1_MUX_LCD(133, LCD)),			/* LCD_PWM[1] */
+	_RZP(P_LCD, RZN1_MUX_LCD(134, LCD)),			/* LCD_R[5] */
+	_RZP(P_LCD, RZN1_MUX_LCD(135, LCD)),			/* LCD_R[0] */
+	_RZP(P_LCD, RZN1_MUX_LCD(136, LCD)),			/* LCD_G[0] */
+	_RZP(P_LCD, RZN1_MUX_LCD(137, LCD)),			/* LCD_B[0] */
+	_RZP(P_LCD, RZN1_MUX_LCD(138, LCD)),			/* LCD_R[6] */
+	_RZP(P_LCD, RZN1_MUX_LCD(139, LCD)),			/* LCD_G[6] */
+	_RZP(P_LCD, RZN1_MUX_LCD(140, LCD)),			/* LCD_B[6] */
+	_RZP(P_LCD, RZN1_MUX_LCD(141, LCD)),			/* LCD_R[7] */
+	_RZP(P_LCD, RZN1_MUX_LCD(142, LCD)),			/* LCD_G[7] */
+	_RZP(P_LCD, RZN1_MUX_LCD(143, LCD)),			/* LCD_B[7] */
+	_RZP(P_LCD, RZN1_MUX_LCD(144, LCD)),			/* LCD_G[5] */
+	_RZP(P_LCD, RZN1_MUX_LCD(145, LCD)),			/* LCD_B[5] */
+	_RZP(P_MDIO0, RZN1_MUX_MDIO0(150, ETH_MDIO)),		/* MDIO0_MDC */
+	_RZP(P_MDIO0, RZN1_MUX_MDIO0(151, ETH_MDIO)),		/* MDIO0_MDIO */
+	_RZP(P_MDIO0, RZN1_MUX_MDIO0(170, MDIO_MUX_MAC0)),	/* MDIO0_MUX_MAC0 */
+	_RZP(P_MDIO1, RZN1_MUX_MDIO1(152, ETH_MDIO_E1)),	/* MDIO1_MDC */
+	_RZP(P_MDIO1, RZN1_MUX_MDIO1(153, ETH_MDIO)),		/* MDIO1_MDIO */
+	_RZP(P_MDIO1, RZN1_MUX_MDIO1(171, MDIO_MUX_SWITCH)),	/* MDIO1_MUX_SWITCH */
+	_RZP(P_NMI, RZN1_MUX_NMI(111, ETHERCAT)),		/* NMI_CORTEXM[3] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(74, QSPI)),		/* QSPI0_CS_N[0] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(75, QSPI)),		/* QSPI0_IO[3] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(76, QSPI)),		/* QSPI0_IO[2] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(77, QSPI)),		/* QSPI0_IO[1] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(78, QSPI)),		/* QSPI0_IO[0] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(79, QSPI)),		/* QSPI0_CLK */
+	_RZP(P_REFCLK, RZN1_MUX_REFCLK(60, CLK_ETH_MII_RGMII_RMII)),	/* REFCLK_RGMII */
+	_RZP(P_REFCLK, RZN1_MUX_REFCLK(61, CLK_ETH_NAND)),	/* REFCLK_MII */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(95, SDIO)),		/* SDIO0_CMD */
+	_RZP(P_SDIO0, RZN1_MUX_12MA(96, SDIO)),			/* SDIO0_CLK */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(97, SDIO)),		/* SDIO0_IO[0] */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(98, SDIO)),		/* SDIO0_IO[1] */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(99, SDIO)),		/* SDIO0_IO[2] */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(100, SDIO)),		/* SDIO0_IO[3] */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(101, SDIO_E)),		/* SDIO0_CD_N */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(102, SDIO_E)),		/* SDIO0_WP */
+	_RZP(P_SPI0, RZN1_MUX_SPI0(156, SPI0_M)),		/* SPI0_CLK */
+	_RZP(P_SPI0, RZN1_MUX_SPI0(157, SPI0_M)),		/* SPI0_MOSI */
+	_RZP(P_SPI0, RZN1_MUX_SPI0(158, SPI0_M)),		/* SPI0_MISO */
+	_RZP(P_SPI0, RZN1_MUX_SPI0(159, SPI0_M)),		/* SPI0_SS_N[0] */
+	_RZP(P_SWITCH, RZN1_MUX_SWITCH(80, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[5] */
+	_RZP(P_SWITCH, RZN1_MUX_SWITCH(81, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[4] */
+	_RZP(P_SWITCH, RZN1_MUX_SWITCH(82, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[3] */
+	_RZP(P_SWITCH, RZN1_MUX_SWITCH(114, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[2] */
+	_RZP(P_UART0, RZN1_MUX_UART0(103, UART0_I)),		/* UART0_TXD */
+	_RZP(P_UART0, RZN1_MUX_UART0(104, UART0_I)),		/* UART0_RXD */
+	_RZP(P_UART2, RZN1_MUX_UART2(105, UART2)),		/* UART2_TXD */
+	_RZP(P_UART2, RZN1_MUX_UART2(106, UART2)),		/* UART2_RXD */
+	_RZP(P_UART2, RZN1_MUX_UART2(107, UART2)),		/* UART2_RTS_N */
+	_RZP(P_UART2, RZN1_MUX_UART2(108, UART2)),		/* UART2_CTS_N */
+	_RZP(P_UART3, RZN1_MUX_UART3(123, UART3)),		/* UART3_TXD */
+	_RZP(P_UART3, RZN1_MUX_UART3(124, UART3)),		/* UART3_RXD */
+	_RZP(P_UART3, RZN1_MUX_UART3(125, UART3)),		/* UART3_RTS_N */
+	_RZP(P_USB, RZN1_MUX_USB(119, USB)),			/* USB_PPON[1] */
+	_RZP(P_USB, RZN1_MUX_USB(120, USB)),			/* USB_OC[1] */
+	_RZP(P_USB, RZN1_MUX_USB(121, USB)),			/* USB_PPON[2] */
+	_RZP(P_USB, RZN1_MUX_USB(122, USB)),			/* USB_OC[2] */
+	0L, /* terminator */
+};
+/*
+ * Sample function for setting the pinmux. Pass -1 for setting /all/
+ * the pins, pass any of the RZN1_P_xxx for setting just that one set
+ * returns the number of pins that have been set.
+ * There is also a variant where you can pass multiple peripherals as
+ * a bitmask.
+ */
+#ifdef USE_DEFAULT_PINMUX
+/* Functions are marked 'unused' to prevent warnings on modern GCC */
+#if defined(__GNUC__)
+#define __unused __attribute__((unused))
+#elif !defined(__unused)
+#define __unused
+#endif
+static int rzn1_board_pinmux(int periph /* = -1 */) __unused;
+static int rzn1_board_pinmux(int periph /* = -1 */) {
+ int i, cnt = 0;
+ for (i = 0; rzn1_pinmux_map[i]; i++)
+  if (periph == -1 ||
+      (rzn1_pinmux_map[i] >> RZN1_MUX_PERIPH_BIT) == (uint32_t)periph) {
+       rzn1_pinmux_set(rzn1_pinmux_map[i]);
+       cnt++;
+ }
+ return cnt;
+}
+static int rzn1_board_pinmux_mask(uint32_t periph_mask /* = -1 */) __unused;
+static int rzn1_board_pinmux_mask(uint32_t periph_mask /* = -1 */) {
+ int i, cnt = 0;
+ for (i = 0; rzn1_pinmux_map[i]; i++)
+  if (periph_mask & (1 << (rzn1_pinmux_map[i] >> RZN1_MUX_PERIPH_BIT))) {
+   rzn1_pinmux_set(rzn1_pinmux_map[i]);
+   cnt++;
+  }
+ return cnt;
+}
+#endif
+
+/* 
+ * this is the compressed Renesas Pinmux Web App data structure; this is
+ * used to allow uploading this file back into the web app, make some
+ * more changes and generate/save the DTS again. It is not used by linux
+ * in any way.
+ */
+#ifdef JSON_PRESET
+N4IgdghgtgpiBcIBKMwwM4XQAiQLQHoA5ARgBFsyYoB7bAIRogCcATEAGhAAcIBjANYQA5nEQwALAAYpnHjGYBLbgAsFEADboEAb
+RABhAIKk5RogCY5AUQAqACRLX7lrrbsBmJ3YleArHIBxAAUASQB5FxBg8M8uEPN9SIAZfTI5AFkycMcuTPDIonSQuQBFAGVQnOQr
+ADF9JIBpOTKssKqKkPaAdRCbfTs5AFVDJBsq4dHYkAmbHy5BsvoQAF0uYW5FGgB9SFhteFAATktENyskIltsIJpmABd3bBCkErkS
+KQB2BBAg9LCyLZVd4ADm+v3+gLeUkOYL+AKB71hEIRjkQ4IBkRIJBOPzhW0xJE8aLxBJ8xIhBP85IBUyxADYkTS3iQvtStrSSKC2
+RyYYgklYMUg3uZZHyBfiAsLUSA3FsgnYAJpbJBWMq2YUMxDRCLC1lRUJhN7uHFnC5XG73cxPF5vXwm+znS42a63O4kbDW15cEi+I
+kyu4qF33CSe21kkA2GgAVz4KjK+guW2eXpAPqp/sDFruvlDAF81hsaPsdB9fBIWXSOKXyx8PlWyyzgfWa4dm5ypG3gSRO+ZO+5Ox
+JO75O5Xq5y62PgU3J62x4cO3Pu3Pe3P+3PB3Ph3PRw3DhPd9Pd7OyyKFyepEvzyvz2vzxvz1vzzuJCL9y+pIf38eX+9m+YsX+2KA
+beP73j+j4/s+/5vv+n7/t+5gin+/7IdeL7mCBiFgYhEGIVB5gweYcHmAh7hni+7iXhRaEYZh7jYe4w6+L4Hx0kRHDMR8U7DvR7h0
+pWvF0nWglNoJra8R8HYSd2Em9hJ/YSYOEk8RI7isRwEl1sxXZlhxvg6Ux+k+pW2k+lpRn6XpOmtr47zmIOtlSOYTF2ZWEisYcrbu
+ZJHbeReHB+b2fn9n5g5+cOflubWnwBdFTZ+V5ta/vRJCqQFxzAocAnlhIKmpdlqXCTlol0iQe4aaVhxNr4bEfIc3Y1QRxwcXSvq+
+i1bUOa1jFMd1NUcPZuWZQNEi5fOGk1YcPGTQJk1ae8lm+FIdKeUxy2eVFHzuCFtb0RVVUKStwJKUdPFHW5PpTQFl0Xb45XeS+Gmj
+ZRT2qXJz0Kc9SnPSpqnZapRWqaJz3iaN0iveWEPvc9EPfaNv0SP97kQ8Do2JaxQW1nSO2sWFWNnUtcmtVIh2sVJxMRbWkmxUlAXl
+lOdOcl55bjaNZXdoNdKPZzaW2WxJl2liyy5kAA==
+#endif
+
+#endif /* __RZN1_BOARD_PINMUX_H__ */
diff --git a/board/renesas/rzn1d400-db/rzn1d-db.c b/board/renesas/rzn1d400-db/rzn1d-db.c
new file mode 100644
index 0000000..1b59de3
--- /dev/null
+++ b/board/renesas/rzn1d400-db/rzn1d-db.c
@@ -0,0 +1,391 @@
+/*
+ * Renesas RZ/N1D-400 Demo Board, can be used with RZ/N1 Extension Board
+ *
+ * (C) Copyright 2016 Renesas Electronics Europe Limited
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ */
+/*
+ * WARNING! All hardware information (device and board) indexes start at 1,
+ * whereas all software indexes start at 0. Everything in this file refers
+ * to the software indexes.
+ */
+
+#include <common.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <dm.h>
+#include <led.h>
+#include <linux/sizes.h>
+#include <malloc.h>
+#include <sdhci.h>
+#include <spl.h>
+#include <usb.h>
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-sysctrl.h"
+#include "renesas/rzn1-utils.h"
+#include "renesas/rzn1-clocks.h"
+#include "renesas/pinctrl-rzn1.h"
+#define USE_DEFAULT_PINMUX
+#include "rzn1-board-pinmux.h"
+#include "cadence_ddr_ctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+/* Called early during device initialisation */
+void rzn1_setup_pinmux(void)
+{
+	/* Set all pin mux and drive stength to defaults for this board */
+	rzn1_board_pinmux(-1);
+
+	/*
+	 * This is special 'virtual' pins for the MDIO multiplexing.
+	 * The default sets MDIO1 control to the 5-port Switch, but U-Boot
+	 * doesn't have a driver for this, hence MDIO1 is controlled by GMAC1
+	 */
+	rzn1_pinmux_set(RZN1_MUX_MDIO(RZN1_MDIO_BUS1, MDIO_MUX_MAC1));
+}
+
+#if defined(RZN1_ENABLE_USBF) && !defined(CONFIG_SPL_BUILD)
+/* Configure board specific clocks for the USB blocks */
+int board_usb_init(int index, enum usb_init_type init)
+{
+	/* Configure device clocks, etc */
+	return rzn1_usb_init(index, init);
+}
+#endif
+
+static int set_led(const char *name, int val)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = led_get_by_label(name, &dev);
+	if (ret)
+		return ret;
+
+	return led_set_on(dev, val);
+}
+
+int rzn1_ctrl(void)
+{
+#if defined(RZN1_ENABLE_I2C)
+	/*
+	 * Switch I2C master for the EEPROM from the FTDI device to the RZ/N1.
+	 * The order is important as we want to avoid two masters connected at
+	 * the same time.
+	 * NOTE: ctrl0 is marked as ACTIVE_LOW in the dts
+	 */
+	/* Pretend the ctrl pins are leds. It works... */
+	set_led("ctrl1", 0);
+	set_led("ctrl2", 0);
+	set_led("ctrl0", 0);
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+#if defined(RZN1_ENABLE_QSPI)
+	/* Enable QSPI */
+	rzn1_clk_set_gate(RZN1_CLK_QSPI0_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_QSPI0_ID, 1);
+#endif
+
+#if defined(RZN1_ENABLE_I2C) && !defined(CONFIG_SPL_BUILD)
+	rzn1_clk_set_gate(RZN1_HCLK_I2C1_ID, 1);
+	rzn1_ctrl();
+#endif
+
+#if defined(RZN1_ENABLE_SDHC) && !defined(CONFIG_SPL_BUILD)
+	/* Enable SDHC0 */
+	rzn1_clk_set_gate(RZN1_CLK_SDIO0_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_SDIO0_ID, 1);
+	rzn1_clk_reset(RZN1_HCLK_SDIO0_ID);
+#endif
+
+#if defined(RZN1_ENABLE_GPIO)
+	/* Enable GPIO clock */
+	rzn1_clk_set_gate(RZN1_HCLK_GPIO0_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_GPIO1_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_GPIO2_ID, 1);
+#endif
+
+#if defined(RZN1_ENABLE_USBF) && !defined(CONFIG_SPL_BUILD)
+	board_usb_init(0, USB_INIT_DEVICE);
+#endif
+
+#if defined(CONFIG_ARMV7_NONSEC) && defined(CONFIG_ARMV7_NONSEC_AT_BOOT)
+	/* Change to non-secure mode now */
+	armv7_init_nonsec();
+#endif
+
+	return 0;
+}
+
+extern u32 ddr_00_87_async[];
+extern u32 ddr_350_374_async[];
+
+void rzn1_ddr3_single_bank(void *ddr_ctrl_base)
+{
+	/* CS0 */
+	cdns_ddr_set_mr1(ddr_ctrl_base, 0,
+		MR1_ODT_IMPEDANCE_60_OHMS,
+		MR1_DRIVE_STRENGTH_40_OHMS);
+	cdns_ddr_set_mr2(ddr_ctrl_base, 0,
+		MR2_DYNAMIC_ODT_OFF,
+		MR2_SELF_REFRESH_TEMP_EXT);
+
+	/* ODT_WR_MAP_CS0 = 1, ODT_RD_MAP_CS0 = 0 */
+	cdns_ddr_set_odt_map(ddr_ctrl_base, 0, 0x0100);
+}
+
+int dram_init(void)
+{
+#if defined(CONFIG_CADENCE_DDR_CTRL)
+	ddr_phy_init(RZN1_DDR3_SINGLE_BANK);
+
+	/* Override DDR PHY related settings */
+	ddr_350_374_async[351 - 350] = 0x001e0000;
+	ddr_350_374_async[352 - 350] = 0x1e680000;
+	ddr_350_374_async[353 - 350] = 0x02000020;
+	ddr_350_374_async[354 - 350] = 0x02000200;
+	ddr_350_374_async[355 - 350] = 0x00000c30;
+	ddr_350_374_async[356 - 350] = 0x00009808;
+	ddr_350_374_async[357 - 350] = 0x020a0706;
+	ddr_350_374_async[372 - 350] = 0x01000000;
+
+	rzn1_ddr_ctrl_init(ddr_00_87_async, ddr_350_374_async,
+			   CONFIG_SYS_SDRAM_SIZE);
+
+	rzn1_ddr3_single_bank((void *)RZN1_DDR_BASE);
+	cdns_ddr_set_diff_cs_delays((void *)RZN1_DDR_BASE, 2, 7, 2, 2);
+	cdns_ddr_set_same_cs_delays((void *)RZN1_DDR_BASE, 0, 7, 0, 0);
+	cdns_ddr_set_odt_times((void *)RZN1_DDR_BASE, 5, 6, 6, 0, 4);
+	cdns_ddr_ctrl_start((void *)RZN1_DDR_BASE);
+
+	ddr_phy_enable_wl();
+
+#if defined(CONFIG_CADENCE_DDR_CTRL_ENABLE_ECC)
+	/*
+	 * Any read before a write will trigger an ECC un-correctable error,
+	 * causing a data abort. However, this is also true for any read with a
+	 * size less than the AXI bus width. So, the only sensible solution is
+	 * to write to all of DDR now and take the hit...
+	 */
+	memset((void *)RZN1_V_DDR_BASE, 0xff, CONFIG_SYS_SDRAM_SIZE);
+
+	/*
+	 * Note: The call to get_ram_size() below checks to see what memory is
+	 * actually there, but it reads before writing which would also trigger
+	 * an ECC un-correctable error if we don't write to all of DDR.
+	 */
+#endif
+	gd->ram_size = get_ram_size((void *)CONFIG_SYS_SDRAM_BASE,
+					    CONFIG_SYS_SDRAM_SIZE);
+#endif
+
+	return 0;
+}
+
+#if defined(RZN1_ENABLE_ETHERNET)
+/* RIN Ether Accessory (Switch Control) regs */
+#define MODCTRL				0x8
+#define MT5PT_SWITCH_UPSTREAM_PORT	4
+
+/*
+ * RIN RGMII/RMII Converter and switch setup.
+ * Called when DW ethernet determines the link speed
+ */
+int phy_adjust_link_notifier(struct phy_device *phy)
+{
+#ifdef CONFIG_DM_ETH
+	struct udevice *dev = phy->dev;
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+	int gmac0 = pdata->iobase == RZN1_GMAC0_BASE ? 1 : 0;
+#else
+	struct eth_device *eth = phy->dev;
+	int gmac0 = eth->index == 0 ? 1 : 0;
+#endif
+
+	if (gmac0) {
+		/* GMAC0 can only be connected to RGMII/RMII Converter 0 */
+		rzn1_rgmii_rmii_conv_speed(0, phy->duplex, phy->speed);
+	} else {
+		int port;
+
+		/* GMAC1 goes via the 5-port switch */
+		/* All ports are enabled on the switch, but U-Boot only supports
+		 * a single PHY attached to it. Since we have no idea which port
+		 * the PHY is actually being used with, we update all ports.
+		 */
+		for (port = 0; port < 4; port++) {
+			rzn1_rgmii_rmii_conv_speed(4 - port, phy->duplex, phy->speed);
+			rzn1_switch_setup_port_speed(port, phy->speed, 1);
+		}
+	}
+
+	return 0;
+}
+
+static int rzn1_board_eth_init(void)
+{
+	int ret = 0;
+
+	rzn1_rin_init();
+
+	/* Setup RGMII/RMII Converters */
+	rzn1_rgmii_rmii_conv_setup(0, PHY_INTERFACE_MODE_RGMII_ID, 0);
+	rzn1_rgmii_rmii_conv_setup(1, PHY_INTERFACE_MODE_RGMII_ID, 0);
+	rzn1_rgmii_rmii_conv_setup(2, PHY_INTERFACE_MODE_RGMII_ID, 0);
+	rzn1_rgmii_rmii_conv_setup(3, PHY_INTERFACE_MODE_MII, 1);
+	rzn1_rgmii_rmii_conv_setup(4, PHY_INTERFACE_MODE_MII, 1);
+
+	/* RIN: Mode Control - GMAC1 on all Switch ports */
+	rzn1_rin_prot_writel(0x13, MODCTRL);
+
+	rzn1_mt5pt_switch_init();
+
+	/* Upstream port is always 1Gbps */
+	rzn1_switch_setup_port_speed(MT5PT_SWITCH_UPSTREAM_PORT, SPEED_1000, 1);
+
+	rzn1_rin_reset_clks();
+
+#ifdef RZN1_APPLY_ETH_PHY_RESET_PULSE
+	struct gpio_desc reset_gpio = {};
+	int node;
+
+	/* The PHY reset pin is in the 5-port switch DT node because the PHYs
+	 * are connected to the switch and not to the GMAC. */
+	node = fdt_node_offset_by_compatible(gd->fdt_blob, 0, "mtip,5pt_switch");
+	if (node < 0)
+		return node;
+
+	ret = gpio_request_by_name_nodev(gd->fdt_blob, node, "phy-reset-gpios", 0,
+				 &reset_gpio, GPIOD_IS_OUT);
+	if (ret)
+		return ret;
+
+	/* reset the phy */
+	ret = dm_gpio_set_value(&reset_gpio, 0);
+	if (ret)
+		return ret;
+
+	mdelay(15);
+
+	ret = dm_gpio_set_value(&reset_gpio, 1);
+	if (ret)
+		return ret;
+#endif
+
+	/* Enable Ethernet GMAC0 (only used on EB board) */
+	rzn1_clk_set_gate(RZN1_HCLK_GMAC0_ID, 1);
+	rzn1_clk_reset(RZN1_HCLK_GMAC0_ID);
+
+	/* Enable Ethernet GMAC1 */
+	rzn1_clk_set_gate(RZN1_HCLK_GMAC1_ID, 1);
+	rzn1_clk_reset(RZN1_HCLK_GMAC1_ID);
+
+	return ret;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+	u32 if_type;
+
+	ret = rzn1_board_eth_init();
+	if (ret)
+		return ret;
+
+	/* Enable Ethernet GMAC0 (only used on EB board) */
+	if (designware_initialize(RZN1_GMAC0_BASE, PHY_INTERFACE_MODE_RGMII_ID) >= 0)
+		ret++;
+
+	/* Work out which PHY interface we are using based in the PHY address */
+	if ((CONFIG_PHY1_ADDR == 4) || (CONFIG_PHY1_ADDR == 5))
+		if_type = PHY_INTERFACE_MODE_MII;
+	else
+		if_type = PHY_INTERFACE_MODE_RGMII_ID;
+
+	/* Enable Ethernet GMAC1.
+	 * Uses a fixed 1Gbps link to the 5-port switch.
+	 * The interface specified here is the PHY side, not 5-port switch side.
+	 */
+	if (designware_initialize_fixed_link(RZN1_GMAC1_BASE, if_type, SPEED_1000) >= 0)
+		ret++;
+
+	return ret;
+}
+
+/* Re-use Marvell function */
+void m88e1518_phy_writebits(struct phy_device *phydev,
+		   u8 reg_num, u16 offset, u16 len, u16 data);
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	/*
+	 * Board Design Note:
+	 * Depending on switch settings and pin multiplexing, the 5-Port Switch
+	 * may use the LED[0] from the PHYs as a link up/down status signal, so
+	 * we program the PHYs to output this.
+	 * Note: This only changes the PHYs that are actually used by U-Boot.
+	 *
+	 * The KSZ8041 PHY LED[0] signal must be inverted by the R-In Engine
+	 * using the "Ethernet PHY Link Mode" reg, see board_init() above.
+	 * If the Switch Link Status signal is disabled by hardware, the 5-Port
+	 * Switch will think the link is permanently down.
+	 */
+#define MARVELL_88E1512		0x1410dd4
+#define MII_MARVELL_PHY_PAGE	22
+	if (phydev->phy_id == MARVELL_88E1512) {
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_MARVELL_PHY_PAGE, 3);
+
+		/* LED Func Control: LED[0]: link up = On, link down = Off */
+		m88e1518_phy_writebits(phydev, 16, 0, 4, 0);
+
+		/* LED[2] is used as an active low interrupt */
+		m88e1518_phy_writebits(phydev, 18, 7, 1, 1);
+
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_MARVELL_PHY_PAGE, 0);
+	}
+
+#define MICREL_KSZ8041		0x221513
+	if (phydev->phy_id == MICREL_KSZ8041) {
+		/* LED Mode: link up = drive low, link down = drive high */
+		m88e1518_phy_writebits(phydev, 0x1e, 14, 2, 1);
+	}
+
+#define PHY_LINK_MODE		0x14		/* Ethernet PHY Link Mode */
+	/* R-IN Engine: Invert all of the 5-Port Switch Link Status signals */
+	rzn1_rin_prot_writel(0x37f, PHY_LINK_MODE);
+
+	return 0;
+}
+#endif	/* RZN1_ENABLE_ETHERNET */
+
+#if defined(CONFIG_SPL_BOARD_INIT)
+void spl_board_init(void)
+{
+	arch_cpu_init();
+	preloader_console_init();
+	board_init();
+	dram_init();
+
+#if defined(RZN1_ENABLE_ETHERNET)
+	rzn1_board_eth_init();
+#endif
+}
+#endif
diff --git a/board/renesas/rzn1s324-db/Kconfig b/board/renesas/rzn1s324-db/Kconfig
new file mode 100644
index 0000000..f9d3ad5
--- /dev/null
+++ b/board/renesas/rzn1s324-db/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_RENESAS_RZN1S324_DB
+
+config SYS_BOARD
+	default "rzn1s324-db"
+
+config SYS_VENDOR
+	default "renesas"
+
+config SYS_SOC
+	default "rzn1"
+
+config SYS_CONFIG_NAME
+	default "rzn1s324-db"
+
+endif
diff --git a/board/renesas/rzn1s324-db/Makefile b/board/renesas/rzn1s324-db/Makefile
new file mode 100644
index 0000000..a095f9f
--- /dev/null
+++ b/board/renesas/rzn1s324-db/Makefile
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2017 Renesas Electronics Europe Ltd
+#
+# SPDX-License-Identifier: GPL-2.0
+#
+
+obj-y	:= setup.o
diff --git a/board/renesas/rzn1s324-db/rzn1-board-pinmux.h b/board/renesas/rzn1s324-db/rzn1-board-pinmux.h
new file mode 100755
index 0000000..a0db0a2
--- /dev/null
+++ b/board/renesas/rzn1s324-db/rzn1-board-pinmux.h
@@ -0,0 +1,373 @@
+﻿/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_BOARD_PINMUX_H__
+#define __RZN1_BOARD_PINMUX_H__
+/*
+ * AUTOGENERATED DO NOT EDIT
+ *
+ * Renesas RZ/N1S Demo Board
+ * This file only sets the pin function by default.
+ *
+ * You can override the default mux pullup/down and drive by
+ * defining the following macros in the board file before
+ * including this.
+ */
+
+#ifndef RZN1_MUX_DEFAULT
+#define RZN1_MUX_DEFAULT RZN1_MUX
+#endif
+
+#include "renesas/pinctrl-rzn1.h"
+
+#ifndef RZN1_MUX_CAN1
+#define RZN1_MUX_CAN1 RZN1_MUX_6MA
+#endif
+#ifndef RZN1_MUX_ETH0
+#define RZN1_MUX_ETH0 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH1
+#define RZN1_MUX_ETH1 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH2
+#define RZN1_MUX_ETH2 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH3
+#define RZN1_MUX_ETH3 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH4
+#define RZN1_MUX_ETH4 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_GPIO
+#define RZN1_MUX_GPIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_GPIO1
+#define RZN1_MUX_GPIO1 RZN1_MUX_GPIO
+#endif
+#ifndef RZN1_MUX_GPIO2
+#define RZN1_MUX_GPIO2 RZN1_MUX_GPIO
+#endif
+#ifndef RZN1_MUX_I2C1
+#define RZN1_MUX_I2C1 RZN1_MUX_12MA
+#endif
+#ifndef RZN1_MUX_LCD
+#define RZN1_MUX_LCD RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_MDIO
+#define RZN1_MUX_MDIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_MDIO0
+#define RZN1_MUX_MDIO0 RZN1_MUX_MDIO
+#endif
+#ifndef RZN1_MUX_MDIO1
+#define RZN1_MUX_MDIO1 RZN1_MUX_MDIO
+#endif
+#ifndef RZN1_MUX_NMI
+#define RZN1_MUX_NMI RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_QSPI0
+#define RZN1_MUX_QSPI0 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_QSPI
+#define RZN1_MUX_QSPI RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_QSPI1
+#define RZN1_MUX_QSPI1 RZN1_MUX_QSPI
+#endif
+#ifndef RZN1_MUX_REFCLK
+#define RZN1_MUX_REFCLK RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_SDIO
+#define RZN1_MUX_SDIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_SDIO0
+#define RZN1_MUX_SDIO0 RZN1_MUX_SDIO
+#endif
+#ifndef RZN1_MUX_SWITCH
+#define RZN1_MUX_SWITCH RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_UART0
+#define RZN1_MUX_UART0 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_UART2
+#define RZN1_MUX_UART2 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_UART
+#define RZN1_MUX_UART RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_UART3
+#define RZN1_MUX_UART3 RZN1_MUX_UART
+#endif
+#ifndef RZN1_MUX_USB
+#define RZN1_MUX_USB RZN1_MUX_DEFAULT
+#endif
+
+#define RZN1_MUX_PERIPH_BIT	24
+
+/*
+ * These numbers are arbitrary and do not correspond to anything
+ * on the hardware, they are for the application convenience only
+ * and *will* change if the pinmux is regenerated by the Webapp.
+ */
+enum {
+	RZN1_P_CAN1 = 0, RZN1_P_ETH0, RZN1_P_ETH1, RZN1_P_ETH2, RZN1_P_ETH3, RZN1_P_ETH4,
+	RZN1_P_GPIO1, RZN1_P_GPIO2, RZN1_P_I2C1, RZN1_P_LCD, RZN1_P_MDIO0, RZN1_P_MDIO1,
+	RZN1_P_NMI, RZN1_P_QSPI0, RZN1_P_QSPI1, RZN1_P_REFCLK, RZN1_P_SDIO0, RZN1_P_SWITCH,
+	RZN1_P_UART0, RZN1_P_UART2, RZN1_P_UART3, RZN1_P_USB, 
+};
+
+/*
+ * A peripheral number is also encoded in these constants to
+ * help parsing in case your code wishes to do pinmux selectively
+ */
+#define _RZP(_P, _M) ((_M) | (RZN1_##_P << RZN1_MUX_PERIPH_BIT))
+
+static const uint32_t rzn1_pinmux_map[] = {
+	_RZP(P_CAN1, RZN1_MUX_CAN1(109, CAN)),			/* CAN1_TXD */
+	_RZP(P_CAN1, RZN1_MUX_CAN1(110, CAN)),			/* CAN1_RXD */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(0, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXCLK */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(1, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[0] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(2, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[1] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(3, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[2] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(4, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[3] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(5, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXEN */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(6, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXCLK */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(7, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[0] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(8, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[1] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(9, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[2] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(10, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[3] */
+	_RZP(P_ETH0, RZN1_MUX_ETH0(11, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXDV */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(12, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXCLK */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(13, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[0] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(14, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[1] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(15, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[2] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(16, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[3] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(17, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXEN */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(18, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXCLK */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(19, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[0] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(20, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[1] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(21, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[2] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(22, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[3] */
+	_RZP(P_ETH1, RZN1_MUX_ETH1(23, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXDV */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(24, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXCLK */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(25, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[0] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(26, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[1] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(27, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[2] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(28, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[3] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(29, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXEN */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(30, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXCLK */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(31, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[0] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(32, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[1] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(33, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[2] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(34, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[3] */
+	_RZP(P_ETH2, RZN1_MUX_ETH2(35, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXDV */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(36, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXCLK */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(37, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[0] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(38, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[1] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(39, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[2] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(40, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[3] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(41, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXEN */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(42, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXCLK */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(43, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[0] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(44, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[1] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(45, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[2] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(46, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[3] */
+	_RZP(P_ETH3, RZN1_MUX_ETH3(47, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXDV */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(48, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXCLK */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(49, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[0] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(50, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[1] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(51, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[2] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(52, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[3] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(53, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXEN */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(54, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXCLK */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(55, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[0] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(56, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[1] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(57, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[2] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(58, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[3] */
+	_RZP(P_ETH4, RZN1_MUX_ETH4(59, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXDV */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(83, GPIO)),		/* PMOD_1 (GPIO1B[14]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(84, GPIO)),		/* PMOD_2 (GPIO1B[15]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(85, GPIO)),		/* PMOD_2 (GPIO1B[16]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(86, GPIO)),		/* PMOD_2 (GPIO1B[17]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(87, GPIO)),		/* PMOD_2 (GPIO1B[18]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(88, GPIO)),		/* PMOD_3 (GPIO1B[19]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(89, GPIO)),		/* PMOD_3 (GPIO1B[20]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(90, GPIO)),		/* PMOD_3 (GPIO1B[21]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(91, GPIO)),		/* PMOD_3 (GPIO1B[22]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(92, GPIO)),		/* LED_2R (GPIO1B[23]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(93, GPIO)),		/* LED_2G (GPIO1B[24]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(94, GPIO)),		/* ETH_PHY_RESET (GPIO1B[25]) */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(117, GPIO)),		/* GPIO1A[27] */
+	_RZP(P_GPIO1, RZN1_MUX_GPIO1(118, GPIO)),		/* ETHERNET Port3 IRQ (GPIO1A[28]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(126, GPIO)),		/* ETHERNET Port2 IRQ (GPIO2A[4]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(146, GPIO)),		/* ETHERNET Port1  IRQ (GPIO2A[24]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(147, GPIO)),		/* Eth Port4 IRQ (GPIO2A[25]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(148, GPIO)),		/* TouchSCRN_IRQ (GPIO2A[26]) */
+	_RZP(P_GPIO2, RZN1_MUX_GPIO2(149, GPIO)),		/* Eth Port5 IRQ (GPIO2A[27]) */
+	_RZP(P_I2C1, RZN1_MUX_I2C1(115, I2C)),			/* I2C1_SCL */
+	_RZP(P_I2C1, RZN1_MUX_I2C1(116, I2C)),			/* I2C1_SDA */
+	_RZP(P_LCD, RZN1_MUX_LCD(62, LCD)),			/* LCD_R[1] */
+	_RZP(P_LCD, RZN1_MUX_LCD(63, LCD)),			/* LCD_G[1] */
+	_RZP(P_LCD, RZN1_MUX_LCD(64, LCD)),			/* LCD_B[1] */
+	_RZP(P_LCD, RZN1_MUX_LCD(65, LCD)),			/* LCD_R[2] */
+	_RZP(P_LCD, RZN1_MUX_LCD(66, LCD)),			/* LCD_G[2] */
+	_RZP(P_LCD, RZN1_MUX_LCD(67, LCD)),			/* LCD_B[2] */
+	_RZP(P_LCD, RZN1_MUX_LCD(68, LCD)),			/* LCD_R[3] */
+	_RZP(P_LCD, RZN1_MUX_LCD(69, LCD)),			/* LCD_G[3] */
+	_RZP(P_LCD, RZN1_MUX_LCD(70, LCD)),			/* LCD_B[3] */
+	_RZP(P_LCD, RZN1_MUX_LCD(71, LCD)),			/* LCD_R[4] */
+	_RZP(P_LCD, RZN1_MUX_LCD(72, LCD)),			/* LCD_G[4] */
+	_RZP(P_LCD, RZN1_MUX_LCD(73, LCD)),			/* LCD_B[4] */
+	_RZP(P_LCD, RZN1_MUX_LCD(127, LCD)),			/* LCD_PWM[0] */
+	_RZP(P_LCD, RZN1_MUX_LCD(128, LCD)),			/* LCD_PCLK */
+	_RZP(P_LCD, RZN1_MUX_LCD(129, LCD)),			/* LCD_HSYNC */
+	_RZP(P_LCD, RZN1_MUX_LCD(130, LCD)),			/* LCD_VSYNC */
+	_RZP(P_LCD, RZN1_MUX_LCD(131, LCD)),			/* LCD_DE */
+	_RZP(P_LCD, RZN1_MUX_LCD(132, LCD)),			/* LCD_PE */
+	_RZP(P_LCD, RZN1_MUX_LCD(133, LCD)),			/* LCD_PWM[1] */
+	_RZP(P_LCD, RZN1_MUX_LCD(134, LCD)),			/* LCD_R[5] */
+	_RZP(P_LCD, RZN1_MUX_LCD(135, LCD)),			/* LCD_R[0] */
+	_RZP(P_LCD, RZN1_MUX_LCD(136, LCD)),			/* LCD_G[0] */
+	_RZP(P_LCD, RZN1_MUX_LCD(137, LCD)),			/* LCD_B[0] */
+	_RZP(P_LCD, RZN1_MUX_LCD(138, LCD)),			/* LCD_R[6] */
+	_RZP(P_LCD, RZN1_MUX_LCD(139, LCD)),			/* LCD_G[6] */
+	_RZP(P_LCD, RZN1_MUX_LCD(140, LCD)),			/* LCD_B[6] */
+	_RZP(P_LCD, RZN1_MUX_LCD(141, LCD)),			/* LCD_R[7] */
+	_RZP(P_LCD, RZN1_MUX_LCD(142, LCD)),			/* LCD_G[7] */
+	_RZP(P_LCD, RZN1_MUX_LCD(143, LCD)),			/* LCD_B[7] */
+	_RZP(P_LCD, RZN1_MUX_LCD(144, LCD)),			/* LCD_G[5] */
+	_RZP(P_LCD, RZN1_MUX_LCD(145, LCD)),			/* LCD_B[5] */
+	_RZP(P_MDIO0, RZN1_MUX_MDIO0(150, ETH_MDIO)),		/* MDIO0_MDC */
+	_RZP(P_MDIO0, RZN1_MUX_MDIO0(151, ETH_MDIO)),		/* MDIO0_MDIO */
+	_RZP(P_MDIO0, RZN1_MUX_MDIO0(170, MDIO_MUX_MAC0)),	/* MDIO0_MUX_MAC0 */
+	_RZP(P_MDIO1, RZN1_MUX_MDIO1(152, ETH_MDIO)),		/* MDIO1_MDC */
+	_RZP(P_MDIO1, RZN1_MUX_MDIO1(153, ETH_MDIO)),		/* MDIO1_MDIO */
+	_RZP(P_MDIO1, RZN1_MUX_MDIO1(171, MDIO_MUX_SWITCH)),	/* MDIO1_MUX_SWITCH */
+	_RZP(P_NMI, RZN1_MUX_NMI(111, ETHERCAT)),		/* NMI_CORTEXM[3] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(74, QSPI)),		/* QSPI0_CS_N[0] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(75, QSPI)),		/* QSPI0_IO[3] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(76, QSPI)),		/* QSPI0_IO[2] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(77, QSPI)),		/* QSPI0_IO[1] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(78, QSPI)),		/* QSPI0_IO[0] */
+	_RZP(P_QSPI0, RZN1_MUX_QSPI0(79, QSPI)),		/* QSPI0_CLK */
+	_RZP(P_QSPI1, RZN1_MUX_QSPI1(154, QSPI)),		/* QSPI1_CS_N[0] */
+	_RZP(P_QSPI1, RZN1_MUX_QSPI1(155, QSPI)),		/* QSPI1_IO[3] */
+	_RZP(P_QSPI1, RZN1_MUX_QSPI1(156, QSPI)),		/* QSPI1_IO[2] */
+	_RZP(P_QSPI1, RZN1_MUX_QSPI1(157, QSPI)),		/* QSPI1_IO[1] */
+	_RZP(P_QSPI1, RZN1_MUX_QSPI1(158, QSPI)),		/* QSPI1_IO[0] */
+	_RZP(P_QSPI1, RZN1_MUX_QSPI1(159, QSPI)),		/* QSPI1_CLK */
+	_RZP(P_REFCLK, RZN1_MUX_REFCLK(60, CLK_ETH_MII_RGMII_RMII)),	/* REFCLK_RGMII */
+	_RZP(P_REFCLK, RZN1_MUX_REFCLK(61, CLK_ETH_NAND)),	/* REFCLK_MII */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(95, SDIO)),		/* SDIO0_CMD */
+	_RZP(P_SDIO0, RZN1_MUX_12MA(96, SDIO)),			/* SDIO0_CLK */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(97, SDIO)),		/* SDIO0_IO[0] */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(98, SDIO)),		/* SDIO0_IO[1] */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(99, SDIO)),		/* SDIO0_IO[2] */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(100, SDIO)),		/* SDIO0_IO[3] */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(101, SDIO_E)),		/* SDIO0_CD_N */
+	_RZP(P_SDIO0, RZN1_MUX_SDIO0(102, SDIO_E)),		/* SDIO0_WP */
+	_RZP(P_SWITCH, RZN1_MUX_SWITCH(80, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[5] */
+	_RZP(P_SWITCH, RZN1_MUX_SWITCH(81, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[4] */
+	_RZP(P_SWITCH, RZN1_MUX_SWITCH(82, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[3] */
+	_RZP(P_SWITCH, RZN1_MUX_SWITCH(114, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[2] */
+	_RZP(P_UART0, RZN1_MUX_UART0(103, UART0_I)),		/* UART0_TXD */
+	_RZP(P_UART0, RZN1_MUX_UART0(104, UART0_I)),		/* UART0_RXD */
+	_RZP(P_UART2, RZN1_MUX_UART2(105, UART2)),		/* UART2_TXD */
+	_RZP(P_UART2, RZN1_MUX_UART2(106, UART2)),		/* UART2_RXD */
+	_RZP(P_UART2, RZN1_MUX_UART2(107, UART2)),		/* UART2_RTS_N */
+	_RZP(P_UART2, RZN1_MUX_UART2(108, UART2)),		/* UART2_CTS_N */
+	_RZP(P_UART3, RZN1_MUX_UART3(123, UART3)),		/* UART3_TXD */
+	_RZP(P_UART3, RZN1_MUX_UART3(124, UART3)),		/* UART3_RXD */
+	_RZP(P_UART3, RZN1_MUX_UART3(125, UART3)),		/* UART3_RTS_N */
+	_RZP(P_USB, RZN1_MUX_USB(119, USB)),			/* USB_PPON[1] */
+	_RZP(P_USB, RZN1_MUX_USB(120, USB)),			/* USB_OC[1] */
+	_RZP(P_USB, RZN1_MUX_USB(121, USB)),			/* USB_PPON[2] */
+	_RZP(P_USB, RZN1_MUX_USB(122, USB)),			/* USB_OC[2] */
+	0L, /* terminator */
+};
+/*
+ * Sample function for setting the pinmux. Pass -1 for setting /all/
+ * the pins, pass any of the RZN1_P_xxx for setting just that one set
+ * returns the number of pins that have been set.
+ * There is also a variant where you can pass multiple peripherals as
+ * a bitmask.
+ */
+#ifdef USE_DEFAULT_PINMUX
+/* Functions are marked 'unused' to prevent warnings on modern GCC */
+#if defined(__GNUC__)
+#define __unused __attribute__((unused))
+#elif !defined(__unused)
+#define __unused
+#endif
+static int rzn1_board_pinmux(int periph /* = -1 */) __unused;
+static int rzn1_board_pinmux(int periph /* = -1 */) {
+ int i, cnt = 0;
+ for (i = 0; rzn1_pinmux_map[i]; i++)
+  if (periph == -1 ||
+      (rzn1_pinmux_map[i] >> RZN1_MUX_PERIPH_BIT) == (uint32_t)periph) {
+       rzn1_pinmux_set(rzn1_pinmux_map[i]);
+       cnt++;
+ }
+ return cnt;
+}
+static int rzn1_board_pinmux_mask(uint32_t periph_mask /* = -1 */) __unused;
+static int rzn1_board_pinmux_mask(uint32_t periph_mask /* = -1 */) {
+ int i, cnt = 0;
+ for (i = 0; rzn1_pinmux_map[i]; i++)
+  if (periph_mask & (1 << (rzn1_pinmux_map[i] >> RZN1_MUX_PERIPH_BIT))) {
+   rzn1_pinmux_set(rzn1_pinmux_map[i]);
+   cnt++;
+  }
+ return cnt;
+}
+#endif
+
+/* 
+ * this is the compressed Renesas Pinmux Web App data structure; this is
+ * used to allow uploading this file back into the web app, make some
+ * more changes and generate/save the DTS again. It is not used by linux
+ * in any way.
+ */
+#ifdef JSON_PRESET
+N4IgdghgtgpiBcIBKMwwM4XQAiQLQHoA5ARgGVsARGKAe2wCFaIAnAExABoQAHCAYwDWEAOZxEbAMwAmACxdeMFgEseACyUQANug
+QBtEAGEAgkWkKAogBUAEiUu3z3azckOb857YCsCgOIACgCSAPJOIIGhbtxB0obhADKGlAoAspSh9tzpoeFEqUEKAIpkwVkgJcHhS
+BYAYoYJANIKZBkh5WQA6kFWhjYKAKrGSFblQyPRIONWnlNkDCAAutwiPMq0APqQsLrwoACc5oguFkhE1tgBtCwALpLYQUhFCiQAD
+ADsCCABqSGUG+U3gAOL4/P4Al6vfag37/QFvGHg+H2RBg/7hEgkI7fWEbDEkNyo3H4+RE8H43xk/6TTEANkR1JeJE+VI2NJIINZ7
+OhiASFnRSBe0leXz56L8QpRIBcGwCNgAmhsamRrEL6YhImEhSyIsEQi8ZF8TmcLldbtIHk8Xt5scbzlZLtcbiRsJbntwSN5CdKbm
+pHbdZG7raSQFZaABXfhqMiGM4bR7ukCeyk+v1mm7eIMAXxWa1ouz0728smZtM4RZL73e5eLzKBNcr+wbHNezaBJDb0jbkjbsjb3j
+bZYrHOrw6B9bHTeH+1b04706705707704H06Htf2o63E63U+Lwtnh9e85Pi5Py5Pq5P65Pm9kwp3j9ee5fB8fbwb0kx36xf6vT8b
+0/O9PwfH9nx/N8fw/aRhW/H8EIvR9pEAuDgLg0C4PA6RIOkaDpFgyRj0fSQz1I5DULQyQMMkAdvG8d5aXwzgGPeccBxoyRaTLLja
+WrPj6z4psuPeVtRI7USu1EntRL7UTONkSQmM4UTqwY9ti1Y7xNPonTPTLDTPXU/SdO0zSm28N45FY6z6OsstZCY/YmycsTWzc09O
+E8rtPJ7Ty+08gdPMcqsPm8sL6081yqy/GiSCU7zDiBfZeJLWRFIStKEoE9KhNpEht1Ugr9nrbxmPefYO3K3DDlY2kvS9erGr7crG
+vohq6LLOQMpSzgeu8GdVPK/ZOJG3iRvUt4zO8V5aRc+i5pc0L3kkfyqxo4rStk+agXk3bON2xzPVG7yTuOwbqzcx9VNkJTJLumRb
+qU2THvkx7FKUtKlNypShMekS7tkcSgYeu7pKB16geejKYe+pyYf+u6YqY3yq1pdamMC9HDtm6SGteHbZv22bOMkfZZF48mEbWimh
+OpkTydm1SmeqkhmMMm1MUWLMgA==
+#endif
+
+#endif /* __RZN1_BOARD_PINMUX_H__ */
diff --git a/board/renesas/rzn1s324-db/setup.c b/board/renesas/rzn1s324-db/setup.c
new file mode 100644
index 0000000..508e7eb
--- /dev/null
+++ b/board/renesas/rzn1s324-db/setup.c
@@ -0,0 +1,334 @@
+/*
+ * Renesas RZ/N1S-324 Demo Board, can be used with RZ/N1 Extension Board
+ *
+ * (C) Copyright 2017 Renesas Electronics Europe Limited
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ */
+/*
+ * WARNING! All hardware information (device and board) indexes start at 1,
+ * whereas all software indexes start at 0. Everything in this file refers
+ * to the software indexes.
+ */
+
+#include <common.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <dm.h>
+#include <led.h>
+#include <linux/sizes.h>
+#include <malloc.h>
+#include <sdhci.h>
+#include <spl.h>
+#include <usb.h>
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-sysctrl.h"
+#include "renesas/rzn1-utils.h"
+#include "renesas/rzn1-clocks.h"
+#include "renesas/pinctrl-rzn1.h"
+#define USE_DEFAULT_PINMUX
+#include "rzn1-board-pinmux.h"
+#include "cadence_ddr_ctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+/* Called early during device initialisation */
+void rzn1_setup_pinmux(void)
+{
+	/* Set all pin mux and drive stength to defaults for this board */
+	rzn1_board_pinmux(-1);
+
+	/*
+	 * This is special 'virtual' pins for the MDIO multiplexing.
+	 * The default sets MDIO1 control to the 5-port Switch, but U-Boot
+	 * doesn't have a driver for this, hence MDIO1 is controlled by GMAC1
+	 */
+	rzn1_pinmux_set(RZN1_MUX_MDIO(RZN1_MDIO_BUS1, MDIO_MUX_MAC1));
+}
+
+#if defined(RZN1_ENABLE_USBF) && !defined(CONFIG_SPL_BUILD)
+/* Configure board specific clocks for the USB blocks */
+int board_usb_init(int index, enum usb_init_type init)
+{
+	/* Configure device clocks, etc */
+	return rzn1_usb_init(index, init);
+}
+#endif
+
+static int set_led(const char *name, int val)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = led_get_by_label(name, &dev);
+	if (ret)
+		return ret;
+
+	return led_set_on(dev, val);
+}
+
+int rzn1_ctrl(void)
+{
+#if defined(RZN1_ENABLE_I2C)
+	/*
+	 * Switch I2C master for the EEPROM from the FTDI device to the RZ/N1.
+	 * The order is important as we want to avoid two masters connected at
+	 * the same time.
+	 * NOTE: ctrl0 is marked as ACTIVE_LOW in the dts
+	 */
+	/* Pretend the ctrl pins are leds. It works... */
+	set_led("ctrl1", 0);
+	set_led("ctrl2", 0);
+	set_led("ctrl0", 0);
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+#if defined(RZN1_ENABLE_QSPI)
+	/* Enable QSPI */
+	rzn1_clk_set_gate(RZN1_CLK_QSPI0_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_QSPI0_ID, 1);
+	rzn1_clk_set_gate(RZN1_CLK_QSPI1_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_QSPI1_ID, 1);
+#endif
+
+#if defined(RZN1_ENABLE_I2C) && !defined(CONFIG_SPL_BUILD)
+	rzn1_clk_set_gate(RZN1_HCLK_I2C1_ID, 1);
+	rzn1_ctrl();
+#endif
+
+#if defined(RZN1_ENABLE_SDHC) && !defined(CONFIG_SPL_BUILD)
+	/* Enable SDHC0 */
+	rzn1_clk_set_gate(RZN1_CLK_SDIO0_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_SDIO0_ID, 1);
+	rzn1_clk_reset(RZN1_HCLK_SDIO0_ID);
+#endif
+
+#if defined(RZN1_ENABLE_GPIO)
+	/* Enable GPIO clock */
+	rzn1_clk_set_gate(RZN1_HCLK_GPIO0_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_GPIO1_ID, 1);
+	rzn1_clk_set_gate(RZN1_HCLK_GPIO2_ID, 1);
+#endif
+
+#if defined(RZN1_ENABLE_USBF) && !defined(CONFIG_SPL_BUILD)
+		board_usb_init(0, USB_INIT_DEVICE);
+#endif
+
+#if defined(CONFIG_ARMV7_NONSEC) && defined(CONFIG_ARMV7_NONSEC_AT_BOOT)
+	/* Change to non-secure mode now */
+	armv7_init_nonsec();
+#endif
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	/* No DDR possible on this device */
+	return 0;
+}
+
+#if defined(RZN1_ENABLE_ETHERNET)
+/* RIN Ether Accessory (Switch Control) regs */
+#define MODCTRL				0x8
+#define MT5PT_SWITCH_UPSTREAM_PORT	4
+
+/*
+ * RIN RGMII/RMII Converter and switch setup.
+ * Called when DW ethernet determines the link speed
+ */
+int phy_adjust_link_notifier(struct phy_device *phy)
+{
+#ifdef CONFIG_DM_ETH
+	struct udevice *dev = phy->dev;
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+	int gmac0 = pdata->iobase == RZN1_GMAC0_BASE ? 1 : 0;
+#else
+	struct eth_device *eth = phy->dev;
+	int gmac0 = eth->index == 0 ? 1 : 0;
+#endif
+
+	if (gmac0) {
+		/* GMAC0 can only be connected to RGMII/RMII Converter 0 */
+		rzn1_rgmii_rmii_conv_speed(0, phy->duplex, phy->speed);
+	} else {
+		int port;
+
+		/* GMAC1 goes via the 5-port switch */
+		/* All ports are enabled on the switch, but U-Boot only supports
+		 * a single PHY attached to it. Since we have no idea which port
+		 * the PHY is actually being used with, we update all ports.
+		 */
+		for (port = 0; port < 4; port++) {
+			rzn1_rgmii_rmii_conv_speed(4 - port, phy->duplex, phy->speed);
+			rzn1_switch_setup_port_speed(port, phy->speed, 1);
+		}
+	}
+
+	return 0;
+}
+
+static int rzn1_board_eth_init(void)
+{
+	int ret = 0;
+
+	rzn1_rin_init();
+
+	/* Setup RGMII/RMII Converters */
+	rzn1_rgmii_rmii_conv_setup(0, PHY_INTERFACE_MODE_RGMII_ID, 0);
+	rzn1_rgmii_rmii_conv_setup(1, PHY_INTERFACE_MODE_RGMII_ID, 0);
+	rzn1_rgmii_rmii_conv_setup(2, PHY_INTERFACE_MODE_RGMII_ID, 0);
+	rzn1_rgmii_rmii_conv_setup(3, PHY_INTERFACE_MODE_MII, 1);
+	rzn1_rgmii_rmii_conv_setup(4, PHY_INTERFACE_MODE_MII, 1);
+
+	/* RIN: Mode Control - GMAC1 on all Switch ports */
+	rzn1_rin_prot_writel(0x13, MODCTRL);
+
+	rzn1_mt5pt_switch_init();
+
+	/* Upstream port is always 1Gbps */
+	rzn1_switch_setup_port_speed(MT5PT_SWITCH_UPSTREAM_PORT, SPEED_1000, 1);
+
+	rzn1_rin_reset_clks();
+
+#ifdef RZN1_APPLY_ETH_PHY_RESET_PULSE
+	struct gpio_desc reset_gpio = {};
+	int node;
+
+	/* The PHY reset pin is in the 5-port switch DT node because the PHYs
+	 * are connected to the switch and not to the GMAC. */
+	node = fdt_node_offset_by_compatible(gd->fdt_blob, 0, "mtip,5pt_switch");
+	if (node < 0)
+		return node;
+
+	ret = gpio_request_by_name_nodev(gd->fdt_blob, node, "phy-reset-gpios", 0,
+				 &reset_gpio, GPIOD_IS_OUT);
+	if (ret)
+		return ret;
+
+	/* reset the phy */
+	ret = dm_gpio_set_value(&reset_gpio, 0);
+	if (ret)
+		return ret;
+
+	mdelay(15);
+
+	ret = dm_gpio_set_value(&reset_gpio, 1);
+	if (ret)
+		return ret;
+#endif
+
+	/* Enable Ethernet GMAC0 (only used on EB board) */
+	rzn1_clk_set_gate(RZN1_HCLK_GMAC0_ID, 1);
+	rzn1_clk_reset(RZN1_HCLK_GMAC0_ID);
+
+	/* Enable Ethernet GMAC1 */
+	rzn1_clk_set_gate(RZN1_HCLK_GMAC1_ID, 1);
+	rzn1_clk_reset(RZN1_HCLK_GMAC1_ID);
+
+	return ret;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+	u32 if_type;
+
+	ret = rzn1_board_eth_init();
+	if (ret)
+		return ret;
+
+	/* Enable Ethernet GMAC0 (only used on EB board) */
+	if (designware_initialize(RZN1_GMAC0_BASE, PHY_INTERFACE_MODE_RGMII_ID) >= 0)
+		ret++;
+
+	/* Work out which PHY interface we are using based in the PHY address */
+	if ((CONFIG_PHY1_ADDR == 4) || (CONFIG_PHY1_ADDR == 5))
+		if_type = PHY_INTERFACE_MODE_MII;
+	else
+		if_type = PHY_INTERFACE_MODE_RGMII_ID;
+
+	/* Enable Ethernet GMAC1.
+	 * Uses a fixed 1Gbps link to the 5-port switch.
+	 * The interface specified here is the PHY side, not 5-port switch side.
+	 */
+	if (designware_initialize_fixed_link(RZN1_GMAC1_BASE, if_type, SPEED_1000) >= 0)
+		ret++;
+
+	return ret;
+}
+
+/* Re-use Marvell function */
+void m88e1518_phy_writebits(struct phy_device *phydev,
+		   u8 reg_num, u16 offset, u16 len, u16 data);
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	/*
+	 * Board Design Note:
+	 * Depending on switch settings and pin multiplexing, the 5-Port Switch
+	 * may use the LED[0] from the PHYs as a link up/down status signal, so
+	 * we program the PHYs to output this.
+	 * Note: This only changes the PHYs that are actually used by U-Boot.
+	 *
+	 * The KSZ8041 PHY LED[0] signal must be inverted by the R-In Engine
+	 * using the "Ethernet PHY Link Mode" reg, see board_init() above.
+	 * If the Switch Link Status signal is disabled by hardware, the 5-Port
+	 * Switch will think the link is permanently down.
+	 */
+#define MARVELL_88E1512		0x1410dd4
+#define MII_MARVELL_PHY_PAGE	22
+	if (phydev->phy_id == MARVELL_88E1512) {
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_MARVELL_PHY_PAGE, 3);
+
+		/* LED Func Control: LED[0]: link up = On, link down = Off */
+		m88e1518_phy_writebits(phydev, 16, 0, 4, 0);
+
+		/* LED[2] is used as an active low interrupt */
+		m88e1518_phy_writebits(phydev, 18, 7, 1, 1);
+
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_MARVELL_PHY_PAGE, 0);
+	}
+
+#define MICREL_KSZ8041		0x221513
+	if (phydev->phy_id == MICREL_KSZ8041) {
+		/* LED Mode: link up = drive low, link down = drive high */
+		m88e1518_phy_writebits(phydev, 0x1e, 14, 2, 1);
+	}
+
+#define PHY_LINK_MODE		0x14		/* Ethernet PHY Link Mode */
+	/* R-IN Engine: Invert all of the 5-Port Switch Link Status signals */
+	rzn1_rin_prot_writel(0x37f, PHY_LINK_MODE);
+
+	return 0;
+}
+#endif	/* RZN1_ENABLE_ETHERNET */
+
+#if defined(CONFIG_SPL_BOARD_INIT)
+void spl_board_init(void)
+{
+	arch_cpu_init();
+	preloader_console_init();
+	board_init();
+	dram_init();
+
+#if defined(RZN1_ENABLE_ETHERNET)
+	rzn1_board_eth_init();
+#endif
+}
+#endif
diff --git a/cmd/Kconfig b/cmd/Kconfig
index 91bd3fb..14e0d41 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -437,6 +437,14 @@ config CMD_DFU
 	  Enables the command "dfu" which is used to have U-Boot create a DFU
 	  class device via USB.
 
+config CMD_DFU_EXT
+	bool "dfu extended"
+	depends on CMD_DFU
+	help
+	  Changes the "dfu" command to support multiple dfu targets, e.g. nand
+	  and spi flash. To use this, the "dfu_ext_info" env var is populated
+	  with a list of semi-colon seperated targets.
+
 config CMD_USB_MASS_STORAGE
 	bool "UMS usb mass storage"
 	help
diff --git a/cmd/dfu.c b/cmd/dfu.c
index 04291f6..f4a7a5a 100644
--- a/cmd/dfu.c
+++ b/cmd/dfu.c
@@ -21,7 +21,7 @@
 
 static int do_dfu(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
-
+#ifndef CONFIG_CMD_DFU_EXT
 	if (argc < 4)
 		return CMD_RET_USAGE;
 
@@ -49,7 +49,24 @@ static int do_dfu(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		dfu_show_entities();
 		goto done;
 	}
+#else
+	/* DFU EXT allows allows us to target multiple interfaces, all info
+	 * about the interfaces is in the 'dfu_ext_info' env var, rather than
+	 * passed in via the dfu command. */
+	char *usb_controller = argv[1];
+	int ret;
+
+	ret = dfu_init_env_entities(NULL, NULL);
+	if (ret)
+		goto done;
+
+	ret = CMD_RET_SUCCESS;
+	if (argc > 1 && !strcmp(argv[1], "list")) {
+		dfu_show_entities();
+		goto done;
+	}
 
+#endif /* CONFIG_CMD_DFU_EXT */
 	int controller_index = simple_strtoul(usb_controller, NULL, 0);
 
 	run_usb_dnl_gadget(controller_index, "usb_dnl_dfu");
@@ -61,6 +78,7 @@ done:
 
 U_BOOT_CMD(dfu, CONFIG_SYS_MAXARGS, 1, do_dfu,
 	"Device Firmware Upgrade",
+#ifndef CONFIG_CMD_DFU_EXT
 	"<USB_controller> <interface> <dev> [list]\n"
 	"  - device firmware upgrade via <USB_controller>\n"
 	"    on device <dev>, attached to interface\n"
@@ -73,4 +91,8 @@ U_BOOT_CMD(dfu, CONFIG_SYS_MAXARGS, 1, do_dfu,
 	"    <interface>\n"
 	"    [<addr>] - address where FIT image has been stored\n"
 #endif
+#else
+	" [list]\n"
+	"    [list] - list available DFU settings\n"
+#endif /* CONFIG_CMD_DFU_EXT */
 );
diff --git a/cmd/mem.c b/cmd/mem.c
index a690957..731448a 100644
--- a/cmd/mem.c
+++ b/cmd/mem.c
@@ -374,6 +374,7 @@ static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	ulong	addr, dest, count, bytes;
 	int	size;
+	bool	nosize = false;
 	const void *src;
 	void *buf;
 
@@ -382,8 +383,13 @@ static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	/* Check for size specification.
 	*/
-	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
+	if ((size = cmd_get_data_size(argv[0], 0)) < 0)
 		return 1;
+	/* Check to see if no size was specified */
+	if (size == 0) {
+		size = 4;
+		nosize = true;
+	}
 
 	addr = simple_strtoul(argv[1], NULL, 16);
 	addr += base_address;
@@ -468,6 +474,13 @@ static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	bytes = size * count;
 	buf = map_sysmem(dest, bytes);
 	src = map_sysmem(addr, bytes);
+
+	/* If size wasn't specified use memcpy for speed */
+	if (nosize) {
+		memcpy((void *)dest, (void *)addr, count*size);
+		return 0;
+	}
+
 	while (count-- > 0) {
 		if (size == 4)
 			*((u32 *)buf) = *((u32  *)src);
diff --git a/cmd/misc.c b/cmd/misc.c
index efcbb90..5ba7639 100644
--- a/cmd/misc.c
+++ b/cmd/misc.c
@@ -71,6 +71,7 @@ static int do_timer(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	if (!strcmp(argv[1], "get")) {
 		ulong msecs = get_timer(start) * 1000 / CONFIG_SYS_HZ;
+		setenv_ulong("milliseconds", msecs);
 		printf("%ld.%03d\n", msecs / 1000, (int)(msecs % 1000));
 	}
 
diff --git a/cmd/nand.c b/cmd/nand.c
index c16ec77..97cf312 100644
--- a/cmd/nand.c
+++ b/cmd/nand.c
@@ -286,7 +286,7 @@ static void nand_print_and_set_info(int idx)
 	struct mtd_info *mtd = nand_info[idx];
 	struct nand_chip *chip = mtd_to_nand(mtd);
 
-	printf("Device %d: ", idx);
+	printf("Device %d (%s %s): ", idx, chip->onfi_params.manufacturer, chip->onfi_params.model);
 	if (chip->numchips > 1)
 		printf("%dx ", chip->numchips);
 	printf("%s, sector size %u KiB\n",
@@ -298,6 +298,12 @@ static void nand_print_and_set_info(int idx)
 	printf("  options     0x%8x\n", chip->options);
 	printf("  bbt options 0x%8x\n", chip->bbt_options);
 
+	printf("  ECC BCH%d, block size        %d b\n", chip->ecc.strength, chip->ecc.size);
+	printf("  ECC bytes per block          %d b\n", chip->ecc.bytes);
+#if defined(RZN1_NAND_OOB_FS_BYTES)
+	printf("  ECC reserved for file system %d b\n", RZN1_NAND_OOB_FS_BYTES);
+#endif
+
 	/* Set geometry info */
 	setenv_hex("nand_writesize", mtd->writesize);
 	setenv_hex("nand_oobsize", mtd->oobsize);
diff --git a/common/board_f.c b/common/board_f.c
index cc8aee7..4e38de7 100644
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -361,11 +361,15 @@ static int setup_dest_addr(void)
 	 */
 	gd->ram_size = board_reserve_ram_top(gd->ram_size);
 
+#ifdef CONFIG_SYS_STAY_IN_SRAM
+	gd->ram_top = CONFIG_SYS_SRAM_BASE + CONFIG_SYS_SRAM_SIZE;
+#else
 #ifdef CONFIG_SYS_SDRAM_BASE
 	gd->ram_top = CONFIG_SYS_SDRAM_BASE;
 #endif
 	gd->ram_top += get_effective_memsize();
 	gd->ram_top = board_get_usable_ram_top(gd->mon_len);
+#endif /* CONFIG_SYS_STAY_IN_SRAM */
 	gd->relocaddr = gd->ram_top;
 	debug("Ram top: %08lX\n", (ulong)gd->ram_top);
 #if defined(CONFIG_MP) && (defined(CONFIG_MPC86xx) || defined(CONFIG_E500))
@@ -435,8 +439,8 @@ static int reserve_mmu(void)
 	gd->arch.tlb_size = PGTABLE_SIZE;
 	gd->relocaddr -= gd->arch.tlb_size;
 
-	/* round down to next 64 kB limit */
-	gd->relocaddr &= ~(0x10000 - 1);
+	/* round down to ensure alignment */
+	gd->relocaddr &= ~(PGTABLE_SIZE - 1);
 
 	gd->arch.tlb_addr = gd->relocaddr;
 	debug("TLB table from %08lx to %08lx\n", gd->arch.tlb_addr,
@@ -513,6 +517,9 @@ static int reserve_trace(void)
 
 static int reserve_uboot(void)
 {
+#ifdef CONFIG_SYS_STAY_IN_SRAM
+	debug("Skipping u-boot relocate\n");
+#else
 	/*
 	 * reserve memory for U-Boot code, data & bss
 	 * round down to next 4 kB limit
@@ -526,6 +533,7 @@ static int reserve_uboot(void)
 
 	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10,
 	      gd->relocaddr);
+#endif
 
 	gd->start_addr_sp = gd->relocaddr;
 
@@ -537,6 +545,10 @@ static int reserve_uboot(void)
 static int reserve_malloc(void)
 {
 	gd->start_addr_sp = gd->start_addr_sp - TOTAL_MALLOC_LEN;
+#ifdef CONFIG_SYS_STAY_IN_SRAM
+	gd->malloc_pool_addr = gd->start_addr_sp;
+	debug("malloc pool at: %08lx\n", gd->malloc_pool_addr);
+#endif
 	debug("Reserving %dk for malloc() at: %08lx\n",
 			TOTAL_MALLOC_LEN >> 10, gd->start_addr_sp);
 	return 0;
@@ -742,6 +754,13 @@ static int reloc_fdt(void)
 
 static int setup_reloc(void)
 {
+#ifdef CONFIG_SYS_STAY_IN_SRAM
+	extern char __image_copy_start[];
+	debug("Skipped relocation to %lx\n", (ulong)__image_copy_start);
+	gd->relocaddr = CONFIG_SYS_TEXT_BASE;
+	debug("Free ram between u-boot and stack: %ld\n",
+		gd->start_addr_sp - gd->relocaddr + gd->mon_len);
+#else
 	if (gd->flags & GD_FLG_SKIP_RELOC) {
 		debug("Skipping relocation due to flag\n");
 		return 0;
@@ -757,9 +776,10 @@ static int setup_reloc(void)
 	gd->reloc_off = gd->relocaddr - (CONFIG_SYS_TEXT_BASE + 0x400);
 #endif
 #endif
+	debug("Relocation Offset is: %08lx\n", gd->reloc_off);
+#endif
 	memcpy(gd->new_gd, (char *)gd, sizeof(gd_t));
 
-	debug("Relocation Offset is: %08lx\n", gd->reloc_off);
 	debug("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
 	      gd->relocaddr, (ulong)map_to_sysmem(gd->new_gd),
 	      gd->start_addr_sp);
@@ -768,7 +788,7 @@ static int setup_reloc(void)
 }
 
 /* ARM calls relocate_code from its crt0.S */
-#if !defined(CONFIG_ARM) && !defined(CONFIG_SANDBOX)
+#if !defined(CONFIG_ARM) && !defined(CONFIG_SANDBOX) && !defined(CONFIG_SYS_STAY_IN_SRAM)
 
 static int jump_to_copy(void)
 {
diff --git a/common/board_r.c b/common/board_r.c
index a373352..eb2df64 100644
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -286,12 +286,19 @@ static int initr_malloc(void)
 {
 	ulong malloc_start;
 
+#ifdef CONFIG_SYS_STAY_IN_SRAM
+	/* In the case we do not relocate u-boot code, we can't just
+	 * plonk an address from thin air, we use the one that has been
+	 * calculated with the other bits at the top of memory */
+	malloc_start = gd->malloc_pool_addr;
+#else
 #ifdef CONFIG_SYS_MALLOC_F_LEN
 	debug("Pre-reloc malloc() used %#lx bytes (%ld KB)\n", gd->malloc_ptr,
 	      gd->malloc_ptr / 1024);
 #endif
 	/* The malloc area is immediately below the monitor copy in DRAM */
 	malloc_start = gd->relocaddr - TOTAL_MALLOC_LEN;
+#endif
 	mem_malloc_init((ulong)map_sysmem(malloc_start, TOTAL_MALLOC_LEN),
 			TOTAL_MALLOC_LEN);
 	return 0;
diff --git a/common/bootm.c b/common/bootm.c
index b2c0912..8b4ccb9 100644
--- a/common/bootm.c
+++ b/common/bootm.c
@@ -60,8 +60,10 @@ static void boot_start_lmb(bootm_headers_t *images)
 
 	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
 
+#if !defined(CONFIG_SYS_STAY_IN_SRAM)
 	arch_lmb_reserve(&images->lmb);
 	board_lmb_reserve(&images->lmb);
+#endif
 }
 #else
 #define lmb_reserve(lmb, base, size)
diff --git a/common/image.c b/common/image.c
index 8c35327..c8f2de1 100644
--- a/common/image.c
+++ b/common/image.c
@@ -475,7 +475,7 @@ ulong getenv_bootm_low(void)
 
 #if defined(CONFIG_SYS_SDRAM_BASE)
 	return CONFIG_SYS_SDRAM_BASE;
-#elif defined(CONFIG_ARM)
+#elif defined(CONFIG_ARM) && defined(CONFIG_NR_DRAM_BANKS)
 	return gd->bd->bi_dram[0].start;
 #else
 	return 0;
diff --git a/common/spl/Kconfig b/common/spl/Kconfig
index cba51f5..dcc0e1d 100644
--- a/common/spl/Kconfig
+++ b/common/spl/Kconfig
@@ -342,6 +342,20 @@ config SPL_MTD_SUPPORT
 	  devices. See SPL_NAND_SUPPORT and SPL_ONENAND_SUPPORT for how
 	  to enable specific MTD drivers.
 
+config SPL_MULTIIMAGE
+	bool "Support loading multiple images on Renesas devices"
+	depends on SPL
+	help
+	  Enable loading multiple images from QSPI and/or NAND. It uses a PKG
+	  Table loaded from an offset of CONFIG_SYS_*_U_BOOT_OFFS from the boot
+	  media.
+	  The PKG Table specifies whether each package is a uImage, or a Renesas
+	  image wrapped in a BLp header. The BLp wrapped header can provide a
+	  signature of the payload, which can be verified by the BootROM. The PKG
+	  Table also indicates if the image contains code for the Cortex M3 core,
+	  and if so U-Boot/SPL will start the CM3 accordingly, or data, or code
+	  for the Cortex A7.
+
 config SPL_MUSB_NEW_SUPPORT
 	bool "Support new Mentor Graphics USB"
 	depends on SPL
diff --git a/common/spl/Makefile b/common/spl/Makefile
index ed02635..16f2cb0 100644
--- a/common/spl/Makefile
+++ b/common/spl/Makefile
@@ -26,4 +26,5 @@ obj-$(CONFIG_SPL_EXT_SUPPORT) += spl_ext.o
 obj-$(CONFIG_SPL_SATA_SUPPORT) += spl_sata.o
 obj-$(CONFIG_SPL_DFU_SUPPORT) += spl_dfu.o
 obj-$(CONFIG_SPL_SPI_LOAD) += spl_spi.o
+obj-$(CONFIG_SPL_MULTIIMAGE) += spl_multi_image.o
 endif
diff --git a/common/spl/crypto_api.h b/common/spl/crypto_api.h
new file mode 100644
index 0000000..546a5f2
--- /dev/null
+++ b/common/spl/crypto_api.h
@@ -0,0 +1,166 @@
+#ifndef _CRYPTOTYPES_H_INCLUDED_
+#define _CRYPTOTYPES_H_INCLUDED_
+#include "cryptotypes.h"
+
+/* The address of the Crypto API structure */
+#define CRYPTO_API_ADDRESS (0x00000060)
+
+/* API version MMMM.mmmm v1.04 */
+#define CRYPTO_API_VERSION (0x00010004)
+
+typedef enum {
+	IMAGE_SOURCE_SERIAL_FLASH,  /* 2nd stage Bootloader to be loaded from QSPI serial flash */
+	IMAGE_SOURCE_NAND_FLASH,    /* 2nd stage Bootloader to be loaded from NAND flash */
+	IMAGE_SOURCE_USB,           /* 2nd stage Bootloader to be loaded from USB */
+	IMAGE_SOURCE_NONE
+} IMAGE_SOURCE_TYPE_E;
+
+/* Example of API usage:
+ *
+ *      #include "crypto_api.h"
+ *
+ *      boot_rom_api_t* pAPI = (boot_rom_api_t*)CRYPTO_API_ADDRESS;
+ *
+ *      if ( ESUCCESS != pAPI->crypto_init() ||
+ *              ECDSA_VERIFY_STATUS_VERIFIED != pAPI->ecdsa_verify(pBLp_Header,
+ *                                                            pPayload_Data,
+ *                                                            Execution_offset,
+ *                                                            pStorageArea,
+ *                                                            pHash)}
+ *      {
+ *              SignatureVerifyFailed_handler();
+ *      }
+ */
+
+/* Structure for accessing the Crypto API:
+ * CRYPTO_API_ADDRESS + 0x00: CRYPTO_API_VERSION
+ * CRYPTO_API_ADDRESS + 0x04: Address of crypto_init function
+ * CRYPTO_API_ADDRESS + 0x08: Address of ecdsa_verify function
+ * CRYPTO_API_ADDRESS + 0x0c: Address of read_security_state function
+ * CRYPTO_API_ADDRESS + 0x10: Indicator of Boot source (NAND, QSPI or USB)
+ * CRYPTO_API_ADDRESS + 0x14: Index of used Image
+ * CRYPTO_API_ADDRESS + 0x18: Index of used Header
+ * CRYPTO_API_ADDRESS + 0x1c: ROM address of start of load data
+ * CRYPTO_API_ADDRESS + 0x20: ROM address of end of load data
+ * CRYPTO_API_ADDRESS + 0x24: RAM address of start of .data section
+ * CRYPTO_API_ADDRESS + 0x28: RAM address of end of .data section
+ * CRYPTO_API_ADDRESS + 0x2c: RAM address of start of .bss section
+ * CRYPTO_API_ADDRESS + 0x30: RAM address of end of .bss section
+ * CRYPTO_API_ADDRESS + 0x34: ROM address of start of crypto library
+ * CRYPTO_API_ADDRESS + 0x38: ROM address of end of crypto library
+ * CRYPTO_API_ADDRESS + 0x3c: RAM address of the start of the stack
+ */
+typedef struct boot_rom_api_s {
+	/* Crypto API version */
+	uint32_t APIversion;
+
+	/* Initialise the crypto block
+	 * Returns 0 for success.
+	 */
+	/**************************************************************************
+	 *
+	 *  Function:       crypto_init
+	 *
+	 *  Return value:   (uint32_t type)
+	 *                                      ESUCCESS (0) for success,
+	 *                                      or non-zero error code for failure
+	 *************************************************************************/
+	uint32_t (*crypto_init)(void);
+
+	/**************************************************************************
+	 *
+	 *  Function:       ecdsa_verify
+	 *
+	 *  Return value:   (ecdsa_verify_return_t type)
+	 *                  ECDSA_VERIFY_STATUS_VERIFIED (ESUCCESS, 0) for success,
+	 *                  or non-zero error code for failure
+	 *
+	 *  Parameters:     pBLp_Header         Pointer to the SPKG Header
+	 *                                      which cannot reside at address 0
+	 *                  pPayload_Data       Pointer to the payload data. This
+	 *                                      will be 264 bytes offset from the
+	 *                                      BLp Header if they are contiguous.
+	 *                  Execution_offset    Expected execution offset, to be
+	 *                                      checked against the attribute
+	 *                                      in the BLp Header.
+	 *                  pStorageArea        Pointer to a 2KB RAM buffer for use
+	 *                                      in signature verification.
+	 *                  pKeyHash            Pointer to the hash of the public
+	 *                                      key.
+	 *
+	 *  Description:    Publicly exposed function to verify the signature of a
+	 *                  BLp image.
+	 *                  The hash of the image is calculated and verified
+	 *                  against the signature contained in the header, and the
+	 *                  key hash is calculated and compared to the passed in
+	 *                  value. Additionally, the execution offset in the BLp
+	 *                  header is compared to the passed in value.
+	 *************************************************************************/
+	ecdsa_verify_return_t (*ecdsa_verify)(
+			const BLpHeader_t * const pBLp_Header,
+			const uint32_t * const pPayload_Data,
+			const uint32_t Execution_offset,
+			SB_StorageArea_t *pStorageArea,
+			const KeyHash_t * const pHash);
+
+	/**************************************************************************
+	 *
+	 *  Function:       read_security_state
+	 *
+	 *  Return value:   bit 0  indicates that secure boot is required
+	 *                  bit 1  indicates that crypto hardware is disabled
+	 *
+	 *                  0x00    Does not require secure boot,
+	 *                          crypto enabled.
+	 *                  0x01    Requires secure boot,
+	 *                          crypto enabled
+	 *                  0x02    Does not require secure boot,
+	 *                          crypto disabled
+	 *                  0x03    Requires secure boot,
+	 *                          but crypto disabled
+	 *
+	 *  Parameters:     none
+	 *  Description:    Reads the state of the security and crypto bits
+	 *************************************************************************/
+	uint32_t (*read_security_state)(void);
+
+	/* Boot Type:
+	 * The Boot ROM Code will populate this with a value
+	 * to indicate the boot type */
+	IMAGE_SOURCE_TYPE_E *pBoot_Type;
+
+	/* Index of found image (if applicable) */
+	uint32_t *pImageIndex;
+
+	/* SPKG Header index used */
+	uint32_t *pHeaderIndex;
+
+	/* __load_data_start__ */
+	void *pload_data_start;
+
+	/* __load_data_end__ */
+	void *pload_data_end;
+
+	/* __data_start__ */
+	void *pdata_start;
+
+	/* __data_end__ */
+	void *pdata_end;
+
+	/* __bss_start__ */
+	void *pbss_start;
+
+	/* __bss_end__ */
+	void *pbss_end;
+
+	/* Crypto library start */
+	void *pcrypto_start;
+
+	/* Crypto library end */
+	void *pcrypto_end;
+
+	/* Stack Start */
+	void *pstack_start;
+
+} boot_rom_api_t;
+#endif /* _CRYPTOTYPES_H_INCLUDED_ */
diff --git a/common/spl/cryptotypes.h b/common/spl/cryptotypes.h
new file mode 100644
index 0000000..283678d
--- /dev/null
+++ b/common/spl/cryptotypes.h
@@ -0,0 +1,77 @@
+/*
+ * cryptotypes.h
+ *
+ *  Created on: 5 Feb 2015
+ *	  Author: goveyd
+ */
+
+#ifndef CRYPTOTYPES_H_
+#define CRYPTOTYPES_H_
+
+/******************************************************************************
+ * Includes
+ ******************************************************************************/
+/******************************************************************************
+ * Defines and Typedefs
+ *********************************************************************************/
+
+/* ecdsa_verify error codes */
+typedef enum {
+	ECDSA_VERIFY_STATUS_VERIFIED = 0,
+} ecdsa_verify_return_t;
+
+/* BLp Header format structure */
+typedef struct {
+	uint32_t Type; /** Type. */
+	uint32_t PubKeyType; /** Type of public key */
+
+	/** Signature. */
+	uint8_t r[32]; /** r. */
+	uint8_t s[32]; /** s. */
+
+	/** Public key (if included in image). */
+	uint8_t Qx[32]; /** Qx. */
+	uint8_t Qy[32]; /** Qy. */
+
+	uint32_t EncryptionKey[10]; /** Key. */
+	uint32_t EncryptionIV[4];   /** IV. */
+	uint32_t ImageLen;          /** Image length. */
+	/** Image attributes. */
+	uint32_t Header_version_attribute_type_ID;
+	uint32_t Header_version_attribute_value;
+	uint32_t Custom_attribute_Load_Address_type_ID;
+	/* Big Endian Custom_attribute_Load_Address_value needs Endian swap */
+	uint32_t Custom_attribute_Load_Address_value_Big_Endian;
+	uint32_t Custom_attribute_Execution_Offset_type_ID;
+	/* Big Endian Custom_attribute_Execution_Offset_value needs Endian swap */
+	uint32_t Custom_attribute_Execution_Offset_value_Big_Endian;
+	uint32_t Unused_attribute3_type_ID;
+	uint32_t Unused_attribute3_value;
+	uint32_t Unused_attribute4_type_ID;
+	uint32_t Unused_attribute4_value;
+	uint32_t Unused_attribute5_type_ID;
+	uint32_t Unused_attribute5_value;
+	uint32_t Unused_attribute6_type_ID;
+	uint32_t Unused_attribute6_value;
+	uint32_t Unused_attribute7_type_ID;
+	uint32_t Unused_attribute7_value;
+
+	/** Certificate count. */
+	uint32_t CertificateCount;
+} BLpHeader_t;
+
+typedef struct {
+	union {
+		uint32_t data_32_bitAccess[512]; /** For Alignment and 32 bit access. */
+		uint8_t data_8_bitAccess[2048];  /** Size. */
+	} Union;
+} SB_StorageArea_t;
+
+typedef struct {
+	union {
+		uint32_t KeyHash_32_bitAccess[8]; /** For Alignment and 32 bit access. */
+		uint8_t KeyHash_8_bitAccess[32];  /** Size. */
+	} Union;
+} KeyHash_t;
+
+#endif /* CRYPTOTYPES_H_ */
diff --git a/common/spl/pkgt_table.h b/common/spl/pkgt_table.h
new file mode 100644
index 0000000..f90ec76
--- /dev/null
+++ b/common/spl/pkgt_table.h
@@ -0,0 +1,93 @@
+/*
+ * Renesas RZ/N1 Linux tools: Package Table format
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier:	BSD-2-Clause
+ */
+
+#ifndef _PKGT_TABLE_H_
+#define _PKGT_TABLE_H_
+
+/*
+ * The package table data structure is what tells the SPL bootloader to load
+ * bits from the QSPI and NAND flash. It is made to be able to load uImage
+ * files, or the Renesas specific signed package formats.
+ * The table itself is made to have built in redundancy, so it can be read
+ * from the NAND with bit errors, due to NAND rot.
+ */
+#define PKGT_MAX_TBL_ENTRIES	16	/* Must be power of 2 */
+#define PKGT_REDUNDANCY_COUNT	128
+/* "PKGT" */
+#define PKGT_MAGIC 		(('P'<<0)|('K'<<8)|('G'<<16)|('T'<<24))
+
+enum {
+	PKGT_TYPE_UIMAGE = 0,	/* uImage */
+	PKGT_TYPE_RPKG 	= 1,	/* Renesas RAW signed binary package RPKG */
+	PKGT_TYPE_SPKG 	= 2,	/* Renesas ROM Compatible Signed SPKG */
+	PKGT_TYPE_RAW	= 3,	/* No headers (Offset is an address) */
+};
+enum {
+	PKGT_CORE_CA70	= 0,	/* Cortex A7 - 1st core */
+	PKGT_CORE_CA71	= 1,	/* Cortex A7 - 2nd core (currently unused) */
+	PKGT_CORE_CM3	= 2,	/* Cortex M3 */
+};
+enum {
+	PKGT_KIND_CODE	= 0,	/* Code for a core */
+	PKGT_KIND_DTB	= 1,	/* Device tree blob -- pass as parameter to core X */
+	PKGT_KIND_DATA	= 3,	/* Data */
+};
+enum {
+	PKGT_SRC_SAME	= 0,	/* Same media as the PKGT table */
+	PKGT_SRC_QSPI	= 1,	/* Offset is in QSPI */
+	PKGT_SRC_NAND	= 2,	/* Offset is in NAND */
+};
+
+/* bit positions in pkg_entry->pkg */
+enum {
+	PKG_TYPE_BIT	= 0,
+	PKG_CORE_BIT	= 4,
+	PKG_KIND_BIT	= 8,
+	PKG_SRC_BIT	= 12,
+	PKG_BACKUP_BIT	= 16,	/* Mark this entry has an alternative */
+	PKG_NONSEC_BIT	= 17,	/* Start code in NONSEC mode */
+	PKG_HYP_BIT	= 18,	/* Start code in HYP(from NONSEC) mode */
+	PKG_NOCRC_BIT	= 19,	/* Skip CRC (if on QSPI) */
+	PKG_INITRAMFS_BIT	= 20, /* Data package is linux initramfs */
+	PKG_ALT_BIT	= 21, 	/* Code is alternative bootloader */
+	/* Rest of the bits are free */
+};
+
+/* bit positions in pkg_table->pkgt */
+enum {
+	PKGT_COUNT_BIT	= 0,
+};
+
+#define PKG_TYPE(e) (((e)->pkg >> PKG_TYPE_BIT) & 0xf)
+#define PKG_CORE(e) (((e)->pkg >> PKG_CORE_BIT) & 0xf)
+#define PKG_KIND(e) (((e)->pkg >> PKG_KIND_BIT) & 0xf)
+#define PKG_SRC(e) (((e)->pkg >> PKG_SRC_BIT) & 0xf)
+#define PKG_SET_SRC(e, s) (e)->pkg = ((e)->pkg & ~(0xf << PKG_SRC_BIT)) | \
+				((s & 0xf) << PKG_SRC_BIT)
+#define PKG_IS_BACKUP(e) ((e)->pkg & (1 << PKG_BACKUP_BIT))
+#define PKG_IS_HYP(e) ((e)->pkg & (1 << PKG_HYP_BIT))
+/* HYP implies NONSEC */
+#define PKG_IS_NONSEC(e) (PKG_IS_HYP(e) || ((e)->pkg & (1 << PKG_NONSEC_BIT)))
+#define PKG_IS_NOCRC(e) ((e)->pkg & (1 << PKG_NOCRC_BIT))
+#define PKG_IS_INITRAMFS(e) ((e)->pkg & (1 << PKG_INITRAMFS_BIT))
+#define PKG_IS_ALT(e) ((e)->pkg & (1 << PKG_ALT_BIT))
+
+struct pkg_entry {
+	uint32_t pkg;		/* Type, Core, Kind, Src + Flags */
+	uint32_t offset;	/* offset into the current media for the image */
+} __attribute__((packed));
+
+struct pkg_table {
+	uint32_t magic;		/* "PKGT" in big endian */
+	uint32_t pkgt;		/* number of pkg_table entries, etc */
+	uint32_t crc;		/* crc of nr_entries entries following */
+	uint32_t reserved;	/* reserved for future use */
+	struct pkg_entry entries[PKGT_MAX_TBL_ENTRIES];
+} __attribute__((packed));
+
+#endif
diff --git a/common/spl/spkg_header.h b/common/spl/spkg_header.h
new file mode 100644
index 0000000..5730ab5
--- /dev/null
+++ b/common/spl/spkg_header.h
@@ -0,0 +1,50 @@
+/*
+ * Renesas RZ/N1 Linux tools: Package Table format
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier:	BSD-2-Clause
+ */
+
+#ifndef _SKGT_HEADER_H_
+#define _SKGT_HEADER_H_
+
+#define SPKG_HEADER_SIGNATURE (('R'<<0)|('Z'<<8)|('N'<<16)|('1'<<24))
+#define SPKG_HEADER_COUNT	8
+#define SPKG_BLP_SIZE		264
+
+#define SPKG_HEADER_SIZE	24
+#define SPKG_HEADER_SIZE_ALL	(SPKG_HEADER_SIZE * SPKG_HEADER_COUNT)
+#define SPKG_HEADER_CRC_SIZE	4
+
+/* Index into SPKG */
+#define INDEX_BLP_START		SPKG_HEADER_SIZE_ALL
+#define INDEX_IMAGE_START	(INDEX_BLP_START + SPKG_BLP_SIZE)
+
+/* Flags, not supported by ROM code, only used for U-Boot SPL */
+enum {
+	SPKG_CODE_NONSEC_BIT = 0,
+	SPKG_CODE_HYP_BIT,
+};
+
+/* SPKG header */
+struct spkg_hdr {
+	uint32_t 	signature;
+	uint8_t		version;
+	uint8_t		ecc;
+	uint8_t 	ecc_scheme;
+	uint8_t 	ecc_bytes;
+	uint32_t 	payload_length; /* only HIGHER 24 bits */
+	uint32_t 	load_address;
+	uint32_t	execution_offset;
+	uint32_t	crc; /* of this header */
+} __attribute__((packed));
+
+struct spkg_file {
+	struct spkg_hdr		header[SPKG_HEADER_COUNT];
+	uint8_t			blp[SPKG_BLP_SIZE];
+	uint8_t			data[0];
+	/* then the CRC */
+} __attribute__((packed));
+
+#endif
diff --git a/common/spl/spl.c b/common/spl/spl.c
index f7df834..6ae73cf 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -163,6 +163,11 @@ __weak void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
 {
 	typedef void __noreturn (*image_entry_noargs_t)(void);
 
+	if (spl_image->entry_point < spl_image->load_addr ||
+		spl_image->entry_point > spl_image->load_addr + spl_image->size) {
+		spl_image->entry_point = spl_image->load_addr;
+		debug("fixing entry point!: 0x%X\n", spl_image->entry_point);
+	}
 	image_entry_noargs_t image_entry =
 		(image_entry_noargs_t)(unsigned long)spl_image->entry_point;
 
@@ -170,6 +175,8 @@ __weak void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
 	image_entry();
 }
 
+#ifndef CONFIG_SPL_MULTIIMAGE
+
 #ifndef CONFIG_SPL_LOAD_FIT_ADDRESS
 # define CONFIG_SPL_LOAD_FIT_ADDRESS	0
 #endif
@@ -227,12 +234,14 @@ SPL_LOAD_IMAGE_METHOD("RAM", 0, BOOT_DEVICE_RAM, spl_ram_load_image);
 SPL_LOAD_IMAGE_METHOD("USB DFU", 0, BOOT_DEVICE_DFU, spl_ram_load_image);
 #endif
 #endif
+#endif /* CONFIG_SPL_MULTIIMAGE */
 
 int spl_init(void)
 {
 	int ret;
 
 	debug("spl_init()\n");
+#if !defined(CONFIG_SYS_SPL_MALLOC_START) || !defined(CONFIG_SYS_SPL_MALLOC_SIZE)
 #if defined(CONFIG_SYS_MALLOC_F_LEN)
 #ifdef CONFIG_MALLOC_F_ADDR
 	gd->malloc_base = CONFIG_MALLOC_F_ADDR;
@@ -240,6 +249,7 @@ int spl_init(void)
 	gd->malloc_limit = CONFIG_SYS_MALLOC_F_LEN;
 	gd->malloc_ptr = 0;
 #endif
+#endif
 	if (CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)) {
 		ret = fdtdec_setup();
 		if (ret) {
@@ -260,6 +270,7 @@ int spl_init(void)
 	return 0;
 }
 
+#ifndef CONFIG_SPL_MULTIIMAGE
 #ifndef BOOT_DEVICE_NONE
 #define BOOT_DEVICE_NONE 0xdeadbeef
 #endif
@@ -326,9 +337,11 @@ static int boot_from_devices(struct spl_image_info *spl_image,
 
 	return -ENODEV;
 }
+#endif
 
 void board_init_r(gd_t *dummy1, ulong dummy2)
 {
+#ifndef CONFIG_SPL_MULTIIMAGE
 	u32 spl_boot_list[] = {
 		BOOT_DEVICE_NONE,
 		BOOT_DEVICE_NONE,
@@ -337,12 +350,16 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 		BOOT_DEVICE_NONE,
 	};
 	struct spl_image_info spl_image;
+#endif
 
 	debug(">>spl:board_init_r()\n");
 
 #if defined(CONFIG_SYS_SPL_MALLOC_START)
 	mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START,
 			CONFIG_SYS_SPL_MALLOC_SIZE);
+	gd->malloc_base = CONFIG_SYS_SPL_MALLOC_START;
+	gd->malloc_limit = CONFIG_SYS_SPL_MALLOC_SIZE;
+	gd->malloc_ptr = 0;
 	gd->flags |= GD_FLG_FULL_MALLOC_INIT;
 #endif
 	if (!(gd->flags & GD_FLG_SPL_INIT)) {
@@ -361,6 +378,9 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 	spl_board_init();
 #endif
 
+#ifdef CONFIG_SPL_MULTIIMAGE
+	spl_load_multi_images();
+#else /* CONFIG_SPL_MULTIIMAGE */
 	memset(&spl_image, '\0', sizeof(spl_image));
 	board_boot_order(spl_boot_list);
 
@@ -374,7 +394,7 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 	case IH_OS_U_BOOT:
 		debug("Jumping to U-Boot\n");
 		break;
-#ifdef CONFIG_SPL_OS_BOOT
+#if defined(CONFIG_SPL_OS_BOOT) && defined(CONFIG_SYS_SPL_ARGS_ADDR)
 	case IH_OS_LINUX:
 		debug("Jumping to Linux\n");
 		spl_board_prepare_for_linux();
@@ -392,6 +412,7 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 	debug("loaded - jumping to U-Boot...");
 	spl_board_prepare_for_boot();
 	jump_to_image_no_args(&spl_image);
+#endif /* CONFIG_SPL_MULTIIMAGE */
 }
 
 /*
diff --git a/common/spl/spl_multi_image.c b/common/spl/spl_multi_image.c
new file mode 100644
index 0000000..79d7279
--- /dev/null
+++ b/common/spl/spl_multi_image.c
@@ -0,0 +1,926 @@
+/*
+ * SPL: Load multiple images.
+ *
+ * This code reads a Package Table from the boot media, NAND or QSPI, at an
+ * offset defined by CONFIG_SYS_NAND_U_BOOT_OFFS or CONFIG_SYS_SPI_U_BOOT_OFFS
+ * respectively. The Package Table provides information about the list of
+ * images to load. These images can be either uImages or Renesas packages.
+ *
+ * Renesas packages use the BLP header (see BLpHeader_t) that provides
+ * information on the size of the payload, the load address, execution address,
+ * the public key used to sign the image, and the signature itself.
+ * U-Boot/SPL includes a hash of the public key which is used to verify that
+ * the public key in the BLP header is correct. This hash is defined using the
+ * RZN1_SPL_RPKG_HASH symbol.
+ *
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/gic.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <nand.h>
+#include <spl.h>
+#include <spi_flash.h>
+#include "crypto_api.h"
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-sysctrl.h"
+
+#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
+#include <asm/armv7.h>
+#include <asm/secure.h>
+#endif
+#if defined(CONFIG_SPL_ENV_SUPPORT)
+#include <environment.h>
+#endif
+
+#include "pkgt_table.h"
+#include "spkg_header.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define sysctrl_readl(addr) \
+	readl(RZN1_SYSTEM_CTRL_BASE + addr)
+#define sysctrl_writel(val, addr) \
+	writel(val, RZN1_SYSTEM_CTRL_BASE + addr)
+
+u8 default_load_source;
+#if defined(CONFIG_SPL_SPI_LOAD)
+struct spi_flash *flash;
+#endif
+#if defined(CONFIG_SPL_NAND_LOAD)
+/*
+ * When reading data from a NAND Flash device, the minimum we can read is a
+ * page. SPL will be able to load multiple images to arbitrary locations, so
+ * we cannot make any assumptions about what areas are available to use.
+ * Therefore, we need storage inside the SPL image.
+ */
+static u32 nand_page[8192/4];
+static struct image_header *header = (struct image_header *)nand_page;
+#endif
+
+#ifndef IH_MAGIC
+#define IH_MAGIC	0x27051956	/* Image Magic Number		*/
+#endif
+
+struct spl_image_info spl_image;
+
+struct loaded_data_t {
+	struct pkg_entry *part;
+	u32 load_addr;
+	u32 entry_point;
+	u32 size, mapped;
+};
+
+/* indexed with PKGT_CORE_CA70/CA71/CM3 and PKGT_KIND_CODE/DTB/DATA */
+static struct loaded_data_t loaded_core[3][3];
+
+/* Hash of the public key that was used to sign the RPKG */
+static const uint8_t rzn1_rpkg_public_key_hash[] = { RZN1_SPL_RPKG_HASH };
+
+/* if NAND exists, we can use the static page they use to load pages */
+#if defined(CONFIG_SPL_NAND_LOAD)
+/* Re-use intermediate storage for NAND page */
+extern u32 nand_page[];
+static struct spkg_file *spkg = (struct spkg_file *)nand_page;
+#else
+static struct spkg_file spkg_header_struct;
+static struct spkg_file *spkg = &spkg_header_struct;
+#endif
+
+static int addr_ok(
+	uint32_t addr, uint32_t low, uint32_t limit)
+{
+	if ((addr < low) || (addr >= (low + limit)))
+		return 0;
+
+	return 1;
+}
+
+/* Check that the address range is _completely_ inside another range */
+static int range_ok(
+	uint32_t addr, uint32_t size, uint32_t low, uint32_t limit)
+{
+	if (addr_ok(addr, low, limit) && addr_ok(addr + size - 1, low, limit))
+		return 1;
+
+	return 0;
+}
+
+/* Check that the address range is _partially_ inside another range */
+static int range_conflicts(
+	uint32_t addr, uint32_t size, uint32_t low, uint32_t limit)
+{
+	if (addr_ok(addr, low, limit) || addr_ok(addr + size - 1, low, limit))
+		return 1;
+
+	return 0;
+}
+
+
+static __noreturn void stop(void)
+{
+	hang();
+	/* Just in case hang() doesn't work */
+	while (1)
+		;
+}
+
+static const char * const pkg_type[] = { "uImage", "RPKG", "SPKG" };
+static const char * const pkg_core[] = { "CA7 #0", "CA7 #1", "CM3" };
+static const char * const pkg_kind[] = { "code", "dtb", "data" };
+static const char * const pkg_src[] = { "(same)", "QSPI", "NAND" };
+
+static void pkgt_msg(struct pkg_entry *entry, char *msg, int details)
+{
+	printf("U-Boot SPL: Error with PKG Table entry (%s).\n", msg);
+	printf("    PKG media offset 0x%08x ", entry->offset);
+
+	printf("%s %s %s in %s\n",
+	       pkg_core[PKG_CORE(entry)], pkg_kind[PKG_KIND(entry)],
+		pkg_type[PKG_TYPE(entry)], pkg_src[PKG_SRC(entry)]);
+	if (details)
+		printf("    PKG load address 0x%08x, size 0x%08x\n",
+		       spl_image.load_addr, spl_image.size);
+}
+
+/* Depending on OTP values in the device, the Cortex M3 will either start
+ * running code from QSPI or from the start of SRAM.
+ */
+static int cm3_runs_from_qspi(void)
+{
+	if (sysctrl_readl(RZN1_SYSCTRL_REG_OPMODE) & (1 << 4))
+		return 0;
+
+	return 1;
+}
+
+/* Align on the next megabyte boundary */
+#define MAP_ALIGNEMNT	(16*1024*1024)
+
+/* if the code for a core is loaded, add size (and alignemnt, and a bit extra)
+ * to it's size, for relocating DTB, initramfs etc */
+static uint32_t reserve_core_range(int core, uint32_t size)
+{
+	struct loaded_data_t *code =
+		&loaded_core[core][PKGT_KIND_CODE];
+	/* round load address to 4K */
+	uint32_t dest = (code->load_addr + code->size + code->mapped + (MAP_ALIGNEMNT-1)) &
+				~(MAP_ALIGNEMNT-1);
+
+	/* add at least 4KB, and round */
+	size = (size + 8192) & ~4095;
+
+	if (!code->load_addr)
+		return 0;
+
+	debug("%s core %d reserve %d at %08x\n", __func__, core, size, dest);
+
+	code->mapped += size;
+
+	return dest;
+}
+
+/* Load data from the flash specified by the table entry */
+static int source_load(
+	struct pkg_entry *entry,
+	uint32_t offset,
+	size_t size,
+	void *dst)
+{
+	int ret = -1;
+
+	switch (PKG_SRC(entry)) {
+#if defined(CONFIG_SPL_SPI_LOAD)
+	case PKGT_SRC_QSPI:
+		if (!flash)
+			flash = spl_spi_probe();
+		ret = spi_flash_read(flash, offset, size, dst);
+		break;
+#endif
+#if defined(CONFIG_SPL_NAND_LOAD)
+	case PKGT_SRC_NAND:
+		ret = nand_spl_load_image(offset, size, dst);
+		break;
+#endif
+	}
+	return ret;
+}
+
+/* Use the BootROM code to check the signature */
+static int rpkg_verify_sig(
+	BLpHeader_t *pBLp_Header, void *pPayload, uint32_t exec_offset)
+{
+	boot_rom_api_t *pAPI = (boot_rom_api_t *)CRYPTO_API_ADDRESS;
+	SB_StorageArea_t StorageArea;
+	uint32_t ret;
+
+	debug("%s: pBLp_Header %p, pPayload %p, exec_offset %d\n", __func__,
+	      pBLp_Header, pPayload, exec_offset);
+
+	ret = pAPI->crypto_init();
+	if (ret != 0) {
+		printf("%s: failed to initialise!\n", __func__);
+		return -1;
+	}
+	debug("%s: Call to crypto_init completed!\n", __func__);
+
+	ret = pAPI->ecdsa_verify(pBLp_Header,
+			pPayload,
+			exec_offset,
+			&StorageArea,
+			(void *)&rzn1_rpkg_public_key_hash);
+	if (ret != ECDSA_VERIFY_STATUS_VERIFIED) {
+		printf("%s: failed to verify image (%d)!\n", __func__, ret);
+		return -2;
+	}
+	debug("%s: verified!\n", __func__);
+
+	return 0;
+}
+
+/* Returns ZERO if range is valid */
+static int validate_load_range(struct loaded_data_t *info)
+{
+	int i,j;
+	int valid_addr = 0;
+	/*
+	 * Perform some basic checks on the address range.
+	 * This is not exhaustive as the boot allows Cortex M3 code to be loaded
+	 * and started before loading other images. The Cortex M3 code could do
+	 * pretty much anything...
+	 */
+
+	/* Check the image destination is a valid memory region */
+#if defined(CONFIG_SYS_SDRAM_BASE)
+	valid_addr |= range_ok(info->load_addr, info->size,
+				CONFIG_SYS_SDRAM_BASE, CONFIG_SYS_SDRAM_SIZE);
+#endif
+	valid_addr |= range_ok(info->load_addr, info->size,
+				RZN1_SRAM_ID_BASE, RZN1_SRAM_ID_SIZE);
+	valid_addr |= range_ok(info->load_addr, info->size,
+				RZN1_SRAM_SYS_BASE, RZN1_SRAM_SYS_SIZE);
+
+	/* Check the image destination isn't overwriting us */
+	valid_addr &= !range_conflicts(info->load_addr, info->size,
+				CONFIG_SPL_TEXT_BASE, CONFIG_SPL_MAX_FOOTPRINT);
+	valid_addr &= !range_conflicts(info->load_addr, info->size,
+				CONFIG_SYS_SPL_MALLOC_START, CONFIG_SYS_SPL_MALLOC_SIZE);
+	valid_addr &= !range_conflicts(info->load_addr, info->size,
+				CONFIG_SPL_STACK, CONFIG_SPL_STACK + gd->start_addr_sp);
+	/*
+	 * Check the image destination is still available.
+	 * We try to prevent someone overwriting part of a signed image with
+	 * data from another signed image. Note that we can't check that the
+	 * code uses an area of memory that is in use by another image, nor
+	 * would we want to as it could be used for comms between processors.
+	 */
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			if ((info != &loaded_core[i][j]) && /* <- not us! */
+			    loaded_core[i][j].size) {
+				valid_addr &= !range_conflicts(
+						info->load_addr, info->size,
+						loaded_core[i][j].load_addr,
+						loaded_core[i][j].size);
+			}
+	return valid_addr ? 0 : -1;
+}
+
+static int parse_rpkg_header(BLpHeader_t *hdr, struct loaded_data_t *info)
+{
+	uint32_t tmp;
+
+	/* Check the ImageAttributes are what we expect */
+	tmp = __be32_to_cpu(hdr->Custom_attribute_Load_Address_type_ID);
+	if (tmp != 0x80000001) {
+		printf("%s: Bad BLP Load Address ID = 0x%x\n", __func__,
+		       hdr->Custom_attribute_Load_Address_type_ID);
+		return -1;
+	}
+	tmp = __be32_to_cpu(hdr->Custom_attribute_Execution_Offset_type_ID);
+	if (tmp != 0x80000002) {
+		printf("%s: Bad BLP Execution Offset ID = 0x%x\n", __func__,
+		       hdr->Custom_attribute_Execution_Offset_type_ID);
+		return -1;
+	}
+
+	info->load_addr = __be32_to_cpu(hdr->Custom_attribute_Load_Address_value_Big_Endian);
+	info->entry_point = info->load_addr +
+				__be32_to_cpu(hdr->Custom_attribute_Execution_Offset_value_Big_Endian);
+	info->size = __be32_to_cpu(hdr->ImageLen);
+	debug("%s: load addr 0x%x exec addr 0x%x size %d\n", __func__,
+	      info->load_addr, info->entry_point-info->load_addr, info->size);
+
+	return validate_load_range(info);
+}
+
+/* Passed an array of SPKG_HEADER_COUNT headers, return the first
+ * one that has a valid signature and CRC.
+ * Return NULL if none of them work out
+ */
+static struct spkg_hdr *locate_valid_spkg_header(struct spkg_hdr *h)
+{
+	int i;
+
+	for (i = 0; i < SPKG_HEADER_COUNT; i++, h++) {
+		if (h->signature == SPKG_HEADER_SIGNATURE &&
+		    crc32(0, (u8*)h, sizeof(*h)-sizeof(h->crc)) == h->crc) {
+			if (i)
+				debug("%s skipped %d invalid headers\n",
+				      __func__, i);
+			return h;
+		}
+	}
+	return NULL;
+}
+
+static int parse_spkg_header(struct spkg_hdr *h, struct loaded_data_t *info)
+{
+	h = locate_valid_spkg_header(h);
+
+	if (!h)
+		return -1;
+	info->load_addr = h->load_address;
+	info->entry_point = info->load_addr + h->execution_offset;
+	info->size = (h->payload_length >> 8) - SPKG_BLP_SIZE;
+
+	/* copy these flags bits to the package loader.
+	 * This is made so a signed package can force NONSEC/HYP and cannot
+	 * be overriden by just rewritting the unprotected table entry */
+	if (h->payload_length & (1 << SPKG_CODE_NONSEC_BIT))
+		info->part->pkg |= (1 << PKG_NONSEC_BIT);
+	if (h->payload_length & (1 << SPKG_CODE_HYP_BIT))
+		info->part->pkg |= (1 << PKG_HYP_BIT);
+
+	/* Initramfs/DTB with a zero load address means to load it just after
+	 * the code for that core, if it's available etc */
+	if ((PKG_IS_INITRAMFS(info->part) ||  PKG_KIND(info->part) == PKGT_KIND_DTB)
+			&& info->load_addr == 0) {
+		/* round */
+		uint32_t size = (info->size + 4095) & ~4095;
+
+		/* set our relocated address */
+		h->load_address = info->load_addr =
+			reserve_core_range(PKG_CORE(info->part), size);
+
+		/* not really needed as it's data, but adjust anyway */
+		info->entry_point += info->load_addr;
+	}
+
+	debug("%s: load addr 0x%x, size %d, exec addr 0x%x\n", __func__,
+	      info->load_addr, info->size, info->entry_point-info->load_addr);
+
+	return validate_load_range(info);
+}
+
+static int load_spkg_header(struct pkg_entry *entry)
+{
+	return source_load(entry, entry->offset,
+				sizeof(*spkg), spkg);
+}
+static int load_spkg_payload(struct loaded_data_t *part)
+{
+	return source_load(part->part,
+			part->part->offset + sizeof(*spkg),
+			part->size,
+			(void *)part->load_addr);
+}
+static int load_rpkg_header(struct pkg_entry *entry)
+{
+	return source_load(entry, entry->offset,
+			sizeof(BLpHeader_t), spkg->blp);
+}
+static int load_rpkg_payload(struct loaded_data_t *part)
+{
+	return source_load(part->part,
+			part->part->offset + sizeof(BLpHeader_t),
+			part->size - sizeof(BLpHeader_t),
+			(void *)part->load_addr);
+}
+
+int __weak ft_board_setup(void *blob, bd_t *bd)
+{
+	return 0;
+}
+
+#ifdef CONFIG_ARMV7_NONSEC
+/* this is used by the secondary core bootstraper to know if it should
+ * kick off in HYP more or in plain NONSEC */
+extern int nonsec_and_hyp;
+#endif
+
+static void jump_to_image(
+	struct loaded_data_t *code,
+	struct loaded_data_t *dtb,
+	struct loaded_data_t *data)
+{
+	int valid_addr = 0;
+
+	/* Check the execution addr is a valid memory region */
+#if defined(CONFIG_SYS_SDRAM_BASE)
+	valid_addr |= addr_ok(code->entry_point, CONFIG_SYS_SDRAM_BASE, CONFIG_SYS_SDRAM_SIZE);
+#endif
+	valid_addr |= addr_ok(code->entry_point, RZN1_SRAM_ID_BASE, RZN1_SRAM_ID_SIZE);
+	valid_addr |= addr_ok(code->entry_point, RZN1_SRAM_SYS_BASE, RZN1_SRAM_SYS_SIZE);
+	/* It is also possible to start code straight from the QSPI mapping */
+	valid_addr |= addr_ok(code->entry_point, RZN1_V_QSPI_BASE, RZN1_V_QSPI_SIZE);
+
+	if (!valid_addr) {
+		printf("U-Boot SPL: Invalid CA7 entry point (%08x)!\n",
+		       code->entry_point);
+		return;
+	}
+
+	spl_image.entry_point = code->entry_point;
+	spl_image.size = code->size;
+
+	if (dtb && dtb->load_addr && fdt_check_header((void *)dtb->load_addr) == 0) {
+		void * dtb_mapped = (void*)dtb->load_addr;
+
+		debug("Original DTB is %d size for real\n",
+			fdt_totalsize(dtb_mapped));
+		if (dtb->size == 0)
+			dtb->size = fdt_totalsize(dtb_mapped);
+
+		/* if DTB is pointing to the QSPI mapping, it needs relocating */
+		if (addr_ok(dtb->load_addr, RZN1_V_QSPI_BASE, RZN1_V_QSPI_SIZE)) {
+			dtb_mapped = (void*)reserve_core_range(PKG_CORE(dtb->part),
+						dtb->size);
+		}
+		/* make sure we got a bit more room to do stuff in that block */
+		fdt_open_into((void*)dtb->load_addr, dtb_mapped,
+			      dtb->size + 4096);
+		dtb->load_addr = (uint32_t)dtb_mapped;
+
+		fdt_find_and_setprop(dtb_mapped,
+				     "/chosen", "rzn1,spl",
+				     &valid_addr, sizeof(valid_addr), 1);
+		if (PKG_IS_BACKUP(code->part)) {
+			fdt_find_and_setprop(dtb_mapped,
+					     "/chosen", "rzn1,backup",
+					     &valid_addr, sizeof(valid_addr), 1);
+		}
+		const char * boot_source = default_load_source == PKGT_SRC_QSPI ?
+					"qspi" : default_load_source == PKGT_SRC_NAND ?
+					"nand" : "unknown";
+		fdt_find_and_setprop(dtb_mapped,
+				     "/chosen/", "rzn1,boot-source",
+				     boot_source, strlen(boot_source) + 1, 1);
+		fdt_find_and_setprop(dtb_mapped,
+				     "/chosen", "rzn1,flash-offset",
+				     &code->part->offset,
+				     sizeof(code->part->offset), 1);
+#if defined(CONFIG_SYS_SDRAM_BASE)
+		fdt_fixup_memory(dtb_mapped,
+				 CONFIG_SYS_SDRAM_BASE, gd->ram_size);
+#endif
+
+		fdt_fixup_ethernet(dtb_mapped);
+
+		if (data && data->load_addr && PKG_IS_INITRAMFS(data->part)) {
+			fdt_initrd(dtb_mapped,
+				   data->load_addr, data->load_addr + data->size);
+		}
+	} else {
+		if (dtb && dtb->load_addr)
+			pkgt_msg(code->part, "Invalid DTB", 0);
+		dtb = NULL;
+	}
+
+	if (dtb)
+		debug("%s %08x(%08x)\n", __func__, code->entry_point, dtb->load_addr);
+
+	if (PKG_IS_NONSEC(code->part)) {
+#ifdef CONFIG_ARMV7_NONSEC
+		unsigned long machid = 0xffffffff;
+		unsigned long r2 = 0;
+
+		nonsec_and_hyp = !!PKG_IS_HYP(code->part);
+
+		/* if we also want hyp mode, add it to the device tree */
+		if (nonsec_and_hyp)
+			fdt_find_and_setprop((void *)dtb->load_addr,
+					     "/chosen", "rzn1,hyp",
+					     &nonsec_and_hyp, sizeof(nonsec_and_hyp), 1);
+		ft_board_setup((void *)dtb->load_addr, NULL);
+
+		/* Do not remove or move this line! */
+		cleanup_before_linux();
+
+		if (dtb)
+			r2 = dtb->load_addr;
+
+		if (armv7_init_nonsec() == 0) {
+			if (nonsec_and_hyp)
+				debug("entered HYP mode\n");
+			else
+				debug("entered non-secure state\n");
+#ifndef CONFIG_ARMV7_VIRT
+			/* Use a '1' we already have */
+			fdt_find_and_setprop((void *)dtb->load_addr,
+					     "/chosen", "rzn1,nonsec",
+					    &valid_addr, sizeof(valid_addr), 1);
+#endif
+
+			secure_ram_addr(_do_nonsec_entry)((void *)code->entry_point,
+							  0, machid, r2);
+		} else
+			pkgt_msg(code->part, "NONSEC switch failed", 0);
+#else
+		pkgt_msg(code->part, "NONSEC/HYP not compiled in", 0);
+#endif
+	}
+	jump_to_image_linux(&spl_image, (void *)dtb->load_addr);
+	/* Should not return! */
+}
+
+static int load_rpkg_from_header(
+	struct loaded_data_t *part, int verify)
+{
+	struct pkg_entry *entry = part->part;
+	void *blp_header = (void *)&spkg->blp;
+
+	/* Check the RPKG header */
+	if (parse_rpkg_header(blp_header, part)) {
+		pkgt_msg(entry, "Address/size is not allowed", 1);
+		return -3;
+	}
+
+	/* Check that CM3 images are at the correct place */
+	if (PKG_CORE(entry) == PKGT_CORE_CM3 &&
+	    (spl_image.load_addr != RZN1_SRAM_ID_BASE ||
+	     spl_image.entry_point != RZN1_SRAM_ID_BASE)) {
+		pkgt_msg(entry, "Invalid CM3 address", 1);
+		return -4;
+	}
+
+	/* Load the payload */
+	if (load_rpkg_payload(part)) {
+		pkgt_msg(entry, "I/O loading payload", 1);
+		return -5;
+	}
+
+	if (verify) {
+		/* Check the signature */
+		int ret = rpkg_verify_sig(blp_header,
+				      (void *)part->load_addr,
+				part->entry_point - part->load_addr);
+		if (ret) {
+			pkgt_msg(entry, "Verification failed", 1);
+			return -6;
+		}
+	}
+	return 0;
+}
+
+static int load_rpkg(struct loaded_data_t *part, int verify)
+{
+	struct pkg_entry *entry = part->part;
+
+	/* Check that the CM3 can run code */
+	if (PKG_CORE(entry) == PKGT_CORE_CM3 && cm3_runs_from_qspi()) {
+		pkgt_msg(entry, "CM3 is using QSPI", 0);
+		return -1;
+	}
+
+	/* Load the RPKG header */
+	if (load_rpkg_header(entry)) {
+		pkgt_msg(entry, "I/O loading header", 0);
+		return -2;
+	}
+
+	return load_rpkg_from_header(part, verify);
+}
+
+static int load_spkg(struct loaded_data_t *part, int verify)
+{
+	struct pkg_entry *entry = part->part;
+
+	/* Check that the CM3 can run code */
+	if (PKG_CORE(entry) == PKGT_CORE_CM3 && cm3_runs_from_qspi()) {
+		pkgt_msg(entry, "CM3 is using QSPI", 0);
+		return -1;
+	}
+	/* Load the SPKG header */
+	if (load_spkg_header(entry)) {
+		pkgt_msg(entry, "I/O loading SPKG header", 0);
+		return -2;
+	}
+	/* Check the SPKG header */
+	if (parse_spkg_header(spkg->header, part)) {
+		pkgt_msg(entry, "Invalid SPKG header", 1);
+		return -3;
+	}
+	/* Check that CM3 images are at the correct place */
+	if (PKG_CORE(entry) == PKGT_CORE_CM3 &&
+	    (part->load_addr != RZN1_SRAM_ID_BASE ||
+	     part->entry_point != RZN1_SRAM_ID_BASE)) {
+		pkgt_msg(entry, "Invalid CM3 address", 1);
+		return -4;
+	}
+	/* Load the payload */
+	if (load_spkg_payload(part)) {
+		pkgt_msg(entry, "I/O loading SPKG payload", 1);
+		return -5;
+	}
+	/* Verify payload's CRC, unless it's marked as OK */
+	if (!PKG_IS_NOCRC(entry)) {
+		u32 wanted, crc;
+
+		wanted = *((u32 *)(part->load_addr + part->size - sizeof(u32)));
+		/* The BLP is not necessary followed by the payload */
+		crc = crc32(0, spkg->blp, sizeof(spkg->blp));
+		crc = crc32(crc, (void *)part->load_addr,
+			part->size - sizeof(u32));
+		if (crc != wanted) {
+			pkgt_msg(entry, "Invalid SPKG payload CRC", 1);
+			return -6;
+		}
+	}
+	return 0;
+}
+
+static int load_rpkgt_entry(
+	struct pkg_table *table,
+	struct pkg_entry *entry,
+	int verify, int alt_loading)
+{
+	struct loaded_data_t *part = NULL;
+	uint8_t type = PKG_TYPE(entry);
+	uint8_t core = PKG_CORE(entry);
+	uint8_t kind = PKG_KIND(entry);
+	uint8_t src = PKG_SRC(entry);
+	int ret = 0;
+
+	if (core > PKGT_CORE_CM3) {
+		pkgt_msg(entry, "Unsupported cpu index", 0);
+		return -1;
+	}
+	if (kind > PKGT_KIND_DATA) {
+		pkgt_msg(entry, "Unsupported package kind", 0);
+		return -2;
+	}
+	if (src == PKGT_SRC_SAME)
+		PKG_SET_SRC(entry, default_load_source);
+
+	printf("SPL: %s %s %s in %s at 0x%x%s%s%s%s%s%s\n",
+		pkg_core[core], pkg_kind[kind],
+		pkg_type[type], pkg_src[src],
+		entry->offset,
+		PKG_IS_BACKUP(entry) ? " Backup" : "",
+		PKG_IS_ALT(entry) ? " ALT" : "",
+		PKG_IS_NOCRC(entry) ? " NOCRC" : "",
+		PKG_IS_INITRAMFS(entry) ? " Initramfs" : "",
+		PKG_IS_NONSEC(entry) ? " NONSEC" : "",
+		PKG_IS_HYP(entry) ? "+HYP" : "");
+
+	part = &loaded_core[core][kind];
+	if (part->part && PKG_IS_BACKUP(entry)) {
+		/* This part was already loaded, and the one
+		 * we are looking at is a backup, so we can
+		 * safely skip it */
+		return 1;
+	}
+	if (!!alt_loading != !!PKG_IS_ALT(entry)) {
+		return 2;
+	}
+	if (part->load_addr) {
+		debug("part already loaded\n");
+		return 3;
+	}
+	part->part = entry;
+
+	if (type == PKGT_TYPE_UIMAGE) {
+		if (verify) {
+			pkgt_msg(entry, "Secure mode cannot load uImage", 0);
+			return -3;
+		}
+		switch (PKG_SRC(entry)) {
+		case PKGT_SRC_QSPI:
+#if defined(CONFIG_SPL_SPI_LOAD)
+			spl_spi_load_one_uimage(&spl_image, flash, entry->offset);
+#endif
+			break;
+		case PKGT_SRC_NAND:
+#if defined(CONFIG_SPL_NAND_LOAD)
+			spl_nand_load_element(&spl_image, entry->offset, header);
+#endif
+			break;
+		}
+		part->load_addr = spl_image.load_addr;
+		part->entry_point = spl_image.entry_point;
+		part->size = spl_image.size;
+	} else if (type == PKGT_TYPE_RPKG) {
+		ret = load_rpkg(part, verify);
+	} else if (type == PKGT_TYPE_SPKG) {
+		ret = load_spkg(part, verify);
+	} else if (type == PKGT_TYPE_RAW) {
+		part->load_addr = entry->offset;
+		part->entry_point = entry->offset;
+		part->size = 0;
+	} else {
+		pkgt_msg(entry, "Unsupported pkg type", 0);
+		ret = -1;
+	}
+	return ret;
+}
+
+int spl_start_uboot(void);
+
+void __noreturn spl_load_multi_images(void)
+{
+	struct pkg_table table_data;
+	struct pkg_table *table = &table_data;
+#if !defined(RZN1_SKIP_BOOTROM_CALLS)
+	boot_rom_api_t *pAPI = (boot_rom_api_t *)CRYPTO_API_ADDRESS;
+	uint32_t state;
+#endif
+	int verify = 0;
+	int i, nr_entries, retries_count = PKGT_REDUNDANCY_COUNT;
+	uint32_t table_offset = 0x10000;
+	int boot_device = spl_boot_device();
+	int alt_loading = 0;
+
+	memset(&spl_image, '\0', sizeof(spl_image));
+
+	/* Ethernet MACS will need the environment */
+#if defined(CONFIG_SPL_ENV_SUPPORT)
+	env_init();
+	env_relocate_spec();
+#endif
+
+#if !defined(RZN1_SKIP_BOOTROM_CALLS)
+	/*
+	 * Get the BootROM to tell us if it's possible to, and if we need to,
+	 * verify the signature of the images.
+	 */
+	state = pAPI->read_security_state();
+	if ((state & 0x1) && (state & 0x2)) {
+		printf("U-Boot SPL: Error: Requires secure boot, but not available\n");
+		stop();
+	}
+	if (state & 0x1) {
+		debug("%s: Secure boot required\n", __func__);
+		verify = 1;
+	}
+
+#if defined(RZN1_FORCE_VERIFY_USING_BOOTROM)
+	/* Force the BootROM to verify the image, used for testing */
+	verify = 1;
+#endif
+#endif
+
+	/* Read PKG Table from current media */
+	switch (boot_device) {
+#if defined(CONFIG_SPL_SPI_LOAD)
+	case BOOT_DEVICE_SPI:
+		default_load_source = PKGT_SRC_QSPI;
+		flash = spl_spi_probe();
+		table_offset = CONFIG_SYS_SPI_U_BOOT_OFFS;
+		debug("%s: QSPI boot %x\n", __func__, table_offset);
+		break;
+#endif
+#if defined(CONFIG_SPL_NAND_LOAD)
+	case BOOT_DEVICE_NAND:
+		default_load_source = PKGT_SRC_NAND;
+		table_offset = CONFIG_SYS_NAND_U_BOOT_OFFS;
+		debug("%s: NAND boot %x\n", __func__, table_offset);
+		break;
+#endif
+	default:
+		printf("U-Boot SPL: Error: Invalid boot source %d\n", boot_device);
+	}
+
+	debug("%s: %sBoot dev:%d load RPKG table at %x\n", __func__,
+		alt_loading ? "ALTERNATIVE " : "", boot_device,
+	      table_offset);
+
+	/* Now try to load a valid table header */
+	for (; retries_count;
+		retries_count--, table_offset += sizeof(struct pkg_table)) {
+		/* Read PKG Table from current media */
+		switch (boot_device) {
+#if defined(CONFIG_SPL_SPI_LOAD)
+		case BOOT_DEVICE_SPI:
+			default_load_source = PKGT_SRC_QSPI;
+			if (!flash)
+				flash = spl_spi_probe();
+			spi_flash_read(flash, table_offset,
+				       sizeof(struct pkg_table), (void *)table);
+			break;
+#endif
+#if defined(CONFIG_SPL_NAND_LOAD)
+		case BOOT_DEVICE_NAND:
+			default_load_source = PKGT_SRC_NAND;
+			nand_spl_load_image(table_offset,
+					    sizeof(struct pkg_table), (void *)nand_page);
+			memcpy(table, nand_page, sizeof(struct pkg_table));
+			break;
+#endif
+		}
+		if (!default_load_source)
+			debug("%s: No PKG Loading code! Config error.\n", __func__);
+
+		/*
+		 * If we don't need to verify the image signature and we don't have a
+		 * PKG Table, assume we are loading a uImage.
+		 */
+		if (!verify && table->magic != PKGT_MAGIC) {
+			if (be32_to_cpu(table->magic) == IH_MAGIC) {
+				debug("%s: No PKG Table, assuming uImage (%08x)\n", __func__,
+				      table->magic);
+				switch (default_load_source) {
+				case PKGT_SRC_QSPI:
+#if defined(CONFIG_SPL_SPI_LOAD)
+					spl_spi_load_one_uimage(&spl_image, flash, table_offset);
+#endif
+					break;
+				case PKGT_SRC_NAND:
+#if defined(CONFIG_SPL_NAND_LOAD)
+					spl_nand_load_element(&spl_image, table_offset, header);
+#endif
+					break;
+				}
+				jump_to_image_no_args(&spl_image);
+			}
+			/* not a uImage, try another copy of the header */
+			continue;
+		}
+
+		if (table->magic != PKGT_MAGIC) {
+			printf("U-Boot SPL: Error: PKG Table does not have correct ID!\n");
+			continue;
+		}
+
+		{	/* check CRC of the table */
+			uint32_t crc = table->crc;
+			table->crc = 0;
+			uint32_t wanted = crc32(0, (u8*)table, sizeof(*table));
+			if (wanted != crc) {
+			//	printf("U-Boot SPL: PKGT header has invalid CRC\n");
+				continue;
+			}
+		}
+
+		nr_entries = (table->pkgt >> PKGT_COUNT_BIT) & (PKGT_MAX_TBL_ENTRIES-1);
+		if (nr_entries == 0) {
+			printf("U-Boot SPL: Error: PKG Table does not have any entries!\n");
+			continue;
+		}
+
+		alt_loading = spl_start_uboot();
+		for (i = 0; i < nr_entries; i++) {
+			load_rpkgt_entry(table,
+					&table->entries[i], verify, alt_loading);
+		}
+		break;/* we handled a valid table already, bail */
+	}
+
+	if (retries_count == 0)
+		printf("U-Boot SPL: Unable to load a PKGT or uImage, hanging.\n");
+	else if (retries_count < PKGT_REDUNDANCY_COUNT)
+		printf("U-Boot SPL: Warning: Skipped %d PKGT header(s)\n",
+		       PKGT_REDUNDANCY_COUNT - retries_count);
+
+	/* Start the Cortex M3 running, if the device is set to run from SRAM, it's
+	 * entry point is always the start of SRAM at 0x04000000. Note that the CM3
+	 * actually starts execution at address 0x0, but this is mirrored to the
+	 * start of SRAM.
+	 */
+	if (loaded_core[PKGT_CORE_CM3][PKGT_KIND_CODE].load_addr) {
+		debug("%s: Starting the CM3\n", __func__);
+		sysctrl_writel(0x3, RZN1_SYSCTRL_REG_PWRCTRL_CM3);
+	}
+
+	/* Second CA7 can be started independantly to CA7#0 */
+	if (loaded_core[PKGT_CORE_CA71][PKGT_KIND_CODE].load_addr) {
+
+		unsigned gic;
+
+		/* get the GIC base address from the CBAR register */
+		asm("mrc p15, 4, %0, c15, c0, 0\n" : "=r" (gic));
+		gic += GIC_DIST_OFFSET;
+
+		debug("%s: Starting the CA7#1\n", __func__);
+		sysctrl_writel(loaded_core[PKGT_CORE_CA71][PKGT_KIND_CODE].load_addr,
+			       RZN1_SYSCTRL_REG_BOOTADDR);
+		/* kick all CPUs (except this one) by writing to GICD_SGIR */
+		writel(1U << 24, gic + GICD_SGIR);
+	}
+
+	/* And now start the 'main' OS, hopefully */
+	if (loaded_core[PKGT_CORE_CA70][PKGT_KIND_CODE].load_addr) {
+		jump_to_image(
+			&loaded_core[PKGT_CORE_CA70][PKGT_KIND_CODE],
+			&loaded_core[PKGT_CORE_CA70][PKGT_KIND_DTB],
+			&loaded_core[PKGT_CORE_CA70][PKGT_KIND_DATA]);
+	}
+
+	printf("U-Boot SPL: Error: PKG Table has not started Cortex A7#0.\n");
+	stop();
+}
diff --git a/common/spl/spl_nand.c b/common/spl/spl_nand.c
index cd39f9b..d62cdd3 100644
--- a/common/spl/spl_nand.c
+++ b/common/spl/spl_nand.c
@@ -12,6 +12,8 @@
 #include <libfdt_env.h>
 #include <fdt.h>
 
+static int nand_inited;
+
 #if defined(CONFIG_SPL_NAND_RAW_ONLY)
 int spl_nand_load_image(struct spl_image_info *spl_image,
 			struct spl_boot_device *bootdev)
@@ -40,11 +42,17 @@ static ulong spl_nand_fit_read(struct spl_load_info *load, ulong offs,
 		return 0;
 }
 
-static int spl_nand_load_element(struct spl_image_info *spl_image,
-				 int offset, struct image_header *header)
+int spl_nand_load_element(struct spl_image_info *spl_image,
+			  int offset, struct image_header *header)
 {
 	int err;
 
+	/* Allow multiple calls */
+	if (!nand_inited) {
+		nand_init();
+		nand_inited = 1;
+	}
+
 	err = nand_spl_load_image(offset, sizeof(*header), (void *)header);
 	if (err)
 		return err;
@@ -86,7 +94,7 @@ static int spl_nand_load_image(struct spl_image_info *spl_image,
 
 	/*use CONFIG_SYS_TEXT_BASE as temporary storage area */
 	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
-#ifdef CONFIG_SPL_OS_BOOT
+#if  defined(CONFIG_SPL_OS_BOOT) && defined(CONFIG_SYS_NAND_SPL_KERNEL_OFFS)
 	if (!spl_start_uboot()) {
 		/*
 		 * load parameter image
diff --git a/common/spl/spl_spi.c b/common/spl/spl_spi.c
index cd1d6b2..b06ba86 100644
--- a/common/spl/spl_spi.c
+++ b/common/spl/spl_spi.c
@@ -15,7 +15,7 @@
 #include <errno.h>
 #include <spl.h>
 
-#ifdef CONFIG_SPL_OS_BOOT
+#if defined(CONFIG_SPL_OS_BOOT) && defined(CONFIG_SYS_SPI_KERNEL_OFFS)
 /*
  * Load the kernel, check for a valid header we can parse, and if found load
  * the kernel and then device tree.
@@ -27,7 +27,7 @@ static int spi_load_image_os(struct spl_image_info *spl_image,
 	int err;
 
 	/* Read for a header, parse or error out. */
-	spi_flash_read(flash, CONFIG_SYS_SPI_KERNEL_OFFS, 0x40,
+	spi_flash_read(flash, CONFIG_SYS_SPI_KERNEL_OFFS, sizeof(*header),
 		       (void *)header);
 
 	if (image_get_magic(header) != IH_MAGIC)
@@ -61,6 +61,63 @@ static ulong spl_spi_fit_read(struct spl_load_info *load, ulong sector,
 	else
 		return 0;
 }
+
+struct spi_flash *spl_spi_probe(void)
+{
+	struct spi_flash *flash;
+
+	flash = spi_flash_probe(CONFIG_SF_DEFAULT_BUS, CONFIG_SF_DEFAULT_CS,
+				CONFIG_SF_DEFAULT_SPEED, SPI_MODE_3);
+	if (!flash) {
+		puts("SPI probe failed.\n");
+		hang();
+	}
+
+	return flash;
+}
+
+int spl_spi_load_one_uimage(struct spl_image_info *spl_image,
+	struct spi_flash *flash, u32 offset)
+{
+	struct image_header header;
+	int err = 0;
+
+	/*
+	 * Skip loading the mkimage header. This is only necessary for block
+	 * based storage systems where the API requires loading whole blocks
+	 * into aligned destinations. The SF layer can load any amount of data
+	 * from flash and store it anywhere.
+	 */
+	spl_image->flags |= SPL_COPY_PAYLOAD_ONLY;
+
+	/* Load u-boot mkimage header */
+	err = spi_flash_read(flash, offset, sizeof(header), (void *)&header);
+	if (err)
+		return err;
+
+	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+		image_get_magic(&header) == FDT_MAGIC) {
+		struct spl_load_info load;
+
+		debug("Found FIT\n");
+		load.dev = flash;
+		load.priv = NULL;
+		load.filename = NULL;
+		load.bl_len = 1;
+		load.read = spl_spi_fit_read;
+		err = spl_load_simple_fit(spl_image, &load, offset, &header);
+	} else {
+		err = spl_parse_image_header(spl_image, &header);
+		if (err)
+			return err;
+		err = spi_flash_read(flash, offset + sizeof(header),
+				     spl_image->size,
+				     (void *)spl_image->load_addr);
+	}
+
+	return err;
+}
+
 /*
  * The main entry for SPI booting. It's necessary that SDRAM is already
  * configured and available since this code loads the main U-Boot image
@@ -71,55 +128,19 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 {
 	int err = 0;
 	struct spi_flash *flash;
-	struct image_header *header;
-
-	/*
-	 * Load U-Boot image from SPI flash into RAM
-	 */
-
-	flash = spi_flash_probe(CONFIG_SF_DEFAULT_BUS,
-				CONFIG_SF_DEFAULT_CS,
-				CONFIG_SF_DEFAULT_SPEED,
-				CONFIG_SF_DEFAULT_MODE);
-	if (!flash) {
-		puts("SPI probe failed.\n");
-		return -ENODEV;
-	}
+#if defined(CONFIG_SPL_OS_BOOT) && defined(CONFIG_SYS_SPI_KERNEL_OFFS)
+	struct image_header header_stack;
+	struct image_header *header = &header_stack;
+#endif
 
-	/* use CONFIG_SYS_TEXT_BASE as temporary storage area */
-	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
+	flash = spl_spi_probe();
 
-#ifdef CONFIG_SPL_OS_BOOT
-	if (spl_start_uboot() || spi_load_image_os(spl_image, flash, header))
+#if defined(CONFIG_SPL_OS_BOOT) && defined(CONFIG_SYS_SPI_KERNEL_OFFS)
+	if (spl_start_uboot() || spi_load_image_os(spl_image, flash, &header))
 #endif
 	{
-		/* Load u-boot, mkimage header is 64 bytes. */
-		err = spi_flash_read(flash, CONFIG_SYS_SPI_U_BOOT_OFFS, 0x40,
-				     (void *)header);
-		if (err)
-			return err;
-
-		if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
-			image_get_magic(header) == FDT_MAGIC) {
-			struct spl_load_info load;
-
-			debug("Found FIT\n");
-			load.dev = flash;
-			load.priv = NULL;
-			load.filename = NULL;
-			load.bl_len = 1;
-			load.read = spl_spi_fit_read;
-			err = spl_load_simple_fit(spl_image, &load,
-						  CONFIG_SYS_SPI_U_BOOT_OFFS,
-						  header);
-		} else {
-			err = spl_parse_image_header(spl_image, header);
-			if (err)
-				return err;
-			err = spi_flash_read(flash, CONFIG_SYS_SPI_U_BOOT_OFFS,
-					     spl_image->size,
-					     (void *)spl_image->load_addr);
-		}
+		err = spl_spi_load_one_uimage(spl_image, flash,
+					CONFIG_SYS_SPI_U_BOOT_OFFS);
 	}
 
 	return err;
diff --git a/configs/rzn1d400-db_defconfig b/configs/rzn1d400-db_defconfig
new file mode 100644
index 0000000..05e1f8c
--- /dev/null
+++ b/configs/rzn1d400-db_defconfig
@@ -0,0 +1,107 @@
+CONFIG_ARM=y
+CONFIG_ARCH_RZN1D=y
+CONFIG_TARGET_RENESAS_RZN1D400_DB=y
+CONFIG_HUSH_PARSER=y
+CONFIG_BOOTDELAY=1
+
+CONFIG_DEBUG_UART=y
+CONFIG_DEBUG_UART_NS16550=y
+CONFIG_DEBUG_UART_BASE=0x40060000
+CONFIG_DEBUG_UART_CLOCK=20000000
+CONFIG_DEBUG_UART_SHIFT=2
+
+# CONFIG_EFI_LOADER is not set
+
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_CONSOLE is not set
+# CONFIG_CMD_DM is not set
+# CONFIG_CMD_EDITENV is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIMER=y
+# CONFIG_CMD_ITEST is not set
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_MEMTEST=y
+
+CONFIG_DEFAULT_DEVICE_TREE="rzn1d400-db"
+# CONFIG_DISPLAY_CPUINFO is not set
+
+########## GPIO ##########
+CONFIG_DM_PCA953X=y
+# CONFIG_CMD_GPIO is not set
+
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+
+########## USBF/DFU ##########
+CONFIG_USB=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Renesas Electronics"
+CONFIG_G_DNL_VENDOR_NUM=0x045b
+CONFIG_G_DNL_PRODUCT_NUM=0x0239
+CONFIG_DFU_SF=y
+# CONFIG_DFU_NAND is not set
+CONFIG_DFU_RAM=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_DFU_EXT=y
+
+########## I2C ##########
+# CONFIG_CMD_I2C is not set
+
+########## SF ##########
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_MACRONIX=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+
+########## ETH ##########
+CONFIG_ETH_DESIGNWARE=y
+CONFIG_NETDEVICES=y
+CONFIG_NET=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_NFS is not set
+
+########## SDHC ##########
+CONFIG_ARASAN_SDHCI=y
+# CONFIG_BLK is not set
+CONFIG_MMC=y
+# CONFIG_DM_MMC_OPS is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_SDMA=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_FAT=y
+
+########## USBH ##########
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_CMD_USB=y
+
+
+################################# SPL ##########################################
+CONFIG_SPL=y
+# CONFIG_SPL_DM_DEVICE_REMOVE is not set
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_OF_TRANSLATE=y
+CONFIG_OF_SPL_REMOVE_PROPS="pinctrl-0 pinctrl-names clocks clock-names interrupt-parent interrupts"
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_USE_ARCH_MEMSET=y
+CONFIG_SPL_USE_ARCH_MEMCPY=y
+CONFIG_SPL_OS_BOOT=y
+CONFIG_SPL_MULTIIMAGE=y
+
+########## SF ##########
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI_SUPPORT=y
+
+# CONFIG_SPL_NAND_SUPPORT is not set
+# CONFIG_SPL_NAND_DRIVERS is not set
+# CONFIG_SPL_NAND_ONFI is not set
diff --git a/configs/rzn1s324-db_defconfig b/configs/rzn1s324-db_defconfig
new file mode 100644
index 0000000..188c075
--- /dev/null
+++ b/configs/rzn1s324-db_defconfig
@@ -0,0 +1,106 @@
+CONFIG_ARM=y
+CONFIG_ARCH_RZN1S=y
+CONFIG_TARGET_RENESAS_RZN1S324_DB=y
+CONFIG_HUSH_PARSER=y
+CONFIG_BOOTDELAY=1
+
+CONFIG_DEBUG_UART=y
+CONFIG_DEBUG_UART_NS16550=y
+CONFIG_DEBUG_UART_BASE=0x40060000
+CONFIG_DEBUG_UART_CLOCK=20000000
+CONFIG_DEBUG_UART_SHIFT=2
+
+# CONFIG_EFI_LOADER is not set
+
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_CONSOLE is not set
+# CONFIG_CMD_DM is not set
+# CONFIG_CMD_EDITENV is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIMER=y
+# CONFIG_CMD_ITEST is not set
+# CONFIG_CMD_SETEXPR is not set
+
+CONFIG_DEFAULT_DEVICE_TREE="rzn1s324-db"
+# CONFIG_DISPLAY_CPUINFO is not set
+
+########## GPIO ##########
+CONFIG_DM_PCA953X=y
+# CONFIG_CMD_GPIO is not set
+
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+
+########## USBF/DFU ##########
+CONFIG_USB=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Renesas Electronics"
+CONFIG_G_DNL_VENDOR_NUM=0x045b
+CONFIG_G_DNL_PRODUCT_NUM=0x0239
+CONFIG_DFU_SF=y
+# CONFIG_DFU_NAND is not set
+CONFIG_DFU_RAM=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_DFU_EXT=y
+
+########## I2C ##########
+# CONFIG_CMD_I2C is not set
+
+########## SF ##########
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_MACRONIX=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+
+########## ETH ##########
+CONFIG_ETH_DESIGNWARE=y
+CONFIG_NETDEVICES=y
+CONFIG_NET=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_NFS is not set
+
+########## SDHC ##########
+CONFIG_ARASAN_SDHCI=y
+# CONFIG_BLK is not set
+CONFIG_MMC=y
+# CONFIG_DM_MMC_OPS is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_SDMA=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_FAT=y
+
+########## USBH ##########
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_CMD_USB=y
+
+
+################################# SPL ##########################################
+CONFIG_SPL=y
+# CONFIG_SPL_DM_DEVICE_REMOVE is not set
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_OF_TRANSLATE=y
+CONFIG_OF_SPL_REMOVE_PROPS="pinctrl-0 pinctrl-names clocks clock-names interrupt-parent interrupts"
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_USE_ARCH_MEMSET=y
+CONFIG_SPL_USE_ARCH_MEMCPY=y
+CONFIG_SPL_OS_BOOT=y
+CONFIG_SPL_MULTIIMAGE=y
+
+########## SF ##########
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI_SUPPORT=y
+
+# CONFIG_SPL_NAND_SUPPORT is not set
+# CONFIG_SPL_NAND_DRIVERS is not set
+# CONFIG_SPL_NAND_ONFI is not set
diff --git a/doc/device-tree-bindings/spi/spi-cadence.txt b/doc/device-tree-bindings/spi/spi-cadence.txt
index c1e2233..94c800b 100644
--- a/doc/device-tree-bindings/spi/spi-cadence.txt
+++ b/doc/device-tree-bindings/spi/spi-cadence.txt
@@ -26,3 +26,5 @@ connected flash properties
 			  select (n_ss_out).
 - tslch-ns		: Delay in master reference clocks between setting
 			  n_ss_out low and first bit transfer
+- sample-edge-rising	: Data outputs from flash memory will be sampled on the
+			  rising edge. Default is falling edge.
diff --git a/drivers/Makefile b/drivers/Makefile
index c19fa14..e1eb611 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -8,6 +8,8 @@ obj-$(CONFIG_$(SPL_)LED)	+= led/
 obj-$(CONFIG_$(SPL_)PINCTRL)	+= pinctrl/
 obj-$(CONFIG_$(SPL_)RAM)	+= ram/
 
+obj-$(CONFIG_CADENCE_DDR_CTRL) += ddr/cadence/
+
 ifdef CONFIG_SPL_BUILD
 
 obj-$(CONFIG_SPL_CRYPTO_SUPPORT) += crypto/
diff --git a/drivers/ddr/cadence/Makefile b/drivers/ddr/cadence/Makefile
new file mode 100644
index 0000000..b1ff8a6
--- /dev/null
+++ b/drivers/ddr/cadence/Makefile
@@ -0,0 +1,5 @@
+#
+# SPDX-License-Identifier: BSD-2-Clause
+#
+
+obj-$(CONFIG_CADENCE_DDR_CTRL) += ddr_ctrl.o
diff --git a/drivers/ddr/cadence/ddr_ctrl.c b/drivers/ddr/cadence/ddr_ctrl.c
new file mode 100644
index 0000000..9115b9b
--- /dev/null
+++ b/drivers/ddr/cadence/ddr_ctrl.c
@@ -0,0 +1,383 @@
+/*
+ * Cadence DDR Controller
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ */
+
+/*
+ * The Cadence DDR Controller has a huge number of registers that principally
+ * cover two aspects, DDR specific timing information and AXI bus interfacing.
+ * Cadence's TCL script generates all of the register values for specific
+ * DDR devices operating at a specific frequency. The TCL script uses Denali
+ * SOMA files as inputs. The tool also generates the AXI bus register values as
+ * well, however this driver assumes that users will want to modifiy these to
+ * meet a specific application's needs.
+ * Therefore, this driver is passed two arrays containing register values for
+ * the DDR device specific information, and explicity sets the AXI registers.
+ *
+ * AXI bus interfacing:
+ *  The controller has four AXI slaves connections, and each of these can be
+ * programmed to accept requests from specific AXI masters (using their IDs).
+ * The regions of DDR that can be accessed by each AXI slave can be set such
+ * as to isolate DDR used by one AXI master from another. Further, the maximum
+ * bandwidth allocated to each AXI slave can be set.
+ */
+
+#include <common.h>
+#include <linux/sizes.h>
+#include <asm/io.h>
+#include "cadence_ddr_ctrl.h"
+
+#if 0
+	#define pr_debug(fmt, args...)	printf(fmt, ##args)
+	#define pr_debug2(fmt, args...)	printf(fmt, ##args)
+#else
+	#define pr_debug(fmt, args...)
+	#define pr_debug2(fmt, args...)
+#endif
+
+#define DDR_NR_AXI_PORTS		4
+#define DDR_NR_ENTRIES			16
+
+#define DDR_START_REG			(0)		/* DENALI_CTL_00 */
+#define DDR_CS0_MR1_REG			(32 * 4)	/* DENALI_CTL_32 */
+#define DDR_CS0_MR2_REG			(32 * 4 + 2)	/* DENALI_CTL_32 */
+#define DDR_CS1_MR1_REG			(34 * 4 + 2)	/* DENALI_CTL_34 */
+#define DDR_CS1_MR2_REG			(35 * 4)	/* DENALI_CTL_35 */
+#define DDR_ECC_ENABLE_REG		(36 * 4 + 2)	/* DENALI_CTL_36 */
+#define DDR_ECC_DISABLE_W_UC_ERR_REG	(37 * 4 + 2)	/* DENALI_CTL_37 */
+#define DDR_HALF_DATAPATH_REG		(54 * 4)	/* DENALI_CTL_54 */
+#define DDR_INTERRUPT_STATUS		(56 * 4)	/* DENALI_CTL_56 */
+#define DDR_INTERRUPT_ACK		(57 * 4)	/* DENALI_CTL_57 */
+#define DDR_INTERRUPT_MASK		(58 * 4)	/* DENALI_CTL_58 */
+#define DDR_CS0_ODT_MAP_REG		(62 * 4 + 2)	/* DENALI_CTL_62 */
+#define DDR_CS1_ODT_MAP_REG		(63 * 4)	/* DENALI_CTL_63 */
+#define DDR_ODT_TODTL_2CMD		(63 * 4 + 2)	/* DENALI_CTL_63 */
+#define DDR_ODT_TODTH_WR		(63 * 4 + 3)	/* DENALI_CTL_63 */
+#define DDR_ODT_TODTH_RD		(64 * 4 + 0)	/* DENALI_CTL_64 */
+#define DDR_ODT_EN			(64 * 4 + 1)	/* DENALI_CTL_64 */
+#define DDR_ODT_WR_TO_ODTH		(64 * 4 + 2)	/* DENALI_CTL_64 */
+#define DDR_ODT_RD_TO_ODTH		(64 * 4 + 3)	/* DENALI_CTL_64 */
+#define DDR_DIFF_CS_DELAY_REG		(66 * 4)	/* DENALI_CTL_66 */
+#define DDR_SAME_CS_DELAY_REG		(67 * 4)	/* DENALI_CTL_67 */
+#define DDR_RW_PRIORITY_REGS		(87 * 4 + 2)	/* DENALI_CTL_87 */
+#define DDR_AXI_ALIGN_STRB_DISABLE_REG	(90 * 4 + 2)	/* DENALI_CTL_90 */
+#define DDR_AXI_PORT_PROT_ENABLE_REG	(90 * 4 + 3)	/* DENALI_CTL_90 */
+#define DDR_ADDR_RANGE_REGS		(91 * 4)	/* DENALI_CTL_91 */
+#define DDR_RANGE_PROT_REGS		(218 * 4 + 2)	/* DENALI_CTL_218 */
+#define  RANGE_PROT_BITS_PRIV_SECURE	0
+#define  RANGE_PROT_BITS_SECURE		1
+#define  RANGE_PROT_BITS_PRIV		2
+#define  RANGE_PROT_BITS_FULL		3
+#define DDR_ARB_CMD_Q_THRESHOLD_REG	(346 * 4 + 2)	/* DENALI_CTL_346 */
+#define DDR_AXI_PORT_BANDWIDTH_REG	(346 * 4 + 3)	/* DENALI_CTL_346 */
+
+static void ddrc_writeb(u8 val, void *p)
+{
+	pr_debug2("DDR: %p = 0x%02x\n", p, val);
+	writeb(val, p);
+}
+
+static void ddrc_writew(u16 val, void *p)
+{
+	pr_debug2("DDR: %p = 0x%04x\n", p, val);
+	writew(val, p);
+}
+
+static void ddrc_writel(u32 val, void *p)
+{
+	pr_debug2("DDR: %p = 0x%08x\n", p, val);
+	writel(val, p);
+}
+
+void cdns_ddr_set_mr1(void *base, int cs, u16 odt_impedance, u16 drive_strength)
+{
+	void *reg;
+	u16 tmp;
+
+	if (cs == 0)
+		reg = (u8 *)base + DDR_CS0_MR1_REG;
+	else
+		reg = (u8 *)base + DDR_CS1_MR1_REG;
+
+	tmp = readw(reg);
+
+	tmp &= ~MODE_REGISTER_MASK;
+	tmp |=  MODE_REGISTER_MR1;
+
+	tmp &= ~MR1_ODT_IMPEDANCE_MASK;
+	tmp |=  odt_impedance;
+
+	tmp &= ~MR1_DRIVE_STRENGTH_MASK;
+	tmp |=  drive_strength;
+
+	writew(tmp, reg);
+}
+
+void cdns_ddr_set_mr2(void *base, int cs, u16 dynamic_odt, u16 self_refresh_temp)
+{
+	void *reg;
+	u16 tmp;
+
+	if (cs == 0)
+		reg = (u8 *)base + DDR_CS0_MR2_REG;
+	else
+		reg = (u8 *)base + DDR_CS1_MR2_REG;
+
+	tmp = readw(reg);
+
+	tmp &= ~MODE_REGISTER_MASK;
+	tmp |=  MODE_REGISTER_MR2;
+
+	tmp &= ~MR2_DYNAMIC_ODT_MASK;
+	tmp |=  dynamic_odt;
+
+	tmp &= ~MR2_SELF_REFRESH_TEMP_MASK;
+	tmp |=  self_refresh_temp;
+
+	writew(tmp, reg);
+}
+
+void cdns_ddr_set_odt_map(void *base, int cs, u16 odt_map)
+{
+	void *reg;
+
+	if (cs == 0)
+		reg = (u8 *)base + DDR_CS0_ODT_MAP_REG;
+	else
+		reg = (u8 *)base + DDR_CS1_ODT_MAP_REG;
+
+	writew(odt_map, reg);
+}
+
+void cdns_ddr_set_odt_times(void *base, u8 TODTL_2CMD, u8 TODTH_WR, u8 TODTH_RD,
+			    u8 WR_TO_ODTH, u8 RD_TO_ODTH)
+{
+	writeb(TODTL_2CMD,	(u8 *)base + DDR_ODT_TODTL_2CMD);
+	writeb(TODTH_WR,	(u8 *)base + DDR_ODT_TODTH_WR);
+	writeb(TODTH_RD,	(u8 *)base + DDR_ODT_TODTH_RD);
+	writeb(1,		(u8 *)base + DDR_ODT_EN);
+	writeb(WR_TO_ODTH,	(u8 *)base + DDR_ODT_WR_TO_ODTH);
+	writeb(RD_TO_ODTH,	(u8 *)base + DDR_ODT_RD_TO_ODTH);
+}
+
+void cdns_ddr_set_same_cs_delays(void *base, u8 r2r, u8 r2w, u8 w2r, u8 w2w)
+{
+	u32 val = (w2w << 24) | (w2r << 16) | (r2w << 8) | r2r;
+
+	writel(val, (u8 *)base + DDR_SAME_CS_DELAY_REG);
+}
+
+void cdns_ddr_set_diff_cs_delays(void *base, u8 r2r, u8 r2w, u8 w2r, u8 w2w)
+{
+	u32 val = (w2w << 24) | (w2r << 16) | (r2w << 8) | r2r;
+
+	writel(val, (u8 *)base + DDR_DIFF_CS_DELAY_REG);
+}
+
+void cdns_ddr_set_port_rw_priority(void *base, int port,
+			  u8 read_pri, u8 write_pri, u8 fifo_type)
+{
+	u8 *reg8 = (u8 *)base + DDR_RW_PRIORITY_REGS;
+
+	reg8 += (port * 3);
+	pr_debug("%s port %d (reg8=%p, DENALI_CTL_%d)\n",
+			__func__, port, reg8, (reg8-(u8 *)base)/4);
+
+	ddrc_writeb(read_pri, reg8++);
+	ddrc_writeb(write_pri, reg8++);
+	ddrc_writeb(fifo_type, reg8++);
+}
+
+/* The DDR Controller has 16 entries. Each entry can specify an allowed address
+ * range (with 16KB resolution) for one of the 4 AXI slave ports.
+ */
+void cdns_ddr_enable_port_addr_range_x(void *base, int port, int entry,
+			      u32 addr_start, u32 size)
+{
+	u32 addr_end;
+	u32 *reg32 = (u32 *)((u8 *)base + DDR_ADDR_RANGE_REGS);
+	u32 tmp;
+
+	reg32 += (port * DDR_NR_ENTRIES * 2);
+	reg32 += (entry * 2);
+	pr_debug("%s port %d, entry %d (reg32=%p, DENALI_CTL_%d)\n",
+			__func__, port, entry, reg32, ((u8 *)reg32-(u8 *)base)/4);
+
+	/* These registers represent 16KB address blocks */
+	addr_start /= SZ_16K;
+	size /= SZ_16K;
+	if (size)
+		addr_end = addr_start + size - 1;
+	else
+		addr_end = addr_start;
+
+	ddrc_writel(addr_start, reg32++);
+
+	/* end_addr: Ensure we only set the bottom 18-bits as DENALI_CTL_218
+	 * also contains the AXI0 range protection bits. */
+	tmp = readl(reg32);
+	tmp &= ~(BIT(18) - 1);
+	tmp |= addr_end;
+	ddrc_writel(tmp, reg32);
+}
+
+void cdns_ddr_enable_port_prot_x(void *base, int port, int entry,
+	u8 range_protection_bits,
+	u16 range_RID_check_bits,
+	u16 range_WID_check_bits,
+	u8 range_RID_check_bits_ID_lookup,
+	u8 range_WID_check_bits_ID_lookup)
+{
+	/*
+	 * Technically, the offset here points to the byte before the start of
+	 * the range protection registers. However, all entries consist of 8
+	 * bytes, except the first one (which is missing a padding byte) so we
+	 * work around that subtlely.
+	 */
+	u8 *reg8 = (u8 *)base + DDR_RANGE_PROT_REGS;
+
+	reg8 += (port * DDR_NR_ENTRIES * 8);
+	reg8 += (entry * 8);
+	pr_debug("%s port %d, entry %d (reg8=%p, DENALI_CTL_%d)\n",
+			__func__, port, entry, reg8, (reg8-(u8 *)base)/4);
+
+	if (port == 0 && entry == 0)
+		ddrc_writeb(range_protection_bits, reg8 + 1);
+	else
+		ddrc_writeb(range_protection_bits, reg8);
+
+	ddrc_writew(range_RID_check_bits, reg8 + 2);
+	ddrc_writew(range_WID_check_bits, reg8 + 4);
+	ddrc_writeb(range_RID_check_bits_ID_lookup, reg8 + 6);
+	ddrc_writeb(range_WID_check_bits_ID_lookup, reg8 + 7);
+}
+
+void cdns_ddr_set_port_bandwidth(void *base, int port,
+		        u8 max_percent, u8 overflow_ok)
+{
+	u8 *reg8 = (u8 *)base + DDR_AXI_PORT_BANDWIDTH_REG;
+
+	reg8 += (port * 3);
+	pr_debug("%s port %d, (reg8=%p, DENALI_CTL_%d)\n",
+			__func__, port, reg8, (reg8-(u8 *)base)/4);
+
+	ddrc_writeb(max_percent, reg8++);	/* Maximum bandwidth percentage */
+	ddrc_writeb(overflow_ok, reg8++);	/* Bandwidth overflow allowed */
+}
+
+void cdns_ddr_ctrl_init(void *ddr_ctrl_basex, int async,
+			const u32 *reg0, const u32 *reg350,
+			u32 ddr_start_addr, u32 ddr_size)
+{
+	int i, axi, entry;
+	u32 *ddr_ctrl_base = (u32 *)ddr_ctrl_basex;
+	u8 *base8 = (u8 *)ddr_ctrl_basex;
+
+	pr_debug("%s\n", __func__);
+	ddrc_writel(*reg0, ddr_ctrl_base + 0);
+	/* 1 to 6 are read only */
+	for (i = 7; i <= 26; i++)
+		ddrc_writel(*(reg0 + i), ddr_ctrl_base + i);
+	/* 27 to 29 are not changed */
+	for (i = 30; i <= 87; i++)
+		ddrc_writel(*(reg0 + i), ddr_ctrl_base + i);
+
+	/* Enable/disable ECC */
+#if defined(CONFIG_CADENCE_DDR_CTRL_ENABLE_ECC)
+	pr_debug("%s enabling ECC\n", __func__);
+	ddrc_writeb(1, base8 + DDR_ECC_ENABLE_REG);
+#else
+	ddrc_writeb(0, base8 + DDR_ECC_ENABLE_REG);
+#endif
+
+	/* ECC: Disable corruption for read/modify/write operations */
+	ddrc_writeb(1, base8 + DDR_ECC_DISABLE_W_UC_ERR_REG);
+
+	/* ECC: AXI aligned strobe disable => enable */
+	ddrc_writeb(0, base8 + DDR_AXI_ALIGN_STRB_DISABLE_REG);
+
+	/* Set 8/16-bit data width using reduc bit (enable half datapath)*/
+#if defined(CONFIG_CADENCE_DDR_CTRL_8BIT_WIDTH)
+	pr_debug("%s using 8-bit data\n", __func__);
+	ddrc_writeb(1, base8 + DDR_HALF_DATAPATH_REG);
+#else
+	ddrc_writeb(0, base8 + DDR_HALF_DATAPATH_REG);
+#endif
+
+	/* Threshold for command queue */
+	ddrc_writeb(0x03, base8 + DDR_ARB_CMD_Q_THRESHOLD_REG);
+
+	/* AXI port protection => enable */
+	ddrc_writeb(0x01, base8 + DDR_AXI_PORT_PROT_ENABLE_REG);
+
+	/*
+	 * We enable all AXI slave ports with the same settings that simply
+	 * ensures all accesses to ports are in the valid address range.
+	 */
+	for (axi = 0; axi < DDR_NR_AXI_PORTS; axi++) {
+		/* R/W priorities */
+		if (async)
+			cdns_ddr_set_port_rw_priority(ddr_ctrl_base, axi, 2, 2, 0);
+		else
+			cdns_ddr_set_port_rw_priority(ddr_ctrl_base, axi, 2, 2, 3);
+
+		/* DDR address range */
+		cdns_ddr_enable_port_addr_range_x(ddr_ctrl_base, axi, 0,
+					 ddr_start_addr, ddr_size);
+
+		/*
+		 * The hardware requires that the address ranges must not
+		 * overlap in order to trigger a valid address. So, we set all
+		 * other address range entries to be above the DDR, length 0.
+		 */
+		for (entry = 1; entry < DDR_NR_ENTRIES; entry++) {
+			cdns_ddr_enable_port_addr_range_x(ddr_ctrl_base, axi,
+					entry, ddr_start_addr + ddr_size, 0);
+		}
+
+		/* Access rights, see manual for details */
+		cdns_ddr_enable_port_prot_x(ddr_ctrl_base, axi, 0,
+				   RANGE_PROT_BITS_FULL,
+				   0xffff, 0xffff, 0x0f, 0x0f);
+
+		/* AXI bandwidth */
+		cdns_ddr_set_port_bandwidth(ddr_ctrl_base, axi, 50, 1);
+	}
+
+	for (i = 350; i <= 374; i++)
+		ddrc_writel(*(reg350 - 350 + i), ddr_ctrl_base + i);
+
+	/*
+	 * Disable all interrupts, we are not handling them.
+	 * For detail of the interrupt mask, ack and status bits, see the
+	 * manual's description of the 'int_status' parameter.
+	 */
+	ddrc_writel(0, base8 + DDR_INTERRUPT_MASK);
+}
+
+void cdns_ddr_ctrl_start(void *ddr_ctrl_basex)
+{
+	u32 *ddr_ctrl_base = (u32 *)ddr_ctrl_basex;
+	u8 *base8 = (u8 *)ddr_ctrl_basex;
+
+	/* Start */
+	ddrc_writeb(1, base8 + DDR_START_REG);
+
+	/* Wait for controller to be ready (interrupt status) */
+	while (!(readl(base8 + DDR_INTERRUPT_STATUS) & 0x100))
+		;
+
+	/* clear all interrupts */
+	ddrc_writel(~0, base8 + DDR_INTERRUPT_ACK);
+
+	/* Step 19 Wait 500us from MRESETB=1 */
+	udelay(500);
+
+	/* Step 20 tCKSRX wait (From supply stable clock for MCK) */
+	/* DENALI_CTL_19 TREF_ENABLE=0x1(=1), AREFRESH=0x1(=1) */
+	ddrc_writel(0x01000100, ddr_ctrl_base + 19);
+}
diff --git a/drivers/dfu/dfu.c b/drivers/dfu/dfu.c
index 8dacc1a..e14a0ee 100644
--- a/drivers/dfu/dfu.c
+++ b/drivers/dfu/dfu.c
@@ -17,6 +17,12 @@
 #include <linux/list.h>
 #include <linux/compiler.h>
 
+#ifdef CONFIG_CMD_DFU_EXT
+#define DFU_INFO_NAME "dfu_ext_info"
+#else
+#define DFU_INFO_NAME "dfu_alt_info"
+#endif
+
 static LIST_HEAD(dfu_list);
 static int dfu_alt_num;
 static int alt_num_cnt;
@@ -58,9 +64,9 @@ int dfu_init_env_entities(char *interface, char *devstr)
 #ifdef CONFIG_SET_DFU_ALT_INFO
 	set_dfu_alt_info(interface, devstr);
 #endif
-	str_env = getenv("dfu_alt_info");
+	str_env = getenv(DFU_INFO_NAME);
 	if (!str_env) {
-		error("\"dfu_alt_info\" env variable not defined!\n");
+		error("\"" DFU_INFO_NAME "\" env variable not defined!\n");
 		return -EINVAL;
 	}
 
@@ -77,10 +83,12 @@ int dfu_init_env_entities(char *interface, char *devstr)
 
 static unsigned char *dfu_buf;
 static unsigned long dfu_buf_size;
+unsigned char *dfu_read_buf;
 
 unsigned char *dfu_free_buf(void)
 {
 	free(dfu_buf);
+	free(dfu_read_buf);
 	dfu_buf = NULL;
 	return dfu_buf;
 }
@@ -108,9 +116,13 @@ unsigned char *dfu_get_buf(struct dfu_entity *dfu)
 		dfu_buf_size = dfu->max_buf_size;
 
 	dfu_buf = memalign(CONFIG_SYS_CACHELINE_SIZE, dfu_buf_size);
-	if (dfu_buf == NULL)
+	dfu_read_buf = memalign(CONFIG_SYS_CACHELINE_SIZE, dfu_buf_size);
+
+	if (dfu_buf == NULL || dfu_read_buf == NULL) {
 		printf("%s: Could not memalign 0x%lx bytes\n",
 		       __func__, dfu_buf_size);
+		dfu_free_buf();
+	}
 
 	return dfu_buf;
 }
@@ -466,18 +478,32 @@ int dfu_config_entities(char *env, char *interface, char *devstr)
 	for (i = 0; i < dfu_alt_num; i++) {
 
 		s = strsep(&env, ";");
+#ifdef CONFIG_CMD_DFU_EXT
+		interface = strsep(&s, " ");
+		devstr = NULL;
+		/* has a device been specified? */
+		if (strpbrk(s, ":")) {
+			devstr = s;
+			strsep(&s, " ");
+		}
+		debug("%s interface %s:%s, remains:%s\n", __func__,
+			interface, devstr, s);
+#endif
 		ret = dfu_fill_entity(&dfu[i], s, alt_num_cnt, interface,
 				      devstr);
 		if (ret) {
+#ifdef CONFIG_CMD_DFU_EXT
+			continue; /* it's OK for a probe to fail */
+#else
 			free(dfu);
 			return -1;
+#endif
 		}
 
 		list_add_tail(&dfu[i].list, &dfu_list);
 		alt_num_cnt++;
 	}
-
-	return 0;
+	return alt_num_cnt > 0 ? 0 : -1;
 }
 
 const char *dfu_get_dev_type(enum dfu_device_type t)
diff --git a/drivers/dfu/dfu_nand.c b/drivers/dfu/dfu_nand.c
index 23f1571..bd887e6 100644
--- a/drivers/dfu/dfu_nand.c
+++ b/drivers/dfu/dfu_nand.c
@@ -19,6 +19,18 @@
 #include <jffs2/load_kernel.h>
 #include <nand.h>
 
+static struct mtd_info *current_nand(int dev_index)
+{
+	if (dev_index < 0 ||
+	    dev_index >= CONFIG_SYS_MAX_NAND_DEVICE ||
+	    !nand_info[dev_index]) {
+		printf("%s: invalid nand device\n", __func__);
+		return ERR_PTR(-ENODEV);
+	}
+
+	return nand_info[dev_index];
+}
+
 static int nand_block_op(enum dfu_op op, struct dfu_entity *dfu,
 			u64 offset, void *buf, long *len)
 {
@@ -37,14 +49,9 @@ static int nand_block_op(enum dfu_op op, struct dfu_entity *dfu,
 	lim = dfu->data.nand.start + dfu->data.nand.size - start;
 	count = *len;
 
-	if (nand_curr_device < 0 ||
-	    nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
-	    !nand_info[nand_curr_device]) {
-		printf("%s: invalid nand device\n", __func__);
+	mtd = current_nand(nand_curr_device);
+	if (IS_ERR(mtd))
 		return -1;
-	}
-
-	mtd = nand_info[nand_curr_device];
 
 	if (op == DFU_OP_READ) {
 		ret = nand_read_skip_bad(mtd, start, &count, &actual,
@@ -146,14 +153,9 @@ static int dfu_flush_medium_nand(struct dfu_entity *dfu)
 		struct mtd_info *mtd;
 		nand_erase_options_t opts;
 
-		if (nand_curr_device < 0 ||
-		    nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
-		    !nand_info[nand_curr_device]) {
-			printf("%s: invalid nand device\n", __func__);
+		mtd = current_nand(nand_curr_device);
+		if (IS_ERR(mtd))
 			return -1;
-		}
-
-		mtd = nand_info[nand_curr_device];
 
 		memset(&opts, 0, sizeof(opts));
 		off = dfu->offset;
@@ -202,6 +204,17 @@ int dfu_fill_entity_nand(struct dfu_entity *dfu, char *devstr, char *s)
 		dfu->data.nand.start = simple_strtoul(s, &s, 16);
 		s++;
 		dfu->data.nand.size = simple_strtoul(s, &s, 16);
+		if (dfu->data.nand.size == 0) {
+			struct mtd_info *mtd = current_nand(nand_curr_device);
+
+			if (IS_ERR(mtd))
+				return -1;
+
+			mtd = nand_info[nand_curr_device];
+			dfu->data.nand.size = mtd->size - dfu->data.nand.start;
+			debug("DFU:%s calculated size is 0x%llx bytes\n",
+				dfu->name, dfu->data.nand.size);
+		}
 	} else if ((!strcmp(st, "part")) || (!strcmp(st, "partubi"))) {
 		char mtd_id[32];
 		struct mtd_device *mtd_dev;
diff --git a/drivers/dfu/dfu_sf.c b/drivers/dfu/dfu_sf.c
index 9702eee..d6ffaab 100644
--- a/drivers/dfu/dfu_sf.c
+++ b/drivers/dfu/dfu_sf.c
@@ -12,6 +12,8 @@
 #include <spi.h>
 #include <spi_flash.h>
 
+extern unsigned char *dfu_read_buf;
+
 static long dfu_get_medium_size_sf(struct dfu_entity *dfu)
 {
 	return dfu->data.sf.size;
@@ -20,7 +22,8 @@ static long dfu_get_medium_size_sf(struct dfu_entity *dfu)
 static int dfu_read_medium_sf(struct dfu_entity *dfu, u64 offset, void *buf,
 		long *len)
 {
-	return spi_flash_read(dfu->data.sf.dev, offset, *len, buf);
+	return spi_flash_read(dfu->data.sf.dev, dfu->data.sf.start + offset,
+		*len, buf);
 }
 
 static u64 find_sector(struct dfu_entity *dfu, u64 start, u64 offset)
@@ -33,13 +36,34 @@ static int dfu_write_medium_sf(struct dfu_entity *dfu,
 		u64 offset, void *buf, long *len)
 {
 	int ret;
+	int i;
+	u8 *buf8 = buf;
 
-	ret = spi_flash_erase(dfu->data.sf.dev,
-			      find_sector(dfu, dfu->data.sf.start, offset),
-			      dfu->data.sf.dev->sector_size);
+	/* Erase and write are slow, so avoid if possible */
+	ret = dfu_read_medium_sf(dfu, offset, dfu_read_buf, len);
 	if (ret)
 		return ret;
 
+	if (memcmp(dfu_read_buf, buf, *len) == 0) {
+		debug("%s: offset %lld, skip erase,write\n", __func__, offset);
+		return 0;
+	}
+
+	/* Only erase the page if needed, i.e. setting any bit. */
+	/* WARNING: this code assumes that erase sets the data to 0xFF */
+	for (i = 0; i < *len; i++) {
+		if (buf8[i] & (buf8[i] ^ dfu_read_buf[i])) {
+			ret = spi_flash_erase(dfu->data.sf.dev,
+				find_sector(dfu, dfu->data.sf.start, offset),
+				roundup(*len, dfu->data.sf.dev->sector_size));
+			if (ret)
+				return ret;
+			break;
+		}
+	}
+	if (i == *len)
+		debug("%s: offset %lld, skip erase\n", __func__, offset);
+
 	ret = spi_flash_write(dfu->data.sf.dev, dfu->data.sf.start + offset,
 			      *len, buf);
 	if (ret)
@@ -65,23 +89,29 @@ static void dfu_free_entity_sf(struct dfu_entity *dfu)
 
 static struct spi_flash *parse_dev(char *devstr)
 {
-	unsigned int bus;
-	unsigned int cs;
+	unsigned int bus = CONFIG_SF_DEFAULT_BUS;
+	unsigned int cs = CONFIG_SF_DEFAULT_CS;
 	unsigned int speed = CONFIG_SF_DEFAULT_SPEED;
 	unsigned int mode = CONFIG_SF_DEFAULT_MODE;
 	char *s, *endp;
 	struct spi_flash *dev;
 
 	s = strsep(&devstr, ":");
-	if (!s || !*s || (bus = simple_strtoul(s, &endp, 0), *endp)) {
-		printf("Invalid SPI bus %s\n", s);
-		return NULL;
+	if (s && *s) {
+		bus = simple_strtoul(s, &endp, 0);
+		if (*endp) {
+			printf("Invalid SPI bus %s\n", s);
+			return NULL;
+		}
 	}
 
 	s = strsep(&devstr, ":");
-	if (!s || !*s || (cs = simple_strtoul(s, &endp, 0), *endp)) {
-		printf("Invalid SPI chip-select %s\n", s);
-		return NULL;
+	if (s && *s) {
+		cs = simple_strtoul(s, &endp, 0);
+		if (*endp) {
+			printf("Invalid SPI chip-select %s\n", s);
+			return NULL;
+		}
 	}
 
 	s = strsep(&devstr, ":");
@@ -131,6 +161,12 @@ int dfu_fill_entity_sf(struct dfu_entity *dfu, char *devstr, char *s)
 		dfu->data.sf.start = simple_strtoul(s, &s, 16);
 		s++;
 		dfu->data.sf.size = simple_strtoul(s, &s, 16);
+		if (dfu->data.sf.size == 0) {
+			dfu->data.sf.size = dfu->data.sf.dev->size -
+							dfu->data.sf.start;
+			debug("DFU:%s calculated size is 0x%llx bytes\n",
+				dfu->name, dfu->data.sf.size);
+		}
 	} else {
 		printf("%s: Memory layout (%s) not supported!\n", __func__, st);
 		spi_flash_free(dfu->data.sf.dev);
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index c3462ab..e92069c 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -57,6 +57,12 @@ config MSM_SDHCI
           SD 3.0 specifications. Both SD and eMMC devices are supported.
 	  Card-detect gpios are not supported.
 
+config ARASAN_SDHCI
+	bool "Arasan Generic SDHCI controller support"
+	depends on DM_MMC && OF_CONTROL
+	help
+	  Support for Arasan SDHCI host controller on all platforms
+
 config ATMEL_SDHCI
 	bool "Atmel SDHCI controller support"
 	depends on DM_MMC && BLK && DM_MMC_OPS && ARCH_AT91
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 2b136ea..204351c 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -13,6 +13,7 @@ ifndef CONFIG_BLK
 obj-$(CONFIG_GENERIC_MMC) += mmc_legacy.o
 endif
 
+obj-$(CONFIG_ARASAN_SDHCI) += arasan_sdhci.o
 obj-$(CONFIG_ARM_PL180_MMCI) += arm_pl180_mmci.o
 obj-$(CONFIG_ATMEL_SDHCI) += atmel_sdhci.o
 obj-$(CONFIG_BFIN_SDH) += bfin_sdh.o
diff --git a/drivers/mmc/arasan_sdhci.c b/drivers/mmc/arasan_sdhci.c
new file mode 100644
index 0000000..20b06c1
--- /dev/null
+++ b/drivers/mmc/arasan_sdhci.c
@@ -0,0 +1,75 @@
+/*
+ * Generic Arasan SD Host Controller Interface
+ *
+ * Based on:
+ * Xilinx Zynq SD Host Controller Interface
+ * (C) Copyright 2013 - 2015 Xilinx, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <libfdt.h>
+#include <malloc.h>
+#include <sdhci.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int arasan_sdhci_probe(struct udevice *dev)
+{
+	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
+	struct sdhci_host *host = dev_get_priv(dev);
+	const void *fdt = gd->fdt_blob;
+	int node = dev->of_offset;
+	int max_freq;
+
+	host->bus_width	= fdtdec_get_int(fdt, node, "bus-width", 4);
+
+	/*
+	 * When we call sdhci_setup_cfg with a max_freq of 0, the SDHC code will
+	 * attempt to get it from the SDHC registers.
+	 */
+	max_freq = fdtdec_get_int(fdt, node, "max-frequency", 0);
+
+	if (fdtdec_get_bool(fdt, node, "no-1-8-v")) {
+		host->quirks = SDHCI_QUIRK_BROKEN_VOLTAGE;
+		host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	}
+
+#ifdef CONFIG_SDHCI_ARASAN_QUIRKS
+	host->quirks |= CONFIG_SDHCI_ARASAN_QUIRKS;
+#endif
+
+	add_sdhci(host, max_freq, 0);
+
+	upriv->mmc = host->mmc;
+	host->mmc->dev = dev;
+
+	return 0;
+}
+
+static int arasan_sdhci_ofdata_to_platdata(struct udevice *dev)
+{
+	struct sdhci_host *host = dev_get_priv(dev);
+
+	host->name = dev->name;
+	host->ioaddr = (void *)dev_get_addr(dev);
+
+	return 0;
+}
+
+static const struct udevice_id arasan_sdhci_ids[] = {
+	{ .compatible = "arasan,sdhci-8.9a" },
+	{ }
+};
+
+U_BOOT_DRIVER(arasan_sdhci_drv) = {
+	.name		= "arasan_sdhci",
+	.id		= UCLASS_MMC,
+	.of_match	= arasan_sdhci_ids,
+	.ofdata_to_platdata = arasan_sdhci_ofdata_to_platdata,
+	.probe		= arasan_sdhci_probe,
+	.priv_auto_alloc_size = sizeof(struct sdhci_host),
+};
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 9f8368a..6637214 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -1680,7 +1680,7 @@ int mmc_start_init(struct mmc *mmc)
 #endif
 	mmc->ddr_mode = 0;
 	mmc_set_bus_width(mmc, 1);
-	mmc_set_clock(mmc, 1);
+	mmc_set_clock(mmc, 400000);
 
 	/* Reset the Card */
 	err = mmc_go_idle(mmc);
diff --git a/drivers/mmc/sdhci.c b/drivers/mmc/sdhci.c
index cbf5f56..2465a21 100644
--- a/drivers/mmc/sdhci.c
+++ b/drivers/mmc/sdhci.c
@@ -590,7 +590,7 @@ int sdhci_setup_cfg(struct mmc_config *cfg, struct sdhci_host *host,
 		cfg->voltages |= MMC_VDD_165_195;
 
 	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
-		cfg->voltages |= host->voltages;
+		cfg->voltages &= host->voltages;
 
 	cfg->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
 	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) {
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 65bb040..5798396 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -6,6 +6,13 @@ config SYS_NAND_SELF_INIT
 	  This option, if enabled, provides more flexible and linux-like
 	  NAND initialization process.
 
+config NAND_CADENCE_EVATRONIX
+	bool "Configure Cadence/Evatronix Nand"
+	help
+	  This enables Nand driver support for Cadence (ex Evatronix) NAND flash
+	  controller. This uses the hardware ECC for read and
+	  write operations.
+
 config NAND_DENALI
 	bool "Support Denali NAND controller"
 	select SYS_NAND_SELF_INIT
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index fd4bb66..8c417d7 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -5,6 +5,8 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+obj-y += nand_timings.o
+
 ifdef CONFIG_SPL_BUILD
 
 ifdef CONFIG_SPL_NAND_DRIVERS
@@ -13,6 +15,7 @@ endif
 
 obj-$(CONFIG_SPL_NAND_AM33XX_BCH) += am335x_spl_bch.o
 obj-$(CONFIG_SPL_NAND_DENALI) += denali_spl.o
+obj-$(CONFIG_SPL_NAND_ONFI) += nand_spl_onfi.o
 obj-$(CONFIG_SPL_NAND_SIMPLE) += nand_spl_simple.o
 obj-$(CONFIG_SPL_NAND_LOAD) += nand_spl_load.o
 obj-$(CONFIG_SPL_NAND_ECC) += nand_ecc.o
@@ -32,7 +35,6 @@ obj-y += nand_ids.o
 obj-y += nand_util.o
 obj-y += nand_ecc.o
 obj-y += nand_base.o
-obj-y += nand_timings.o
 
 endif # not spl
 
@@ -43,6 +45,7 @@ obj-$(CONFIG_NAND_ECC_BCH) += nand_bch.o
 obj-$(CONFIG_NAND_ATMEL) += atmel_nand.o
 obj-$(CONFIG_NAND_ARASAN) += arasan_nfc.o
 obj-$(CONFIG_DRIVER_NAND_BFIN) += bfin_nand.o
+obj-$(CONFIG_NAND_CADENCE_EVATRONIX) += evatronix_nand.o
 obj-$(CONFIG_NAND_DAVINCI) += davinci_nand.o
 obj-$(CONFIG_NAND_DENALI) += denali.o
 obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_nand.o
@@ -71,6 +74,7 @@ obj-$(CONFIG_NAND_ZYNQ) += zynq_nand.o
 
 else  # minimal SPL drivers
 
+obj-$(CONFIG_NAND_CADENCE_EVATRONIX) += evatronix_nand.o
 obj-$(CONFIG_NAND_FSL_ELBC) += fsl_elbc_spl.o
 obj-$(CONFIG_NAND_FSL_IFC) += fsl_ifc_spl.o
 obj-$(CONFIG_NAND_MXC) += mxc_nand_spl.o
diff --git a/drivers/mtd/nand/evatronix_nand.c b/drivers/mtd/nand/evatronix_nand.c
new file mode 100644
index 0000000..73d0146
--- /dev/null
+++ b/drivers/mtd/nand/evatronix_nand.c
@@ -0,0 +1,1635 @@
+/*
+ * evatronix_nand.c - NAND Flash Driver for Evatronix NANDFLASH-CTRL
+ * NAND Flash Controller IP.
+ *
+ * Intended to handle one NFC, with up to two connected NAND flash chips,
+ * one per bank.
+ *
+ * This implementation has been designed against Rev 1.15 and Rev 1.16 of the
+ * NANDFLASH-CTRL Design Specification.
+ * Note that Rev 1.15 specifies up to 8 chip selects, whereas Rev 1.16
+ * only specifies one. We keep the definitions for the multiple chip
+ * selects though for future reference.
+ *
+ * The corresponding IP version is NANDFLASH-CTRL-DES-6V09H02RE08 .
+ *
+ * Copyright (c) 2015 Axis Communication AB, Lund, Sweden.
+ * Portions Copyright (c) 2010 ST Microelectronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#if defined(LINUX)
+#include <asm/dma.h>
+#include <linux/bitops.h> /* for ffs() */
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_mtd.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/concat.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+#include "evatronix_nand.h"
+#else
+#include <common.h>
+#include <malloc.h>
+#include <nand.h>
+#include <asm/dma-mapping.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+#include <linux/compat.h>
+#include <linux/err.h>
+#include <linux/mtd/nand_ecc.h>
+#include "evatronix_nand.h"
+
+/* U-Boot has it's own devm_kzalloc with a different prototype... */
+static inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
+{
+	return calloc(size, 1);
+}
+#endif
+
+/* Driver configuration */
+/* Stuff that we want user configurable should be moved to DT eventually, but
+ * for sure keep stuff here that we can't test yet due to IP configuration. */
+
+#undef NFC_HWECC_SUBPAGE_WRITE
+#undef NFC_HWECC_SUBPAGE_READ
+
+#undef POLLED_XFERS
+#define POLLED_XFERS
+
+#undef CLEAR_DMA_BUF_AFTER_WRITE
+#define WORKAROUND_NO_ECC_CNT
+
+/* DMA buffer for page transfers. */
+#define DMA_BUF_SIZE (8192 + 640) /* main + spare for 8k page flash */
+
+/* # bytes into the OOB we put our ECC */
+#define ECC_OFFSET 2
+
+/* Number of bytes that we read using READID command.
+ * When reading IDs the IP requires us set up the number of bytes to read
+ * prior to executing the operation, whereas the NAND subsystem would rather
+ * like us to be able to read one byte at a time from the chip. So we fake
+ * this by reading a set number of ID bytes, and then let the NAND subsystem
+ * read from our DMA buffer. */
+#define READID_LENGTH 8
+
+/* Debugging */
+
+#if defined(DEBUG)
+#define MTD_TRACE(FORMAT, ...) \
+	pr_info("mtd trace: %s: " FORMAT, __func__, ## __VA_ARGS__)
+#else
+#define MTD_TRACE(FORMAT, ...) \
+	if (0) \
+		pr_info("mtd trace: %s: " FORMAT, __func__, ## __VA_ARGS__)
+#endif
+
+/* Read modes */
+enum nfc_read_mode {
+	NFC_READ_STD, /* Standard page read with ECC */
+	NFC_READ_RAW, /* Raw mode read of main area without ECC */
+	NFC_READ_OOB, /* Read oob only (no ECC) */
+	NFC_READ_ALL  /* Read main+oob in raw mode (no ECC) */
+};
+
+/* Timing parameters, from dt */
+struct nfc_timings {
+	uint32_t time_seq_0;
+	uint32_t time_seq_1;
+	uint32_t timings_asyn;
+	uint32_t time_gen_seq_0;
+	uint32_t time_gen_seq_1;
+	uint32_t time_gen_seq_2;
+	uint32_t time_gen_seq_3;
+};
+
+/* Configuration, from dt */
+struct nfc_setup {
+	nand_ecc_modes_t ecc_mode;
+	int ecc_blksize;
+	int ecc_strength;
+	bool on_flash_bbt;
+	struct nfc_timings timings;
+	bool use_bank_select; /* CE selects 'bank' rather than 'chip' */
+	bool rb_wired_and;    /* Ready/busy wired AND rather than per-chip */
+	unsigned int cs;
+	unsigned int oob_reserved;
+};
+
+/* DMA buffer, from both software (buf) and hardware (phys) perspective. */
+struct nfc_dma {
+	void *buf; /* mapped address */
+	dma_addr_t phys; /* physical address */
+	int bytes_left; /* how much data left to read from buffer? */
+	int buf_bytes; /* how much allocated data in the buffer? */
+	uint8_t *ptr; /* work pointer */
+};
+
+#ifndef POLLED_XFERS
+/* Interrupt management */
+struct nfc_irq {
+	int done; /* interrupt triggered, consequently we're done. */
+	uint32_t int_status; /* INT_STATUS at time of interrupt */
+	wait_queue_head_t wq; /* For waiting on controller interrupt */
+};
+#endif
+
+/* Information common to all chips, including the NANDFLASH-CTRL IP */
+struct nfc_info {
+	unsigned char __iomem *regbase;
+	unsigned long clk_rate;
+	struct device *dev;
+	struct nand_hw_control *controller;
+	struct nfc_setup *setup;
+	struct nfc_dma dma;
+#ifndef POLLED_XFERS
+	struct nfc_irq irq;
+#endif
+};
+
+/* Per-chip controller configuration */
+struct nfc_config {
+	uint32_t mem_ctrl;
+	uint32_t control;
+	uint32_t ecc_ctrl;
+	uint32_t mem_status_mask;
+	uint32_t cs;
+};
+
+/* Cache for info that we need to save across calls to nfc_command */
+struct nfc_cmd_cache {
+	unsigned int command;
+	int page;
+	int column;
+	int write_size;
+	int oob_required;
+	int write_raw;
+};
+
+/* Information for each physical NAND chip. */
+struct chip_info {
+	struct mtd_info *mtd;
+	struct nand_chip chip;
+	struct nfc_cmd_cache cmd_cache;
+	struct nfc_config nfc_config;
+	bool ecc_enabled;
+};
+
+/* What we tell mtd is an mtd_info actually is a complete chip_info */
+#define TO_CHIP_INFO(mtd) \
+	((struct chip_info *)((struct nand_chip *)(mtd)->priv)->priv)
+
+/* This is a global pointer, as we only support one single instance of the NFC.
+ * For multiple instances, we would need to add nfc_info as a parameter to
+ * several functions, as well as adding it as a member of the chip_info struct.
+ * Since most likely a system would only have one NFC instance, we don't
+ * go all the way implementing that feature now. */
+static struct nfc_info *nfc_info;
+
+/* The timing setup is expected to come via DT. We keep some default timings
+ * here for reference, based on a 100 MHz reference clock. */
+
+static const struct nfc_timings default_mode0_pll_enabled = {
+	0x0d151533, 0x000b0515, 0x00000046,
+	0x00150000, 0x00000000, 0x00000005, 0x00000015 };
+
+/* oob info generated at runtime depending on ecc strength */
+static struct nand_ecclayout eva_oobinfo;
+
+/**** Utility routines. */
+
+/* Count the number of 0's in buff upto a max of max_bits */
+/* Used to determine how many bit flips there are in an allegely erased block */
+static int count_zero_bits(uint8_t *buff, int size, int max_bits)
+{
+	int k, zero_bits = 0;
+	uint32_t *buf32 = (uint32_t *)buff;
+
+	/* size is always a multiple of 4 */
+	for (k = 0; k < size/4 && zero_bits <= max_bits; k++) {
+		if (~buf32[k])
+			zero_bits += hweight32(~buf32[k]);
+	}
+
+	return zero_bits;
+}
+
+/**** Low level stuff. Read and write registers, interrupt routine, etc. */
+
+/* Read and write NFC SFR registers */
+
+static uint32_t nfc_read(uint reg_offset)
+{
+	return readl(nfc_info->regbase + reg_offset);
+}
+
+static void nfc_write(uint32_t data, uint reg_offset)
+{
+	/* Note: According to NANDFLASH-CTRL Design Specification, rev 1.14,
+	 * p19, the NFC SFR's can only be written when STATUS.CTRL_STAT is 0.
+	 * So, should really check for that here. */
+	writel(data, nfc_info->regbase  + reg_offset);
+}
+
+#ifndef POLLED_XFERS
+static irqreturn_t nfc_irq(int irq, void *device_info)
+{
+	/* Note that device_info = nfc_info, so if we don't want a global
+	 * nfc_info we can get it via device_info. */
+
+	/* Save interrupt status in case caller wants to check what actually
+	 * happened. */
+	nfc_info->irq.int_status = nfc_read(INT_STATUS_REG);
+
+	MTD_TRACE("Got interrupt %d, INT_STATUS 0x%08x\n",
+		  irq, nfc_info->irq.int_status);
+
+	/* disable global NFC interrupt */
+	nfc_write(nfc_read(CONTROL_REG) & ~CONTROL_INT_EN, CONTROL_REG);
+
+	nfc_info->irq.done = 1;
+	wake_up(&nfc_info->irq.wq);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/* Get resources from platform: register bank mapping, irqs, etc */
+static int nfc_init_resources(struct platform_device *pdev)
+{
+#if defined(LINUX)
+	struct device *dev = &pdev->dev;
+	struct resource *resource;
+	struct clk *clk;
+#ifndef POLLED_XFERS
+	int irq;
+#endif
+	int res;
+
+	/* Register base for controller, ultimately from device tree */
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!resource) {
+		dev_err(dev, "No register addresses configured!\n");
+		return -ENOMEM;
+	}
+	nfc_info->regbase = devm_ioremap_resource(dev, resource);
+	if (IS_ERR(nfc_info->regbase))
+		return PTR_ERR(nfc_info->regbase);
+
+	dev_info(dev, "Got SFRs at phys %pR, mapped to %pa\n",
+		 resource, nfc_info->regbase);
+
+	/* find the clocks */
+	clk = devm_clk_get(dev, "clka");
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+	res = clk_prepare_enable(clk);
+	if (res) {
+		dev_err(dev, "can not enable the NAND clka clock\n");
+		return res;
+	}
+
+	clk = devm_clk_get(dev, "clkb");
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+	res = clk_prepare_enable(clk);
+	if (res) {
+		dev_err(dev, "can not enable the NAND clkb clock\n");
+		return res;
+	}
+
+	res = clk_prepare_enable(clk);
+	if (res) {
+		dev_err(dev, "failed to enable clock\n");
+		return res;
+	}
+
+	nfc_info->clk_rate = clk_get_rate(clk);
+	if (nfc_info->clk_rate == 0) {
+		dev_err(dev, "NAND clock rate cannot be 0\n");
+		return -EIO;
+	}
+#else
+	/* U-Boot */
+	nfc_info->regbase = (void *)CONFIG_SYS_NAND_BASE;
+	nfc_info->clk_rate = CONFIG_SYS_NAND_CLOCK;
+#endif
+
+	/* A DMA buffer */
+#if defined(LINUX)
+	nfc_info->dma.buf =
+		dma_alloc_coherent(dev, DMA_BUF_SIZE,
+				   &nfc_info->dma.phys, GFP_KERNEL);
+#else
+	nfc_info->dma.buf =
+		dma_alloc_coherent(DMA_BUF_SIZE,
+				   (unsigned long*)&nfc_info->dma.phys);
+#endif
+	if (nfc_info->dma.buf == NULL) {
+		dev_err(dev, "dma_alloc_coherent failed!\n");
+		return -ENOMEM;
+	}
+
+	MTD_TRACE("DMA buffer %p at physical %p\n",
+		 nfc_info->dma.buf, (void *)nfc_info->dma.phys);
+
+#ifndef POLLED_XFERS
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "No irq configured\n");
+		return irq;
+	}
+	res = devm_request_irq(dev, irq, nfc_irq, 0, "cadence-nand", nfc_info);
+	if (res < 0) {
+		dev_err(dev, "request_irq failed\n");
+		return res;
+	}
+	dev_info(dev, "Successfully registered IRQ %d\n", irq);
+#endif
+
+	return 0;
+}
+
+/* Write timing setup to controller */
+static void setup_nfc_timing(struct nfc_setup *nfc_setup)
+{
+	nfc_write(nfc_setup->timings.time_seq_0, TIME_SEQ_0_REG);
+	nfc_write(nfc_setup->timings.time_seq_1, TIME_SEQ_1_REG);
+	nfc_write(nfc_setup->timings.timings_asyn, TIMINGS_ASYN_REG);
+	nfc_write(nfc_setup->timings.time_gen_seq_0, TIME_GEN_SEQ_0_REG);
+	nfc_write(nfc_setup->timings.time_gen_seq_1, TIME_GEN_SEQ_1_REG);
+	nfc_write(nfc_setup->timings.time_gen_seq_2, TIME_GEN_SEQ_2_REG);
+	nfc_write(nfc_setup->timings.time_gen_seq_3, TIME_GEN_SEQ_3_REG);
+}
+
+/* Write per-chip specific config to controller */
+static void config_nfc(struct nfc_config *nfc_config, void *ref)
+{
+	nfc_write(nfc_config->mem_ctrl, MEM_CTRL_REG);
+	nfc_write(nfc_config->control, CONTROL_REG);
+	nfc_write(nfc_config->ecc_ctrl, ECC_CTRL_REG);
+}
+
+
+#ifndef POLLED_XFERS
+/* Set up interrupt and wq, with supplied interrupt mask */
+static void setup_int(uint32_t what)
+{
+	/* Flag waited on by wq */
+	nfc_info->irq.done = 0;
+
+	/* clear interrupt status bits */
+	nfc_write(0, INT_STATUS_REG);
+
+	/* set interrupt mask */
+	nfc_write(what, INT_MASK_REG);
+
+	/* enable global NFC interrupt. Ooooh... */
+	nfc_write(nfc_read(CONTROL_REG) | CONTROL_INT_EN, CONTROL_REG);
+}
+#endif
+
+/* Set up interrupt, send command, then wait for (any bit of) expected state */
+/* Before issuing a command, we could check if the controller is ready.
+ * We can't check INT_STATUS_REG.MEM0_RDY_INT_FL as it is not a status bit,
+ * it is set on an nfc state transition after the completion of for
+ * instance a page program command (so we can use it as a command
+ * completed trigger).
+ * (See NFC Design Spec (rev 1.15) figure 35 for illustration.)
+ */
+static void command_and_wait(uint32_t nfc_command, uint32_t int_state)
+#ifndef POLLED_XFERS
+{
+	long timeout;
+
+	/* Set up interrupt condition. Here we utilize the fact that the
+	 * bits in INT_STATE are the same as in INT_MASK. */
+	setup_int(int_state);
+
+	/* Send command */
+	nfc_write(nfc_command, COMMAND_REG);
+
+	/* The timeout should only trigger in abnormal situations, so
+	 * we leave it at one second for now. (nand_base uses 20ms for write
+	 * and 400ms for erase, respectively.) */
+	/* TODO: A special case might be an unconnected flash chip during probe.
+	 * If that causes the timeout to be triggered, we might want to lower
+	 * it, and even make it dependent on the NAND flash command being
+	 * executed. */
+	timeout = wait_event_timeout(nfc_info->irq.wq, nfc_info->irq.done,
+				     1 * HZ);
+	if (timeout <= 0) {
+		dev_info(nfc_info->dev,
+			 "Request 0x%08x timed out waiting for 0x%08x\n",
+			 nfc_command, int_state);
+	}
+}
+#else /* POLLED_XFERS */
+{
+	int cmd_loops = 0;
+	uint32_t read_status, read_int_status, dma_status;
+
+	/* Clear interrupt status bits */
+	nfc_write(0, INT_STATUS_REG);
+
+	/* Send command */
+	nfc_write(nfc_command, COMMAND_REG);
+
+	/* Wait for command to complete */
+	MTD_TRACE("Waiting for 0x%08x bit(s) to be set in int_status\n",
+		  int_state);
+
+#define MAX_CMD_LOOPS 100000
+	do {
+		cmd_loops++;
+		read_status = nfc_read(STATUS_REG);
+		read_int_status = nfc_read(INT_STATUS_REG);
+		dma_status = nfc_read(DMA_CTRL_REG);
+		MTD_TRACE("Wait for command done: 0x%08x/0x%08x/0x%08x (%d)\n",
+			  read_status, read_int_status, dma_status, cmd_loops);
+	} while (!(read_int_status & int_state) && cmd_loops < MAX_CMD_LOOPS);
+
+	if (cmd_loops >= MAX_CMD_LOOPS)
+		MTD_TRACE("Int wait for 0x%08x timed out after %d loops: "
+			  "STATUS = 0x%08x, INT_STATUS=0x%08x, "
+			  "DMA_CTRL = 0x%08x, command 0x%08x\n",
+			  int_state, cmd_loops, read_status, read_int_status,
+			  dma_status, nfc_command);
+}
+#endif
+
+/* Initialize DMA, wq and interrupt status for upcoming transfer. */
+static void init_dma(uint64_t addr, int bytes)
+{
+	int dma_trig_level;
+
+	/* DMA control */
+
+	/* Start when COMMAND register written, set burst type/size */
+	nfc_write(DMA_CTRL_DMA_START | DMA_CTRL_DMA_BURST_I_P_4, DMA_CTRL_REG);
+
+	/* DMA address and length */
+	if (nfc_read(PARAM_REG_REG) & PARAM_REG_DMA64)
+		nfc_write(addr >> 32, DMA_ADDR_H_REG);
+	nfc_write(addr, DMA_ADDR_L_REG);
+
+	/* Byte counter */
+	/* Round up to nearest 32-bit word */
+	nfc_write((bytes + 3) & 0xfffffffc, DMA_CNT_REG);
+
+	/* Cap DMA trigger level at FIFO size */
+	dma_trig_level = bytes * 8 / 32; /* 32-bit entities */
+	if (dma_trig_level > DMA_TLVL_MAX)
+		dma_trig_level = DMA_TLVL_MAX;
+	nfc_write(dma_trig_level, DMA_TLVL_REG);
+}
+
+/* Initialize transfer to or from DMA buffer */
+static void init_dmabuf(int bytes)
+{
+	nfc_info->dma.ptr = nfc_info->dma.buf;
+	nfc_info->dma.buf_bytes = nfc_info->dma.bytes_left = bytes;
+}
+
+/* Initialize controller for DATA_REG readout */
+static void init_dreg_read(int bytes)
+{
+	/* Transfer to DATA_REG register */
+	nfc_write(DATA_REG_SIZE_DATA_REG_SIZE(bytes), DATA_REG_SIZE_REG);
+}
+
+/* Set up for ECC if needed */
+static void setup_ecc(struct chip_info *info, int enable_ecc, int column)
+{
+	uint32_t control;
+
+	/* When reading the oob, we never want ECC, when reading the
+	 * main area, it depends. */
+	control = nfc_read(CONTROL_REG) & ~CONTROL_ECC_EN;
+	if (enable_ecc) {
+		nfc_write(ECC_OFFSET + info->mtd->writesize +
+			  info->chip.ecc.bytes * column / info->chip.ecc.size,
+			  ECC_OFFSET_REG);
+		control |= CONTROL_ECC_EN;
+	}
+	nfc_write(control, CONTROL_REG);
+}
+
+/* Read from flash using DMA */
+/* Assumes basic setup for DMA has been done previously. */
+/* The MTD framework never reads a complete page (main + oob) in one go
+ * when using HW ECC, so we don't need to support NFC_READ_ALL in this mode.
+ * For SW ECC we read the whole page on one go in ALL mode however. */
+static void read_dma(struct chip_info *info, int page, int column,
+		     enum nfc_read_mode m)
+{
+	int size;
+	uint32_t command;
+
+	switch (m) {
+	case NFC_READ_OOB:
+		size = info->mtd->oobsize;
+		break;
+	case NFC_READ_ALL:
+		size = info->mtd->oobsize + info->mtd->writesize;
+		break;
+	case NFC_READ_STD:
+	case NFC_READ_RAW:
+		size = info->mtd->writesize;
+		break;
+	default:
+		BUG();
+	}
+
+	/* Set up ECC depending on mode */
+	setup_ecc(info, m == NFC_READ_STD && info->ecc_enabled, column);
+
+	/* Set up DMA and transfer size */
+
+	init_dmabuf(size);
+	init_dma(nfc_info->dma.phys, size);
+	nfc_write(size, DATA_SIZE_REG);
+
+	/* Set up addresses */
+
+	if (m == NFC_READ_OOB)
+		column += info->mtd->writesize;
+	nfc_write(column, ADDR0_COL_REG);
+	nfc_write(page, ADDR0_ROW_REG);
+
+	/* For devices > 128 MiB we have 5 address cycles and can use a
+	 * standard NFC command sequence. For smaller devices we have
+	 * 4 address cycles and need to use a Generic Command Sequence. */
+	if (info->chip.chipsize > (128 << 20)) {
+		command = COMMAND_READ_PAGE_DMA_STD;
+	} else {
+		nfc_write(GEN_SEQ_CTRL_READ_PAGE_4CYCLE, GEN_SEQ_CTRL_REG);
+		command = COMMAND_READ_PAGE_DMA_GEN;
+	}
+
+	command_and_wait(command, INT_STATUS_DMA_INT_FL);
+}
+
+/* Write using DMA */
+/* Assumes DMA has been set up previously and buffer contains data. */
+/* Contrary to read, column is set to writesize when writing to oob, by mtd.
+ * oob is set when the caller wants to write oob data along with the main data.
+ */
+static void write_dma(struct chip_info *info, int page, int column,
+		int oob, int raw)
+{
+	int size;
+	uint32_t command;
+
+	/* Since the controller handles ECC on its own, raw mode doesn't
+	 * come into the size calculations. */
+	if (column >= info->mtd->writesize) { /* oob write only */
+		size = info->mtd->oobsize;
+		raw = 1;
+	} else {
+		size = info->mtd->writesize;
+		if (oob) {
+			size += info->mtd->oobsize;
+			raw = 1;
+		}
+	}
+
+	setup_ecc(info, !raw && info->ecc_enabled, column);
+
+	/* Dump selected parts of buffer */
+	MTD_TRACE("Write %d bytes: 0x%08x 0x%08x .. 0x%08x\n", size,
+		  ((uint32_t *)(nfc_info->dma.buf))[0],
+		  ((uint32_t *)(nfc_info->dma.buf))[1],
+		  ((uint32_t *)(nfc_info->dma.buf))[size / 4 - 1]);
+
+	/* Set up DMA and transfer size */
+	init_dma(nfc_info->dma.phys, size);
+	nfc_write(size, DATA_SIZE_REG);
+
+	/* Set up addresses */
+
+	nfc_write(column, ADDR0_COL_REG);
+	nfc_write(page, ADDR0_ROW_REG);
+
+	/* For devices > 128 MiB we have 5 address cycles and can use a
+	 * standard NFC command sequence. For smaller devices we have
+	 * 4 address cycles and need to use a Generic Command Sequence. */
+	if (info->chip.chipsize > (128 << 20)) {
+		command = COMMAND_WRITE_PAGE_DMA_STD;
+	} else {
+		nfc_write(GEN_SEQ_CTRL_WRITE_PAGE_4CYCLE, GEN_SEQ_CTRL_REG);
+		command = COMMAND_WRITE_PAGE_DMA_GEN;
+	}
+
+	command_and_wait(command, INT_STATUS_DMA_INT_FL);
+
+	/* Don't need to check error status (INT_STATUS_REG.STAT_ERR_INT0_FL)
+	 * here, as the NAND subsystem checks device error status anyway after
+	 * the write command. */
+
+#ifdef CLEAR_DMA_BUF_AFTER_WRITE
+	/* clear buffer so it doesn't contain the written data anymore */
+	memset(nfc_info->dma.buf, 0, DMA_BUF_SIZE);
+#endif
+}
+
+/* Block erase */
+static void block_erase(int page, int cs)
+{
+	/* Set up addresses */
+	nfc_write(page, ADDR0_ROW_REG);
+	MTD_TRACE("Erase block containing page %d\n", page);
+
+	/* Send 3 address cycle block erase command */
+	command_and_wait(COMMAND_BLOCK_ERASE, INT_STATUS_MEM_RDY_INT_FL(cs));
+
+#ifndef POLLED_XFERS
+	MTD_TRACE("Erase block: INT_STATUS 0x%08x\n", nfc_info->irq.int_status);
+#endif
+
+	/* Don't need to check error status (INT_STATUS_REG.STAT_ERR_INT0_FL)
+	 * here, as the NAND subsystem checks device error status anyway after
+	 * the erase command. The error bit in practice probably just indicates
+	 * that the flash didn't pull R/_B low within tWB. */
+}
+
+/* Check for erased page.
+ * The prerequisite to calling this routine is: page has been read with
+ * HW ECC, which has returned an 'ecc uncorrectable' status, so either the
+ * page does in fact contain too many bitflips for the ECC algorithm to correct
+ * or the page is in fact erased, which results in the all-FF's ECC to
+ * be invalid relative to the all-FF's data on the page.
+ * Since with the Evatronix NFC we don't have access to either the ECC bytes
+ * or the oob area after a HW ECC read, the following algorithm is adopted:
+ * - Count the number of 0's in the main area. If there are more than
+ *   the ECC strength per ECC block we assume the page wasn't in fact erased,
+ *   and return with an error status.
+ * - If the main area appears erased, we still need to determine if the oob is
+ *   also erased, if not, it would appear that the page wasn't in fact erased,
+ *   and what we're looking at is a page of mostly-FF data with an invalid ECC.
+ *   - Thus we need to read the oob, leaving the main area at the start of the
+ *     DMA buffer in case someone actually wants to read the data later (e.g.
+ *     nanddump).
+ *   - We then count the number of non-zero bits in the oob. The accepted
+ *     number of zeros could be determined by figuring the the size ratio
+ *     of the oob compared to an ECC block. For instance, if the oob is 64
+ *     bytes, an ECC block 512 bytes, and the error correction capability
+ *     of 8 bits, then the accepted number of zeros for the oob to be
+ *     considered erased would be 64/512 * 8 = 1. Alternatively we could just
+ *     accept an error correction capability number of zeros.
+ *     If there are less than this threshold number of zero bits, the page
+ *     is considered erased. In this case we return an all-FF page to the user.
+ *     Otherwise, we consider ourselves to have an ECC error on our hands,
+ *     and we return the apropriate error status while at the same time leaving
+ *     original main area data in place, for potential scrutiny by a user space
+ *     application (e.g. nanddump).
+ * Caveat: It could be that there are some cases for which an almost-FF page
+ * yields an almost-FF ECC. If there are fewer than the error correction
+ * capability number of zero bits, we could conclude that such a page would
+ * be erased when in fact it actually contains data with too many bitflips.
+ * Experience will have to determine whether this can actually occur. From
+ * past experiences with ECC codes it seems unlikely that that trivial
+ * data will in fact result in a trivial ECC code. Even the fairly basic
+ * 1-bit error correction capability Hamming code does not on its own return
+ * an all-FF ECC for all-FF data.
+ *
+ * Function returns 1 if the page is in fact (considered) erased, 0 if not.
+ */
+static int check_erased_page(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+	struct nand_chip *chip = &info->chip;
+
+	/* We calculate the number of steps here rather than grabbing
+	 * ecc.steps to handle the case of a subpage read where we
+	 * haven't read a complete page. */
+	int eccsteps = len / chip->ecc.size;
+	int eccsize = chip->ecc.size;
+	int eccstrength = chip->ecc.strength;
+
+	int main_area_zeros = 0;
+
+	int step;
+	uint8_t *bufpos = buf;
+
+	MTD_TRACE("%s: %d byte page, ecc steps %d, size %d, strength %d\n",
+		  __func__, len, eccsteps, eccsize, eccstrength);
+
+	/* Check that main area appears erased. If not, return */
+
+	for (step = 0; step < eccsteps; step++) {
+		int zeros = count_zero_bits(bufpos, eccsize, eccstrength);
+
+		if (zeros > eccstrength)
+			return 0;
+		bufpos += eccsize;
+		main_area_zeros += zeros;
+	}
+
+	/* Ok, main area seems erased. Read oob so we can check it too. */
+
+	/* Note that this will overwrite the DMA buffer with the oob data,
+	 * which is ok since the main area data has already been copied
+	 * to buf earlier. */
+	read_dma(info, info->cmd_cache.page, info->cmd_cache.column,
+		 NFC_READ_OOB);
+
+	/* We go for the simple approach and accept eccstrength zero bits */
+	/* We only check the BBM and ECC bytes, the rest may be file system */
+	if (count_zero_bits(nfc_info->dma.buf,
+		eva_oobinfo.oobfree->offset, eccstrength) > eccstrength)
+		return 0;
+
+	MTD_TRACE("%s: Page is erased.%s\n", __func__,
+		  main_area_zeros != 0 ? " Clearing main area to 0xff." : "");
+
+	if (main_area_zeros != 0)
+		memset(buf, 0xff, len);
+
+	return 1;
+}
+
+
+/**** MTD API ****/
+
+/* For cmd_ctrl (and possibly others) we need to do absolutely nothing, but the
+ * pointer is still required to point to a valid function. */
+static void nfc_dummy_cmd_ctrl(struct mtd_info *mtd, int cmd,
+		unsigned int ctrl)
+{
+}
+
+/* Read state of ready pin */
+static int nfc_dev_ready(struct mtd_info *mtd)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+	struct nfc_config *nfc_config = &info->nfc_config;
+
+	MTD_TRACE("mtd %p\n", mtd);
+
+	return !!(nfc_read(STATUS_REG) & nfc_config->mem_status_mask);
+
+}
+
+/* Read byte from DMA buffer */
+/* Not used directly, only via nfc_read_byte */
+static uint8_t nfc_read_dmabuf_byte(struct mtd_info *mtd)
+{
+	if (nfc_info->dma.bytes_left) {
+		MTD_TRACE("mtd %02x\n", *nfc_info->dma.ptr);
+		nfc_info->dma.bytes_left--;
+		return *nfc_info->dma.ptr++;
+	} else
+		return 0; /* no data */
+}
+
+/* Read block of data from DMA buffer */
+static void nfc_read_dmabuf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	MTD_TRACE("mtd %p, buf %p, len %d\n", mtd, buf, len);
+	if (len > nfc_info->dma.bytes_left) {
+		dev_crit(nfc_info->dev,
+			 "Trying to read %d bytes with %d bytes remaining\n",
+			 len, nfc_info->dma.bytes_left);
+		BUG();
+	}
+	memcpy(buf, nfc_info->dma.ptr, len);
+	nfc_info->dma.ptr += len;
+	nfc_info->dma.bytes_left -= len;
+}
+
+/* Write block of data to DMA buffer */
+static void nfc_write_dmabuf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	MTD_TRACE("mtd %p, buf %p, len %d\n", mtd, buf, len);
+	if (len > nfc_info->dma.bytes_left) {
+		dev_crit(nfc_info->dev,
+			 "Trying to write %d bytes with %d bytes remaining\n",
+			 len, nfc_info->dma.bytes_left);
+		BUG();
+	}
+	memcpy(nfc_info->dma.ptr, buf, len);
+	nfc_info->dma.ptr += len;
+	nfc_info->dma.bytes_left -= len;
+	info->cmd_cache.write_size += len; /* calculate total length to write */
+}
+
+/* Read byte from DMA buffer or DATA_REG, depending on previous command. */
+/* Used by MTD for reading ID bytes, and chip status */
+static uint8_t nfc_read_byte(struct mtd_info *mtd)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+	uint8_t status_value;
+
+	/*
+	 * If the controller is not ready (e.g. no NAND attached), return dummy
+	 * data out to ensure we don't lock up waiting for data.
+	 */
+	if (nfc_read(STATUS_REG) & STATUS_CTRL_STAT)
+		return 0xff;
+
+	if (info->cmd_cache.command != NAND_CMD_STATUS)
+		return nfc_read_dmabuf_byte(mtd);
+
+	MTD_TRACE("Read status\n");
+
+	/* In order to read status, we need to send a READ_STATUS command
+	 * to the NFC first, in order to get the data into the DATA_REG */
+	init_dreg_read(1);
+	/* We want to read all status bits from the device */
+	nfc_write(STATUS_MASK_STATE_MASK(0xff), STATUS_MASK_REG);
+	command_and_wait(COMMAND_READ_STATUS, INT_STATUS_DATA_REG_FL);
+	status_value = nfc_read(DATA_REG_REG) & 0xff;
+	MTD_TRACE("Status 0x%08x\n", status_value);
+	return status_value;
+}
+
+/* Do the dirty work for read_page_foo */
+static int nfc_read_page_mode(struct mtd_info *mtd, struct nand_chip *chip,
+		int offset, int len, uint8_t *buf, int oob_required, int page,
+		enum nfc_read_mode m)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+	unsigned int max_bitflips;
+	uint32_t ecc_status;
+
+	MTD_TRACE("page %d, col %d, offs %d, size %d\n",
+		  page, info->cmd_cache.column, offset, len);
+
+	if (page != info->cmd_cache.page) {
+		MTD_TRACE("Warning: Read page has different page number than "
+			  "READ0: %d vs. %d\n", page, info->cmd_cache.page);
+	}
+
+	if (m == NFC_READ_STD) {
+		/* ECC error flags and counters are not cleared automatically
+		 * so we do it here. */
+		/* Note that the design spec says nothing about having to
+		 * zero ECC_STAT (although it explicitly says that ECC_CNT
+		 * needs to be zeroed by software), but testing on actual
+		 * hardware (RTL at this stage) reveals that this is in fact
+		 * the case. */
+		nfc_write(0, ECC_STAT_REG);
+		nfc_write(0, ECC_CNT_REG);
+	}
+
+	read_dma(info, info->cmd_cache.page, info->cmd_cache.column + offset, m);
+
+	/* This is actually nfc_read_dmabuf */
+	/* We add the offset here because the nand_base expects the data
+	 * to be in the corresponding place in the page buffer, rather than
+	 * at the beginning. */
+	chip->read_buf(mtd, buf + offset, len);
+
+	if (m == NFC_READ_RAW)
+		return 0;
+
+	/* Get ECC status from controller */
+	ecc_status = nfc_read(ECC_STAT_REG);
+	max_bitflips = nfc_read(ECC_CNT_REG) & ECC_CNT_ERR_LVL_MASK;
+
+#ifdef WORKAROUND_NO_ECC_CNT
+	/* If we get an ERROR bit set, but ECC_CNT is 0, we assume
+	 * a single bit flip has occurred for want of better information. */
+	if ((ecc_status & ECC_STAT_ERROR(info->nfc_config.cs)) &&
+	    max_bitflips == 0)
+		max_bitflips = 1;
+#endif
+
+	if (ecc_status & ECC_STAT_UNC(info->nfc_config.cs))
+		if (!check_erased_page(mtd, buf, mtd->writesize)) {
+			dev_warn(nfc_info->dev,
+				"Uncorrected errors on page %d!\n", page);
+			mtd->ecc_stats.failed++;
+		}
+
+	/* The following is actually not really correct, as the stats should
+	 * reflect _all_ bitflips, not just the largest one in the latest read.
+	 * We could rectify this by reading chip->ecc.bytes at a time,
+	 * and accumulating the statistics per read, but at least for now
+	 * the additional overhead doesn't seem to warrant the increased
+	 * accuracy of the statistics, since the important figure is the
+	 * max number of bitflips in a single ECC block returned by this
+	 * function. */
+	mtd->ecc_stats.corrected += max_bitflips;
+
+	MTD_TRACE("ECC read status: %s%s%s%s, correction count %d\n",
+		  ecc_status & ECC_STAT_UNC(info->nfc_config.cs) ?
+			"Uncorrected " : "",
+		  ecc_status & ECC_STAT_ERROR(info->nfc_config.cs)
+			? "Corrected " : "",
+		  ecc_status & ECC_STAT_OVER(info->nfc_config.cs)
+			? "Over limit " : "",
+		  ecc_status & (ECC_STAT_UNC(info->nfc_config.cs) |
+				ECC_STAT_ERROR(info->nfc_config.cs) |
+				ECC_STAT_OVER(info->nfc_config.cs))
+			?  "" : "ok",
+		  max_bitflips);
+
+	/* We shouldn't see oob_required for ECC reads. */
+	if (oob_required) {
+		dev_crit(nfc_info->dev, "Need separate read for the OOB\n");
+		BUG();
+	}
+
+	return max_bitflips;
+}
+
+/* Read page with HW ECC */
+static int nfc_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+		uint8_t *buf, int oob_required, int page)
+{
+	MTD_TRACE("page %d, oobreq %d\n", page, oob_required);
+	return nfc_read_page_mode(mtd, chip, 0, mtd->writesize, buf,
+				  oob_required, page, NFC_READ_STD);
+}
+
+/* Read page with no ECC */
+static int nfc_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+		uint8_t *buf, int oob_required, int page)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	MTD_TRACE("page %d, oobreq %d\n", page, oob_required);
+	/* Since we're doing a raw read we can safely ignore the return value
+	 * as it is the number of bit flips in ECC mode only. */
+	nfc_read_page_mode(mtd, chip, 0, mtd->writesize, buf, oob_required,
+			   page, NFC_READ_RAW);
+
+	if (!oob_required)
+		return 0;
+
+	/* Read OOB */
+	read_dma(info, info->cmd_cache.page, info->cmd_cache.column,
+		 NFC_READ_OOB);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/* Write page with HW ECC */
+/* This is the only place where we know we'll be writing w/ ECC */
+static int nfc_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+		const uint8_t *buf, int oob_required, int page)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	MTD_TRACE("oob_required %d\n", oob_required);
+
+	/* The controller can't write data to the oob when ECC is enabled,
+	 * so we set oob_required to 0 here and don't process the oob
+	 * further even if requested. This could happen for instance if
+	 * using nandwrite -o without -n . */
+	if (oob_required)
+		dev_warn(nfc_info->dev, "Tried to write OOB with ECC!\n");
+	info->cmd_cache.oob_required = 0;
+	info->cmd_cache.write_raw = 0;
+
+	nfc_write_dmabuf(mtd, buf, mtd->writesize);
+
+	return 0;
+}
+
+/* Write page with no ECC */
+/* This is the only place where we know we won't be writing w/ ECC */
+static int nfc_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+		const uint8_t *buf, int oob_required, int page)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	MTD_TRACE("oob_required %d\n", oob_required);
+
+	/* We need this for the upcoming PAGEPROG command */
+	info->cmd_cache.oob_required = oob_required;
+	info->cmd_cache.write_raw = 1;
+
+	nfc_write_dmabuf(mtd, buf, mtd->writesize);
+
+	if (oob_required)
+		chip->write_buf(mtd, info->chip.oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/* Handle commands from MTD NAND layer */
+static void nfc_command(struct mtd_info *mtd, unsigned int command,
+			     int column, int page_addr)
+{
+	/* We know that an mtd belonging to us is actually only the first
+	 * struct in a multi-struct structure. */
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	/* Save command so that other parts of the API can figure out
+	 * what's actually going on. */
+	info->cmd_cache.command = command;
+
+	/* Configure the NFC for the flash chip in question. */
+	config_nfc(&info->nfc_config, info);
+
+	/* Some commands we execute immediately, while some need to be
+	 * deferred until we have all the data needed, i.e. for page read,
+	 * we can't initiate the read until we know if we are going to be
+	 * using raw mode or not.
+	 */
+	switch (command) {
+	case NAND_CMD_READ0:
+		MTD_TRACE("READ0 page %d, column %d\n", page_addr, column);
+		if (nfc_info->setup->ecc_mode == NAND_ECC_HW) {
+			/* We do not yet know if the caller wants to
+			 * read the page with or without ECC, so we
+			 * just store the page number and main/oob flag
+			 * here.
+			 * (The page number also arrives via the subsequent
+			 * read_page call, so we don't really need to store
+			 * it). */
+			info->cmd_cache.page = page_addr;
+			info->cmd_cache.column = column;
+		} else {
+			/* Read the whole page including oob */
+			info->cmd_cache.oob_required = 1;
+			read_dma(info, page_addr, column, NFC_READ_ALL);
+		}
+		break;
+	case NAND_CMD_READOOB:
+		MTD_TRACE("READOOB page %d, column %d\n", page_addr, column);
+		/* In contrast to READ0, where nand_base always calls
+		 * a read_page_foo function before reading the data,
+		 * for READOOB, read_buf is called instead.
+		 * We don't want the actual read in read_buf, so
+		 * we put it here. */
+		read_dma(info, page_addr, column, NFC_READ_OOB);
+		break;
+	case NAND_CMD_ERASE1:
+		MTD_TRACE("ERASE1 page %d\n", page_addr);
+		/* Just grab page parameter, wait until ERASE2 to do
+		 * something. */
+		info->cmd_cache.page = page_addr;
+		break;
+	case NAND_CMD_ERASE2:
+		MTD_TRACE("ERASE2 page %d, do it\n", info->cmd_cache.page);
+		/* Off we go! */
+		block_erase(info->cmd_cache.page, info->nfc_config.cs);
+		break;
+	case NAND_CMD_RESET:
+		MTD_TRACE("chip reset\n");
+		/* Clear the FIFOs */
+		nfc_write(FIFO_INIT_FIFO_INIT, FIFO_INIT_REG);
+		command_and_wait(COMMAND_RESET,
+				 INT_STATUS_CMD_END_INT_FL);
+		break;
+	case NAND_CMD_SEQIN:
+		MTD_TRACE("SEQIN column %d, page %d\n", column, page_addr);
+		/* Just grab some parameters, then wait until
+		 * PAGEPROG to do the actual operation. */
+		info->cmd_cache.page = page_addr;
+		info->cmd_cache.column = column;
+		info->cmd_cache.write_size = 0; /* bumped by nfc_write_dmabuf */
+		/* Prepare DMA buffer for data. We don't yet know
+		 * how much data there is, so set size to max. */
+		init_dmabuf(DMA_BUF_SIZE);
+		break;
+	case NAND_CMD_PAGEPROG:
+		/* Used for both main area and oob */
+		MTD_TRACE("PAGEPROG page %d, column %d, w/oob %d, raw %d\n",
+			  info->cmd_cache.page, info->cmd_cache.column,
+			  info->cmd_cache.oob_required,
+			  info->cmd_cache.write_raw);
+		write_dma(info, info->cmd_cache.page,
+			  info->cmd_cache.column,
+			  info->cmd_cache.oob_required,
+			  info->cmd_cache.write_raw);
+		break;
+	case NAND_CMD_READID:
+		MTD_TRACE("READID (0x%02x)\n", column);
+
+		/* Read specified ID bytes */
+		/* 0x00 would be NAND_READ_ID_ADDR_STD
+		 * 0x20 would be NAND_READ_ID_ADDR_ONFI
+		 * 0x40 would be NAND_READ_ID_ADDR_JEDEC
+		 * but NAND subsystem knows this and sends us the
+		 * address values directly */
+		nfc_write(column, ADDR0_COL_REG);
+		nfc_write(0, ADDR0_ROW_REG);
+
+		/*
+		 * If the controller is not ready (e.g. no NAND attached), bail
+		 * out to ensure we don't lock up later on.
+		 */
+		if (nfc_read(STATUS_REG) & STATUS_CTRL_STAT)
+			return;
+
+		init_dmabuf(READID_LENGTH);
+		init_dma(nfc_info->dma.phys, READID_LENGTH);
+		nfc_write(READID_LENGTH, DATA_SIZE_REG);
+
+		/* Send read id command */
+		command_and_wait(COMMAND_READ_ID,
+				 INT_STATUS_DMA_INT_FL);
+		break;
+	case NAND_CMD_STATUS:
+		MTD_TRACE("STATUS, defer to later read byte\n");
+		/* Don't do anything now, wait until we need to
+		 * actually read status. */
+		break;
+	case NAND_CMD_PARAM:
+		MTD_TRACE("PARAM (0x%02x)\n", column);
+
+		nfc_write(column, ADDR0_COL_REG);
+		nfc_write(0, ADDR0_ROW_REG);
+
+		init_dmabuf(NAND_PARAM_SIZE_MAX);
+		init_dma(nfc_info->dma.phys, NAND_PARAM_SIZE_MAX);
+		nfc_write(NAND_PARAM_SIZE_MAX, DATA_SIZE_REG);
+
+		command_and_wait(COMMAND_PARAM,
+				 INT_STATUS_DMA_INT_FL);
+		break;
+	default:
+		MTD_TRACE("Unhandled command 0x%02x (col %d, page addr %d)\n",
+			  command, column, page_addr);
+		break;
+	}
+}
+
+/*
+ * Calculate the number of clock cycles that exceeds a time in ps, minus 1.
+ * ALso limit the result so it fits in a specified number of bits.
+ */
+static uint32_t ps_to_cycles(uint64_t clockperiod_ps, uint32_t ps, int maxbits)
+{
+	uint32_t tmp = 0;
+	const uint32_t max = (1 << maxbits) - 1;
+
+	while (ps > clockperiod_ps) {
+		ps -= clockperiod_ps;
+		tmp++;
+		if (tmp == max)
+			return max;
+	}
+
+	return tmp;
+}
+
+static void nfc_program_timings(struct device *dev, uint32_t clkrate, int mode)
+{
+	const struct nand_sdr_timings *t;
+	uint32_t reg, tmp, tCCS;
+	uint64_t clk_period;	/* in pico seconds */
+	uint32_t io = 5000;	/* additional I/O delay */
+
+	/* mode field is a bit mask of supported modes, bit 0 for mode 0,
+	 * bit 1 for mode 1, bit 2 for mode 2, bit 3 for mode 3, etc. */
+	if (mode)
+		mode = fls(mode) - 1;
+
+	t = onfi_async_timing_mode_to_sdr_timings(mode);
+	if (IS_ERR(t)) {
+		dev_err(dev, "Can't get NAND ONFi timings!\n");
+		return;
+	}
+
+	/* 1/pico-second shifted down 8 bits is 3906250000U */
+	clk_period = 3906250000UL / (clkrate / 256);
+
+	tCCS = 5 * t->tWC_min;
+	reg = (ps_to_cycles(clk_period, t->tWHR_min + io, 6) << 24) |
+	      (ps_to_cycles(clk_period, t->tRHW_min + io, 6) << 16) |
+	      (ps_to_cycles(clk_period, t->tADL_min + io, 6) << 8) |
+	       ps_to_cycles(clk_period, tCCS + io, 6);
+	nfc_write(reg, TIME_SEQ_0_REG);
+
+	reg = (ps_to_cycles(clk_period, t->tWW_min + io, 6) << 16) |
+	      (ps_to_cycles(clk_period, t->tRR_min + io, 6) << 8) |
+	       ps_to_cycles(clk_period, t->tWB_max + io, 6);
+	nfc_write(reg, TIME_SEQ_1_REG);
+
+	/* tRWH [7:4]  RE# or WE# high hold time */
+	/* tRWP [3:0]  RE# or WE# pulse width */
+	tmp = max(t->tREH_min, t->tWH_min) + io;
+	reg = ps_to_cycles(clk_period, tmp, 4) << 4;
+	/* Note: tRWP requires an extra cycle */
+	tmp = max(t->tRP_min,  t->tWP_min) + io;
+	tmp = ps_to_cycles(clk_period, tmp, 4) + 1;
+	reg |= min(tmp, (uint32_t)(1 << 4) - 1);
+	nfc_write(reg, TIMINGS_ASYN_REG);
+}
+
+#if !defined(RZN1_NAND_OOB_FS_BYTES)
+#define RZN1_NAND_OOB_FS_BYTES 0
+#warning "RZN1_NAND_OOB_FS_BYTES not defined, assuming 0 bytes for file system"
+#endif
+
+/* Select an appropriate ECC BCH strength */
+static u32 nand_select_ecc(struct mtd_info *mtd, u32 ecc_blksize,
+	u32 oob_reserved)
+{
+	u32 avail = mtd->oobsize - ECC_OFFSET - oob_reserved;
+	u32 bytes_per_codeword = (avail * ecc_blksize) / mtd->writesize;
+	u8 lut[] = { 56, 42, 28, 14, 7, 4 };
+	u8 bch[] = { 32, 24, 16,  8, 4, 2 };
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lut); i++)
+		if (bytes_per_codeword >= lut[i])
+			return bch[i];
+
+	return 0;
+}
+
+static void setup_ecc_layout(struct mtd_info *mtd, struct nand_chip *chip,
+			     struct nand_ecclayout *ecclayout)
+{
+	int i;
+
+	ecclayout->eccbytes = chip->ecc.bytes *
+		(mtd->writesize / chip->ecc.size);
+
+	for (i = 0; i < ecclayout->eccbytes; i++)
+		ecclayout->eccpos[i] = i + ECC_OFFSET;
+
+	/* reserved marker already included in ecclayout->eccbytes */
+	ecclayout->oobfree->offset = ecclayout->eccbytes + ECC_OFFSET;
+
+	/* all OOB bytes from oobfree->offset till end off OOB are free */
+	ecclayout->oobfree->length = mtd->oobsize - ecclayout->oobfree->offset;
+
+	chip->ecc.layout = ecclayout;
+}
+
+/**** Top level probing and device management ****/
+
+/* Get configuration from device tree */
+#ifdef CONFIG_OF
+static int nfc_get_dt_config(struct platform_device *pdev)
+{
+	struct nfc_setup *nfc_setup = dev_get_platdata(&pdev->dev);
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	int res, timings;
+
+	if (!np) {
+		dev_err(dev, "No configuration\n");
+		return -EINVAL;
+	}
+
+	/* ECC parameters */
+	res = of_get_nand_ecc_mode(np);
+	if (res == NAND_ECC_HW || res == NAND_ECC_SOFT_BCH)
+		nfc_setup->ecc_mode = res;
+	else
+		dev_warn(dev, "Unsupported/unset ECC mode, using default\n");
+
+	res = of_get_nand_ecc_strength(np);
+	/* NFC can handle 2 bits but ECC_BYTES macro can't and it's
+	 * highly unlikely we'd ever need to support 2 bits correction
+	 * in practice, so don't allow that case here. */
+	if (res < 0 || (res != 0 && res != 4 && res != 8 && res != 16 &&
+	     res != 24 && res != 32))
+		dev_warn(dev, "Unsupported ECC strength, using default\n");
+	else
+		nfc_setup->ecc_strength = res;
+
+	if (nfc_setup->ecc_strength == 0)
+		dev_info(dev, "ECC strength calculated from OOB size, etc\n");
+
+	res = of_get_nand_ecc_step_size(np);
+	if (res < 0 || (res != 256 && res != 512 && res != 1024))
+		dev_warn(dev, "Unsupported ECC step size, using default\n");
+	else
+		nfc_setup->ecc_blksize = res;
+
+	nfc_setup->on_flash_bbt = of_get_nand_on_flash_bbt(np);
+
+	timings = sizeof(nfc_setup->timings) / sizeof(u32);
+	res = of_property_read_u32_array(np, "timings",
+					 (u32 *)&nfc_setup->timings, timings);
+	if (res < 0) {
+		dev_warn(dev, "NAND timing setup missing, using defaults\n");
+		/* Default values have been set, but we don't know what
+		 * read_u32_array does if it fails during parsing, so reset
+		 * them here again. */
+		memcpy(&nfc_setup->timings, &default_mode0_pll_enabled,
+		       sizeof(nfc_setup->timings));
+	}
+
+	if (of_property_read_bool(np, "use-bank-select"))
+		nfc_setup->use_bank_select = true;
+
+	if (of_property_read_bool(np, "use-wired-select"))
+		nfc_setup->rb_wired_and = true;
+
+	nfc_setup->cs = 0;
+	of_property_read_u32(np, "cs", &nfc_setup->cs);
+
+	nfc_setup->oob_reserved = 0;
+	of_property_read_u32(np, "oob-reserved", &nfc_setup->oob_reserved);
+
+	return 0;
+}
+#else
+static int nfc_get_dt_config(struct platform_device *pdev)
+{
+	return 0;
+}
+#endif
+
+
+/* Per-NAND-chip initialization. */
+static __init
+struct mtd_info *nfc_flash_probe(struct platform_device *pdev,
+				      unsigned bank_no)
+{
+	struct chip_info *this;
+	struct device *dev = &pdev->dev;
+	int pages_per_block, ecc_blksize, ecc_strength;
+	struct nfc_setup *nfc_setup = nfc_info->setup;
+#if !defined(LINUX)
+	(void)dev;
+#endif
+
+	/* Allocate memory for MTD device structure and private data */
+	this = devm_kzalloc(dev, sizeof(struct chip_info), GFP_KERNEL);
+	if (!this)
+		return NULL;
+
+#if defined(LINUX)
+	this->mtd = devm_kzalloc(dev, sizeof(struct mtd_info), GFP_KERNEL);
+	if (!this->mtd)
+		return NULL;
+#else
+	/* Hook into U-Boot data */
+	this->mtd = &this->chip.mtd;
+#endif
+	this->chip.priv = this;
+
+	/* Link the private data with the mtd structure */
+	this->mtd->priv = &this->chip;
+
+	/* Set up basic config for NAND controller hardware */
+
+	/* Device control. */
+	if (nfc_setup->use_bank_select) {
+	/* Separate chips regarded as different banks. */
+	this->nfc_config.mem_ctrl = MEM_CTRL_BANK_SEL(bank_no) | MEM_CTRL_MEM0_WR;
+		this->nfc_config.cs = 0;
+	} else {
+	/* Separate chips regarded as different chip selects. */
+	this->nfc_config.mem_ctrl = MEM_CTRL_MEM_CE(bank_no) | MEM_CTRL_MEM0_WR;
+		this->nfc_config.cs = bank_no;
+	}
+
+	if (nfc_setup->rb_wired_and) {
+		/* Ready/busy from all flash chips wired-AND:ed */
+		this->nfc_config.mem_status_mask = STATUS_MEM_ST(0);
+	} else {
+	/* Ready/busy from nand flash as separate per-device signals */
+	this->nfc_config.mem_status_mask = STATUS_MEM_ST(bank_no);
+	}
+
+	/* Our interface to the mtd API */
+	this->chip.cmdfunc = nfc_command;
+	this->chip.cmd_ctrl = nfc_dummy_cmd_ctrl;
+	this->chip.dev_ready = nfc_dev_ready;
+	this->chip.read_byte = nfc_read_byte;
+	this->chip.read_buf = nfc_read_dmabuf;
+	this->chip.write_buf = nfc_write_dmabuf;
+
+	/* ONFi Mode 0 timings */
+	nfc_program_timings(dev, nfc_info->clk_rate, 0);
+
+	/* Scan to find existence of the device */
+	/* Note that the NFC is not completely set up at this time, but
+	 * that is ok as we only need to identify the device here. */
+	if (nand_scan_ident(this->mtd, 1, NULL))
+		return NULL;
+
+	/* Adjust timing to fastest supported ONFi mode */
+	nfc_program_timings(dev, nfc_info->clk_rate,
+		onfi_get_async_timing_mode(&this->chip));
+
+	/* If the Flash device has on-die ECC and is enabled, we'll simply
+	 * turn off ECC in this driver.
+	 */
+	this->ecc_enabled = !this->chip.ecc_on_chip;
+	if (this->chip.ecc_on_chip)
+		dev_info(dev, "NAND device uses on-die ECC\n");
+
+	/* Select an appropriate ECC BCH strength */
+	ecc_strength = nfc_info->setup->ecc_strength;
+	if (ecc_strength == 0)
+		ecc_strength = nand_select_ecc(this->mtd,
+					nfc_info->setup->ecc_blksize,
+					RZN1_NAND_OOB_FS_BYTES);
+	if (!ecc_strength) {
+		dev_err(dev, "NAND device unusable as OOB is too small!\n");
+		return NULL;
+	}
+
+	/* Set up rest of config for NAND controller hardware */
+
+	/* set ECC block size and pages per block */
+	pages_per_block = this->mtd->erasesize / this->mtd->writesize;
+	ecc_blksize = nfc_info->setup->ecc_blksize;
+	this->nfc_config.control = CONTROL_ECC_BLOCK_SIZE(ecc_blksize) |
+				   CONTROL_BLOCK_SIZE(pages_per_block);
+
+	/* Set up ECC control and offset of ECC data */
+	/* We don't use the threshold capability of the controller, as we
+	 * let mtd handle that, so set the threshold to same as capability. */
+	this->nfc_config.ecc_ctrl = ECC_CTRL_ECC_THRESHOLD(ecc_strength) |
+				    ECC_CTRL_ECC_CAP(ecc_strength);
+
+	/* Since we've now completed the configuration, we need to force it to
+	 * be written to the NFC, else the caching in config_nfc will leave
+	 * the nfc_config values written since nand_scan_ident unwritten. */
+	config_nfc(&this->nfc_config, NULL);
+
+	/* ECC setup */
+
+	/* ECC API */
+	/* Override the following functions when using hardware ECC,
+	 * otherwise we use the defaults set up by nand_base. */
+	if (nfc_info->setup->ecc_mode == NAND_ECC_HW) {
+		this->chip.ecc.read_page = nfc_read_page_hwecc;
+		this->chip.ecc.read_page_raw = nfc_read_page_raw;
+		this->chip.ecc.write_page = nfc_write_page_hwecc;
+		this->chip.ecc.write_page_raw = nfc_write_page_raw;
+	}
+
+	this->chip.ecc.mode = nfc_info->setup->ecc_mode;
+	this->chip.ecc.size = ecc_blksize;
+	this->chip.ecc.strength = ecc_strength;
+	this->chip.ecc.bytes = ECC_BYTES(ecc_strength, ecc_blksize);
+
+	setup_ecc_layout(this->mtd, &this->chip, &eva_oobinfo);
+
+	/* Note that with a device that uses on-die ECC, all of the above
+	 * ECC info is wrong. Since we don't know what bytes are actually
+	 * used by the on-die ECC, we'll leave them as is.
+	 */
+
+	/* We set the bitflip_threshold at 75% of the error correction
+	 * level to get some margin in case bitflips happen in parts of the
+	 * flash that we don't read that often. */
+	/* We add 1 so that an ECC strength of 1 gives us a threshold of 1;
+	 * rather academic though, as we only support BCH anyway... */
+	this->mtd->bitflip_threshold = (ecc_strength + 1) * 3 / 4;
+
+	if (nfc_info->setup->on_flash_bbt)
+		/* Enable the use of a flash based bad block table.
+		 * Since the OOB is not ECC protected we don't put BBT stuff
+		 * there. We also don't mark user-detected badblocks as bad in
+		 * their oob, only in the BBT, to avoid potential chip problems
+		 * when attempting to write bad blocks (writing to bad blocks
+		 * is not recommended according to flash manufacturers). */
+		this->chip.bbt_options = NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB |
+					 NAND_BBT_NO_OOB_BBM;
+
+#if !defined(LINUX)
+	/* Don't generate a BBT at the start, check for BB markers as we go */
+	this->chip.options = NAND_SKIP_BBTSCAN;
+#endif
+
+	this->chip.controller = nfc_info->controller;
+
+	/* Finalize NAND scan, including BBT if requested */
+	if (nand_scan_tail(this->mtd))
+		return NULL;
+
+#if defined(LINUX)
+	this->mtd->dev.parent = &pdev->dev;
+#else
+	if (nand_register(0, this->mtd))
+		return NULL;
+#endif
+
+	return this->mtd;
+}
+
+/* Main probe function. Called to probe and set up device. */
+static int nfc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtd_info *main_mtd;
+	struct nfc_setup *nfc_setup;
+	struct nand_hw_control *controller;
+	int err = 0;
+
+	MTD_TRACE("Initializing Evatronix NANDFLASH-CTRL driver\n");
+
+	/* nfc_info is where we keep runtime information about the NFC */
+	nfc_info = devm_kzalloc(dev, sizeof(*nfc_info), GFP_KERNEL);
+	if (!nfc_info)
+		return -ENOMEM;
+
+	nfc_info->dev = dev;
+
+	/* Set up a controller struct to act as shared lock for all devices */
+	controller = devm_kzalloc(dev, sizeof(*controller), GFP_KERNEL);
+	if (!controller)
+		return -ENOMEM;
+
+	spin_lock_init(&controller->lock);
+	init_waitqueue_head(&controller->wq);
+	nfc_info->controller = controller;
+
+	/* nfc_setup is where we keep settings from DT, in digested form */
+	nfc_setup = devm_kzalloc(dev, sizeof(*nfc_setup), GFP_KERNEL);
+	if (!nfc_setup)
+		return -ENOMEM;
+
+	pdev->dev.platform_data = nfc_setup;
+	nfc_info->setup = nfc_setup;
+
+	/* Default parameters, potentially overridden by DT */
+	nfc_setup->ecc_mode = NAND_ECC_HW;
+	nfc_setup->ecc_strength = 0;	/* calculated */
+	nfc_setup->ecc_blksize = 512;
+	memcpy(&nfc_setup->timings, &default_mode0_pll_enabled,
+	       sizeof(nfc_setup->timings));
+
+	/* Get config from device tree. */
+	err = nfc_get_dt_config(pdev);
+	if (err) {
+		dev_err(dev, "Can't retrieve dt config\n");
+		return err;
+	}
+
+	MTD_TRACE("ECC using %s mode with strength %i and block size %i.\n",
+		nfc_setup->ecc_mode == NAND_ECC_HW ? "hardware" : "software",
+		nfc_setup->ecc_strength, nfc_setup->ecc_blksize);
+
+	/* Initialize interrupts and DMA etc. */
+	err = nfc_init_resources(pdev);
+	if (err)
+		return err;
+
+	setup_nfc_timing(nfc_setup);
+
+#ifndef POLLED_XFERS
+	init_waitqueue_head(&nfc_info->irq.wq);
+#endif
+
+	main_mtd = nfc_flash_probe(pdev, nfc_setup->cs);
+	if (!main_mtd)
+		return -ENXIO;
+
+	return err;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id nfc_id_table[] = {
+	{ .compatible = "evatronix,nandflash-ctrl" },
+	{} /* sentinel */
+};
+MODULE_DEVICE_TABLE(of, nfc_id_table);
+#endif
+
+#if defined(LINUX)
+static struct platform_driver nfc_driver = {
+	.driver = {
+		.name   = "evatronix-nand",
+		.owner  = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(nfc_id_table),
+#endif
+	},
+	.probe = nfc_probe,
+};
+
+module_platform_driver(nfc_driver);
+
+MODULE_AUTHOR("Ricard Wanderlof <ricardw@axis.com>");
+MODULE_DESCRIPTION("Evatronix NANDFLASH-CTRL driver");
+MODULE_LICENSE("GPL v2");
+#else
+/* U-Boot */
+static struct platform_device pdev;
+void board_nand_init(void)
+{
+	if (nfc_probe(&pdev))
+		puts("Cadence NAND init failed\n");
+}
+#endif
diff --git a/drivers/mtd/nand/evatronix_nand.h b/drivers/mtd/nand/evatronix_nand.h
new file mode 100644
index 0000000..4c935e5
--- /dev/null
+++ b/drivers/mtd/nand/evatronix_nand.h
@@ -0,0 +1,417 @@
+/*
+ * evatronix_nand.h - NAND Flash Driver for Evatronix NANDFLASH-CTRL
+ * NAND Flash Controller IP.
+ *
+ * This implementation has been designed against Rev 1.15 of the
+ * NANDFLASH-CTRL Design Specification.
+ *
+ * Copyright (c) 2014 Axis Communication AB, Lund, Sweden.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _EVATRONIX_NAND_H_
+#define  _EVATRONIX_NAND_H_
+
+#include <linux/bitops.h> /* for ffs() */
+
+/* Register offsets for Evatronix NANDFLASH-CTRL IP */
+/* Register field shift values and masks are interespersed as it makes
+ * them easier to locate. */
+/* We use shift values rather than direct masks (e.g. 0x0000d000), as the
+ * hardware manual lists the bit number, making the definitions below
+ * easier to verify against the manual. */
+/* All (known) registers are here, but we only put in the bit fields
+ * for the fields we need. */
+/* We try to be consistent regarding _SIZE/_MASK/_value macros so as to
+ * get a consistent layout here, except for trivial cases where there is
+ * only a single bit or field in a register at bit offset 0. */
+
+#define COMMAND_REG		0x00
+/* The masks reflect the input data to the MAKE_COMMAND macro, rather than
+ * the bits in the register itself. These macros are not intended to be
+ * used by the user, who should use the MAKE_COMMAND et al macros. */
+#define _CMD_SEQ_SHIFT			0
+#define _INPUT_SEL_SHIFT		6
+#define _DATA_SEL_SHIFT			7
+#define _CMD_0_SHIFT			8
+#define _CMD_1_3_SHIFT			16
+#define _CMD_2_SHIFT			24
+
+#define _CMD_SEQ_MASK			0x3f
+#define _INPUT_SEL_MASK			1
+#define _DATA_SEL_MASK			1
+#define _CMD_MASK			0xff /* for all CMD_foo */
+
+#define MAKE_COMMAND(CMD_SEQ, INPUT_SEL, DATA_SEL, CMD_0, CMD_1_3, CMD_2) \
+	((((CMD_SEQ)	& _CMD_SEQ_MASK)	<< _CMD_SEQ_SHIFT)	| \
+	 (((INPUT_SEL)	& _INPUT_SEL_MASK)	<< _INPUT_SEL_SHIFT)	| \
+	 (((DATA_SEL)	& _DATA_SEL_MASK)	<< _DATA_SEL_SHIFT)	| \
+	 (((CMD_0)	& _CMD_MASK)		<< _CMD_0_SHIFT)	| \
+	 (((CMD_1_3)	& _CMD_MASK)		<< _CMD_1_3_SHIFT)	| \
+	 (((CMD_2)	& _CMD_MASK)		<< _CMD_2_SHIFT))
+
+#define INPUT_SEL_SIU			0
+#define INPUT_SEL_DMA			1
+#define DATA_SEL_FIFO			0
+#define DATA_SEL_DATA_REG		1
+
+#define CONTROL_REG		0x04
+#define CONTROL_BLOCK_SIZE_32		(0 << 6)
+#define CONTROL_BLOCK_SIZE_64		(1 << 6)
+#define CONTROL_BLOCK_SIZE_128		(2 << 6)
+#define CONTROL_BLOCK_SIZE_256		(3 << 6)
+#define CONTROL_BLOCK_SIZE(SIZE)	((ffs(SIZE) - 6) << 6)
+#define CONTROL_ECC_EN			(1 << 5)
+#define CONTROL_INT_EN			(1 << 4)
+#define CONTROL_ECC_BLOCK_SIZE_256	(0 << 1)
+#define CONTROL_ECC_BLOCK_SIZE_512	(1 << 1)
+#define CONTROL_ECC_BLOCK_SIZE_1024	(2 << 1)
+#define CONTROL_ECC_BLOCK_SIZE(SIZE)	((ffs(SIZE) - 9) << 1)
+#define STATUS_REG		0x08
+#define STATUS_MEM_ST(CS)		(1 << (CS))
+#define STATUS_CTRL_STAT		(1 << 8)
+#define STATUS_MASK_REG		0x0C
+#define STATE_MASK_SHIFT		0
+#define STATUS_MASK_STATE_MASK(MASK)	(((MASK) & 0xff) << STATE_MASK_SHIFT)
+#define ERROR_MASK_SHIFT		8
+#define STATUS_MASK_ERROR_MASK(MASK)	(((MASK) & 0xff) << ERROR_MASK_SHIFT)
+#define INT_MASK_REG		0x10
+#define INT_MASK_ECC_INT_EN(CS)		(1 << (24 + (CS)))
+#define INT_MASK_STAT_ERR_INT_EN(CS)	(1 << (16 + (CS)))
+#define INT_MASK_MEM_RDY_INT_EN(CS)	(1 << (8 + (CS)))
+#define INT_MASK_DMA_INT_EN		(1 << 3)
+#define INT_MASK_DATA_REG_EN		(1 << 2)
+#define INT_MASK_CMD_END_INT_EN		(1 << 1)
+#define INT_STATUS_REG		0x14
+#define INT_STATUS_ECC_INT_FL(CS)	(1 << (24 + (CS)))
+#define INT_STATUS_STAT_ERR_INT_FL(CS)	(1 << (16 + (CS)))
+#define INT_STATUS_MEM_RDY_INT_FL(CS)	(1 << (8 + (CS)))
+#define INT_STATUS_DMA_INT_FL		(1 << 3)
+#define INT_STATUS_DATA_REG_FL		(1 << 2)
+#define INT_STATUS_CMD_END_INT_FL	(1 << 1)
+#define ECC_CTRL_REG		0x18
+#define ECC_CTRL_ECC_CAP_2		(0 << 0)
+#define ECC_CTRL_ECC_CAP_4		(1 << 0)
+#define ECC_CTRL_ECC_CAP_8		(2 << 0)
+#define ECC_CTRL_ECC_CAP_16		(3 << 0)
+#define ECC_CTRL_ECC_CAP_24		(4 << 0)
+#define ECC_CTRL_ECC_CAP_32		(5 << 0)
+#define ECC_CTRL_ECC_CAP(B)		((B) < 24 ? ffs(B) - 2 : (B) / 6)
+/* # ECC corrections that are acceptable during read before setting OVER flag */
+#define ECC_CTRL_ECC_THRESHOLD(VAL)	(((VAL) & 0x3f) << 8)
+#define ECC_OFFSET_REG		0x1C
+#define ECC_STAT_REG		0x20
+/* Correctable error flag(s) */
+#define ECC_STAT_ERROR(CS)		(1 << (0 + (CS)))
+/* Uncorrectable error flag(s) */
+#define ECC_STAT_UNC(CS)		(1 << (8 + (CS)))
+/* Acceptable errors level overflow flag(s) */
+#define ECC_STAT_OVER(CS)		(1 << (16 + (CS)))
+#define ADDR0_COL_REG		0x24
+#define ADDR0_ROW_REG		0x28
+#define ADDR1_COL_REG		0x2C
+#define ADDR1_ROW_REG		0x30
+#define PROTECT_REG		0x34
+#define FIFO_DATA_REG		0x38
+#define DATA_REG_REG		0x3C
+#define DATA_REG_SIZE_REG	0x40
+#define DATA_REG_SIZE_DATA_REG_SIZE(SIZE) (((SIZE) - 1) & 3)
+#define DEV0_PTR_REG		0x44
+#define DEV1_PTR_REG		0x48
+#define DEV2_PTR_REG		0x4C
+#define DEV3_PTR_REG		0x50
+#define DEV4_PTR_REG		0x54
+#define DEV5_PTR_REG		0x58
+#define DEV6_PTR_REG		0x5C
+#define DEV7_PTR_REG		0x60
+#define DMA_ADDR_L_REG		0x64
+#define DMA_ADDR_H_REG		0x68
+#define DMA_CNT_REG		0x6C
+#define DMA_CTRL_REG		0x70
+#define DMA_CTRL_DMA_START		(1 << 7) /* start on command */
+#define DMA_CTRL_DMA_MODE_SG		(1 << 5) /* scatter/gather mode */
+#define DMA_CTRL_DMA_BURST_I_P_4	(0 << 2) /* incr. precise burst */
+#define DMA_CTRL_DMA_BURST_S_P_16	(1 << 2) /* stream precise burst */
+#define DMA_CTRL_DMA_BURST_SINGLE	(2 << 2) /* single transfer */
+#define DMA_CTRL_DMA_BURST_UNSPEC	(3 << 2) /* burst of unspec. length */
+#define DMA_CTRL_DMA_BURST_I_P_8	(4 << 2) /* incr. precise burst */
+#define DMA_CTRL_DMA_BURST_I_P_16	(5 << 2) /* incr. precise burst */
+#define DMA_CTRL_ERR_FLAG		(1 << 1) /* read only */
+#define DMA_CTRL_DMA_READY		(1 << 0) /* read only */
+#define BBM_CTRL_REG		0x74
+#define MEM_CTRL_REG		0x80
+#define MEM_CTRL_MEM_CE(CE)		(((CE) & 7) << 0)
+#define MEM_CTRL_BANK_SEL(BANK)		(((BANK) & 7) << 16)
+#define MEM_CTRL_MEM0_WR	BIT(8)
+#define DATA_SIZE_REG		0x84
+#define TIMINGS_ASYN_REG	0x88
+#define TIMINGS_SYN_REG		0x8C
+#define TIME_SEQ_0_REG		0x90
+#define TIME_SEQ_1_REG		0x94
+#define TIME_GEN_SEQ_0_REG	0x98
+#define TIME_GEN_SEQ_1_REG	0x9C
+#define TIME_GEN_SEQ_2_REG	0xA0
+#define FIFO_INIT_REG		0xB0
+#define FIFO_INIT_FIFO_INIT			1 /* Flush FIFO */
+#define FIFO_STATE_REG		0xB4
+#define FIFO_STATE_DF_W_EMPTY		(1 << 7)
+#define FIFO_STATE_DF_R_FULL		(1 << 6)
+#define FIFO_STATE_CF_ACCPT_W		(1 << 5)
+#define FIFO_STATE_CF_ACCPT_R		(1 << 4)
+#define FIFO_STATE_CF_FULL		(1 << 3)
+#define FIFO_STATE_CF_EMPTY		(1 << 2)
+#define FIFO_STATE_DF_W_FULL		(1 << 1)
+#define FIFO_STATE_DF_R_EMPTY		(1 << 0)
+#define GEN_SEQ_CTRL_REG	0xB8		/* aka GENERIC_SEQ_CTRL */
+#define _CMD0_EN_SHIFT			0
+#define _CMD1_EN_SHIFT			1
+#define _CMD2_EN_SHIFT			2
+#define _CMD3_EN_SHIFT			3
+#define _COL_A0_SHIFT			4
+#define _COL_A1_SHIFT			6
+#define _ROW_A0_SHIFT			8
+#define _ROW_A1_SHIFT			10
+#define _DATA_EN_SHIFT			12
+#define _DELAY_EN_SHIFT			13
+#define _IMD_SEQ_SHIFT			15
+#define _CMD3_SHIFT			16
+#define ECC_CNT_REG		0x14C
+#define ECC_CNT_ERR_LVL_MASK		0x3F
+
+#define _CMD0_EN_MASK			1
+#define _CMD1_EN_MASK			1
+#define _CMD2_EN_MASK			1
+#define _CMD3_EN_MASK			1
+#define _COL_A0_MASK			3
+#define _COL_A1_MASK			3
+#define _ROW_A0_MASK			3
+#define _ROW_A1_MASK			3
+#define _DATA_EN_MASK			1
+#define _DELAY_EN_MASK			3
+#define _IMD_SEQ_MASK			1
+#define _CMD3_MASK			0xff
+
+/* DELAY_EN field values, non-shifted */
+#define _BUSY_NONE			0
+#define _BUSY_0				1
+#define _BUSY_1				2
+
+/* Slightly confusingly, the DELAYx_EN fields enable BUSY phases. */
+#define MAKE_GEN_CMD(CMD0_EN, CMD1_EN, CMD2_EN, CMD3_EN, \
+		     COL_A0, ROW_A0, COL_A1, ROW_A1, \
+		     DATA_EN, BUSY_EN, IMMEDIATE_SEQ, CMD3) \
+	((((CMD0_EN)	& _CMD0_EN_MASK)	<< _CMD0_EN_SHIFT)	| \
+	 (((CMD1_EN)	& _CMD1_EN_MASK)	<< _CMD1_EN_SHIFT)	| \
+	 (((CMD2_EN)	& _CMD2_EN_MASK)	<< _CMD2_EN_SHIFT)	| \
+	 (((CMD3_EN)	& _CMD3_EN_MASK)	<< _CMD3_EN_SHIFT)	| \
+	 (((COL_A0)	& _COL_A0_MASK)		<< _COL_A0_SHIFT)	| \
+	 (((COL_A1)	& _COL_A1_MASK)		<< _COL_A1_SHIFT)	| \
+	 (((ROW_A0)	& _ROW_A0_MASK)		<< _ROW_A0_SHIFT)	| \
+	 (((ROW_A1)	& _ROW_A1_MASK)		<< _ROW_A1_SHIFT)	| \
+	 (((DATA_EN)	& _DATA_EN_MASK)	<< _DATA_EN_SHIFT)	| \
+	 (((BUSY_EN)	& _DELAY_EN_MASK)	<< _DELAY_EN_SHIFT)	| \
+	 (((IMMEDIATE_SEQ) & _IMD_SEQ_MASK)	<< _IMD_SEQ_SHIFT)	| \
+	 (((CMD3)	& _CMD3_MASK)		<< _CMD3_SHIFT))
+
+/* The sequence encodings are not trivial. The ones we use are listed here. */
+#define _SEQ_0			0x00 /* send one cmd, then wait for ready */
+#define _SEQ_1			0x21 /* send one cmd, one addr, fetch data */
+#define _SEQ_2			0x22 /* send one cmd, one addr, fetch data */
+#define _SEQ_4			0x24 /* single cycle write then read */
+#define _SEQ_10			0x2A /* read page */
+#define _SEQ_12			0x0C /* write page, don't wait for R/B */
+#define _SEQ_18			0x32 /* read page using general cycle */
+#define _SEQ_19			0x13 /* write page using general cycle */
+#define _SEQ_14			0x0E /* 3 address cycles, for block erase */
+
+#define MLUN_REG		0xBC
+#define DEV0_SIZE_REG		0xC0
+#define DEV1_SIZE_REG		0xC4
+#define DEV2_SIZE_REG		0xC8
+#define DEV3_SIZE_REG		0xCC
+#define DEV4_SIZE_REG		0xD0
+#define DEV5_SIZE_REG		0xD4
+#define DEV6_SIZE_REG		0xD8
+#define DEV7_SIZE_REG		0xDC
+#define SS_CCNT0_REG		0xE0
+#define SS_CCNT1_REG		0xE4
+#define SS_SCNT_REG		0xE8
+#define SS_ADDR_DEV_CTRL_REG	0xEC
+#define SS_CMD0_REG		0xF0
+#define SS_CMD1_REG		0xF4
+#define SS_CMD2_REG		0xF8
+#define SS_CMD3_REG		0xFC
+#define SS_ADDR_REG		0x100
+#define SS_MSEL_REG		0x104
+#define SS_REQ_REG		0x108
+#define SS_BRK_REG		0x10C
+#define DMA_TLVL_REG		0x114
+#define DMA_TLVL_MAX		0xFF
+#define AES_CTRL_REG		0x118
+#define AES_DATAW_REG		0x11C
+#define AES_SVECT_REG		0x120
+#define CMD_MARK_REG		0x124
+#define LUN_STATUS_0_REG	0x128
+#define LUN_STATUS_1_REG	0x12C
+#define TIMINGS_TOGGLE_REG	0x130
+#define TIME_GEN_SEQ_3_REG	0x134
+#define SQS_DELAY_REG		0x138
+#define CNE_MASK_REG		0x13C
+#define CNE_VAL_REG		0x140
+#define CNA_CTRL_REG		0x144
+#define INTERNAL_STATUS_REG	0x148
+#define ECC_CNT_REG		0x14C
+#define PARAM_REG_REG		0x150
+#define PARAM_REG_DMA64		(1 << 27)
+
+/* NAND flash command generation */
+
+/* NAND flash command codes */
+#define NAND_RESET		0xff
+#define NAND_READ_STATUS	0x70
+#define NAND_READ_ID		0x90
+#define NAND_READ_ID_ADDR_STD	0x00	/* address written to ADDR0_COL */
+#define NAND_READ_ID_ADDR_ONFI	0x20	/* address written to ADDR0_COL */
+#define NAND_READ_ID_ADDR_JEDEC	0x40	/* address written to ADDR0_COL */
+#define NAND_PARAM		0xEC
+#define NAND_PARAM_SIZE_MAX		768 /* bytes */
+#define NAND_PAGE_READ		0x00
+#define NAND_PAGE_READ_END	0x30
+#define NAND_BLOCK_ERASE	0x60
+#define NAND_BLOCK_ERASE_END	0xd0
+#define NAND_PAGE_WRITE		0x80
+#define NAND_PAGE_WRITE_END	0x10
+
+#define _DONT_CARE 0x00 /* When we don't have anything better to say */
+
+
+/* Assembled values for putting into COMMAND register */
+
+/* Reset NAND flash */
+
+/* Uses SEQ_0: non-directional sequence, single command, wait for ready */
+#define COMMAND_RESET \
+	MAKE_COMMAND(_SEQ_0, INPUT_SEL_SIU, DATA_SEL_FIFO, \
+		NAND_RESET, _DONT_CARE, _DONT_CARE)
+
+/* Read status */
+
+/* Uses SEQ_4: single command, then read data via DATA_REG */
+#define COMMAND_READ_STATUS \
+	MAKE_COMMAND(_SEQ_4, INPUT_SEL_SIU, DATA_SEL_DATA_REG, \
+		NAND_READ_STATUS, _DONT_CARE, _DONT_CARE)
+
+/* Read ID */
+
+/* Uses SEQ_1: single command, ADDR0_COL, then read data via FIFO */
+/* ADDR0_COL is set to NAND_READ_ID_ADDR_STD for non-ONFi, and
+ * NAND_READ_ID_ADDR_ONFI for ONFi.
+ * The controller reads 5 bytes in the non-ONFi case, and 4 bytes in the
+ * ONFi case, so the data reception (DMA or FIFO_REG) needs to be set up
+ * accordingly. */
+#define COMMAND_READ_ID \
+	MAKE_COMMAND(_SEQ_1, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_READ_ID, _DONT_CARE, _DONT_CARE)
+
+#define COMMAND_PARAM \
+	MAKE_COMMAND(_SEQ_2, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PARAM, _DONT_CARE, _DONT_CARE)
+
+/* Page read via slave interface (FIFO_DATA register) */
+
+/* Standard 5-cycle read command, with 0x30 end-of-cycle marker */
+/* Uses SEQ_10: CMD0 + 5 address cycles + CMD2, read data */
+#define COMMAND_READ_PAGE_STD \
+	MAKE_COMMAND(_SEQ_10, INPUT_SEL_SIU, DATA_SEL_FIFO, \
+		NAND_PAGE_READ, _DONT_CARE, NAND_PAGE_READ_END)
+
+/* 4-cycle read command, together with GEN_SEQ_CTRL_READ_PAGE_4CYCLE */
+/* Uses SEQ_18 (generic command sequence, see GEN_SEQ_ECTRL_READ_PAGE_4CYCLE)):
+   CMD0 + 2+2 address cycles + CMD2, read data */
+#define COMMAND_READ_PAGE_GEN \
+	MAKE_COMMAND(_SEQ_18, INPUT_SEL_SIU, DATA_SEL_FIFO, \
+		NAND_PAGE_READ, _DONT_CARE, NAND_PAGE_READ_END)
+
+/* Page read via master interface (DMA) */
+
+/* Standard 5-cycle read command, with 0x30 end-of-cycle marker */
+/* Uses SEQ_10: CMD0 + 5 address cycles + CMD2, read data */
+#define COMMAND_READ_PAGE_DMA_STD \
+	MAKE_COMMAND(_SEQ_10, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PAGE_READ, _DONT_CARE, NAND_PAGE_READ_END)
+
+/* 4-cycle read command, together with GEN_SEQ_CTRL_READ_PAGE_4CYCLE */
+/* Uses SEQ_18 (generic command sequence, see GEN_SEQ_ECTRL_READ_PAGE_4CYCLE)):
+   CMD0 + 2+2 address cycles + CMD2, read data */
+#define COMMAND_READ_PAGE_DMA_GEN \
+	MAKE_COMMAND(_SEQ_18, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PAGE_READ, _DONT_CARE, NAND_PAGE_READ_END)
+
+/* Page write via master interface (DMA) */
+
+/* Uses SEQ_12: CMD0 + 5 address cycles + write data + CMD1 */
+#define COMMAND_WRITE_PAGE_DMA_STD \
+	MAKE_COMMAND(_SEQ_12, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PAGE_WRITE, NAND_PAGE_WRITE_END, _DONT_CARE)
+
+/* Uses SEQ_19: CMD0 + 4 address cycles + write data + CMD1 */
+#define COMMAND_WRITE_PAGE_DMA_GEN \
+	MAKE_COMMAND(_SEQ_19, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PAGE_WRITE, NAND_PAGE_WRITE_END, _DONT_CARE)
+
+/* Block erase */
+
+/* Uses SEQ_14: CMD0 + 3 address cycles + CMD1 */
+#define COMMAND_BLOCK_ERASE \
+	MAKE_COMMAND(_SEQ_14, INPUT_SEL_SIU, DATA_SEL_FIFO, \
+		NAND_BLOCK_ERASE, NAND_BLOCK_ERASE_END, _DONT_CARE)
+
+/* Assembled values for putting into GEN_SEQ_CTRL register */
+
+/* General command sequence specification for 4 cycle PAGE_READ command */
+#define GEN_SEQ_CTRL_READ_PAGE_4CYCLE \
+	MAKE_GEN_CMD(1, 0, 1, 0,	/* enable command 0 and 2 phases */ \
+		     2, 2,		/* col A0 2 cycles, row A0 2 cycles */ \
+		     0, 0,		/* col A1, row A1 not used */ \
+		     1,			/* data phase enabled */ \
+		     _BUSY_0,		/* busy0 phase enabled */ \
+		     0,			/* immediate cmd execution disabled */ \
+		     _DONT_CARE)	/* command 3 code not needed */
+
+/* General command sequence specification for 4 cycle PAGE_PROGRAM command */
+#define GEN_SEQ_CTRL_WRITE_PAGE_4CYCLE \
+	MAKE_GEN_CMD(1, 1, 0, 0,	/* enable command 0 and 1 phases */ \
+		     2, 2,		/* col A0 2 cycles, row A0 2 cycles */ \
+		     0, 0,		/* col A1, row A1 not used */ \
+		     1,			/* data phase enabled */ \
+		     _BUSY_1,		/* busy1 phase enabled */ \
+		     0,			/* immediate cmd execution disabled */ \
+		     _DONT_CARE)	/* command 3 code not needed */
+
+/* BCH ECC size calculations. Should really go somewhere else? */
+/* From "Mr. NAND's Wild Ride: Warning: Suprises Ahead", by Robert Pierce,
+ * Denali Software Inc. 2009, table on page 5 */
+/* Use 8 bit correction as base. */
+#define ECC8_BYTES(BLKSIZE) (ffs(BLKSIZE) + 3)
+/* The following would be valid for 4..24 bits of correction. */
+#define ECC_BYTES_PACKED(CAP, BLKSIZE) ((ECC8_BYTES(BLKSIZE) * (CAP) + 7) / 8)
+/* Our hardware however requires more bytes than strictly necessary due to
+ * the internal design. */
+#define ECC_BYTES(CAP, BLKSIZE) ((ECC8_BYTES(1024) * (CAP) + 7) / 8)
+
+/* Due to the way mtd interracts with the driver we need to know the maximum
+ * number of bytes of data that is read by the READID and PARAM commands. */
+#define MAX_READID_DATA 8
+#define MAX_PARAM_DATA 768
+
+#endif /* _EVATRONIX_NAND_H_ */
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index d9e5fc9..168c600 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -3735,6 +3735,34 @@ ident_done:
 	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
 		chip->cmdfunc = nand_command_lp;
 
+	/* Determine if the device has on-chip ECC and is enabled */
+	if (chip->onfi_params.jedec_id == NAND_MFR_MICRON) {
+		switch (id_data[1])
+		{
+		case 0xf1:	/* MT29F1G08ABADA */
+		case 0xa1:	/* MT29F1G08ABBDA */
+		case 0xb1:	/* MT29F1G16ABBDA */
+
+		case 0xaa:	/* MT29F2G08ABBEA */
+		case 0xba:	/* MT29F2G16ABBEA */
+		case 0xda:	/* MT29F2G08ABAEA */
+		case 0xca:	/* MT29F2G16ABAEA */
+
+		case 0xdc:	/* MT29F4G08ABADA */
+		case 0xcc:	/* MT29F4G16ABADA */
+		case 0xac:	/* MT29F4G08ABBDA */
+		case 0xbc:	/* MT29F4G16ABBDA */
+		case 0xa3:	/* MT29F8G08ADBDA */
+		case 0xb3:	/* MT29F8G16ADBDA */
+		case 0xd3:	/* MT29F8G08ADADA / MT29F16G08AJADA */
+		case 0xc3:	/* MT29F8G16ADADA */
+
+			if (id_data[4] & 0x80) 
+				chip->ecc_on_chip = 1;
+			break;
+		}
+	}
+
 	pr_info("device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\n",
 		*maf_id, *dev_id);
 
diff --git a/drivers/mtd/nand/nand_spl_load.c b/drivers/mtd/nand/nand_spl_load.c
index 5a25644..26af30d 100644
--- a/drivers/mtd/nand/nand_spl_load.c
+++ b/drivers/mtd/nand/nand_spl_load.c
@@ -15,15 +15,18 @@
  */
 void nand_boot(void)
 {
+#ifdef CONFIG_SYS_NAND_U_BOOT_START
 	__attribute__((noreturn)) void (*uboot)(void);
+#endif
 
 	/*
 	 * Load U-Boot image from NAND into RAM
 	 */
+#ifdef CONFIG_SYS_NAND_U_BOOT_DST
 	nand_spl_load_image(CONFIG_SYS_NAND_U_BOOT_OFFS,
 			CONFIG_SYS_NAND_U_BOOT_SIZE,
 			(void *)CONFIG_SYS_NAND_U_BOOT_DST);
-
+#endif
 #ifdef CONFIG_NAND_ENV_DST
 	nand_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
 			(void *)CONFIG_NAND_ENV_DST);
@@ -37,6 +40,8 @@ void nand_boot(void)
 	/*
 	 * Jump to U-Boot image
 	 */
+#ifdef CONFIG_SYS_NAND_U_BOOT_START
 	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
 	(*uboot)();
+#endif
 }
diff --git a/drivers/mtd/nand/nand_spl_onfi.c b/drivers/mtd/nand/nand_spl_onfi.c
new file mode 100644
index 0000000..07f278b
--- /dev/null
+++ b/drivers/mtd/nand/nand_spl_onfi.c
@@ -0,0 +1,209 @@
+/*
+ * Generic ONFi code for SPL.
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe Ltd
+ *
+ * Parts based on drivers/mtd/nand/mxs_nand_spl.c
+ * Copyright (C) 2014 Gateworks Corporation
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <nand.h>
+
+struct mtd_info nand_info_data;
+struct mtd_info *nand_info[1] = { &nand_info_data };
+
+/* Generic SPL functions below */
+int nand_scan_ident(struct mtd_info *mtd, int max_chips,
+		    struct nand_flash_dev *table)
+{
+	struct nand_chip *chip = mtd->priv;
+	int i;
+	u8 mfg_id, dev_id;
+	u8 id_data[8];
+	struct nand_onfi_params *p = &chip->onfi_params;
+
+	/* Reset the chip */
+	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+	/* Send the command for reading device ID */
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+	mfg_id = chip->read_byte(mtd);
+	dev_id = chip->read_byte(mtd);
+
+	/* Try again to make sure */
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+	for (i = 0; i < 8; i++)
+		id_data[i] = chip->read_byte(mtd);
+	if (id_data[0] != mfg_id || id_data[1] != dev_id) {
+		debug("NAND second ID read did not match");
+		return -EIO;
+	}
+	debug("READID is 0x%02x:0x%02x\n", mfg_id, dev_id);
+
+	/* read ONFI */
+	chip->onfi_version = 1;
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);
+	if (chip->read_byte(mtd) != 'O' || chip->read_byte(mtd) != 'N' ||
+	    chip->read_byte(mtd) != 'F' || chip->read_byte(mtd) != 'I') {
+		debug("NAND not ONFi device");
+		return -EIO;
+	}
+
+	/* we have ONFI, probe it */
+	chip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);
+	chip->read_buf(mtd, (uint8_t *)p, sizeof(*p));
+	mtd->name = p->model;
+	mtd->writesize = le32_to_cpu(p->byte_per_page);
+	mtd->erasesize = le32_to_cpu(p->pages_per_block) * mtd->writesize;
+	mtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);
+	chip->chipsize = le32_to_cpu(p->blocks_per_lun);
+	chip->chipsize *= (uint64_t)mtd->erasesize * p->lun_count;
+	/* Calculate the address shift from the page size */
+	chip->page_shift = ffs(mtd->writesize) - 1;
+	chip->phys_erase_shift = ffs(mtd->erasesize) - 1;
+	/* Convert chipsize to number of pages per chip -1 */
+	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;
+	chip->badblockbits = 16;
+
+	debug("erasesize=%d (>>%d)\n", mtd->erasesize, chip->phys_erase_shift);
+	debug("writesize=%d (>>%d)\n", mtd->writesize, chip->page_shift);
+	debug("oobsize=%d\n", mtd->oobsize);
+	debug("chipsize=%lld\n", chip->chipsize);
+
+	return 0;
+}
+
+int nand_scan_tail(struct mtd_info *mtd)
+{
+	return 0;
+}
+
+int nand_register(int devnum, struct mtd_info *mtd)
+{
+	return 0;
+}
+
+int nand_default_bbt(struct mtd_info *mtd)
+{
+	return 0;
+}
+
+void nand_deselect(void)
+{
+}
+
+void nand_init(void)
+{
+	struct mtd_info *mtd = nand_info[0];
+	struct nand_chip *chip;
+
+	board_nand_init();
+
+	chip = mtd->priv;
+
+	chip->numchips = 1;
+
+	/* SPL uses own buffers */
+	chip->buffers = NULL;
+	chip->oob_poi = NULL;
+
+	/* setup flash layout (does not scan as we override that) */
+	mtd->size = chip->chipsize;
+
+	debug("NAND %llu MiB\n", (mtd->size / (1024 * 1024)));
+}
+
+static int spl_read_page_ecc(struct mtd_info *mtd, void *buf, unsigned int page)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret;
+
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0x0, page);
+	ret = chip->ecc.read_page(mtd, chip, buf, 0, page);
+	if (ret < 0) {
+		debug("NAND read_page failed %d\n", ret);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int spl_is_badblock(struct mtd_info *mtd, int page)
+{
+	register struct nand_chip *chip = mtd->priv;
+	uint16_t oob = 0;
+
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+	chip->read_buf(mtd, (uint8_t *)&oob, 2);
+	debug("%s page:%d oob = 0x%04X\n", __func__, page, oob);
+
+	return oob != 0xffff;
+}
+
+int nand_spl_load_image(uint32_t offs, unsigned int size, void *buf)
+{
+	struct mtd_info *mtd = nand_info[0];
+	struct nand_chip *chip = mtd->priv;
+	unsigned int page;
+	unsigned int nand_page_per_block;
+	unsigned int sz = 0;
+	uint32_t data_offs;
+
+	page = offs >> chip->page_shift;
+	nand_page_per_block = mtd->erasesize / mtd->writesize;
+
+	debug("%s offset:0x%08x len:%d page:%d\n", __func__, offs, size, page);
+
+	/* Read first page */
+	if (spl_read_page_ecc(mtd, buf, page) < 0)
+		return -EIO;
+	page++;
+
+	/* If the caller passed in an offset that is not page aligned, we would
+	 * have read from an offset that is page aligned. Therefore, deal
+	 * with it by moving the data in the output buffer.
+	 */
+	data_offs = offs & ((1 << chip->page_shift) - 1);
+	sz = mtd->writesize - data_offs;
+	if (data_offs) {
+		u8 *buf8 = buf;
+		unsigned int i;
+		for (i = 0; i < sz; i++) {
+			*buf8 = *(buf8 + data_offs);
+			buf8++;
+		}
+	}
+	buf += sz;
+
+	size = roundup(size, mtd->writesize);
+	while (sz < size) {
+		if (spl_read_page_ecc(mtd, buf, page) < 0)
+			return -EIO;
+		sz += mtd->writesize;
+		buf += mtd->writesize;
+		page++;
+
+		/*
+		 * Check if we have crossed a block boundary, and if so
+		 * check for bad block.
+		 */
+		if (!(page % nand_page_per_block)) {
+			/*
+			 * Yes, new block. See if this block is good. If not,
+			 * loop until we find a good block.
+			 */
+			while (spl_is_badblock(mtd, page)) {
+				page = page + nand_page_per_block;
+				/* Check if we've reached the end of flash. */
+				if (page >= mtd->size >> chip->page_shift)
+					return -ENOMEM;
+			}
+		}
+	}
+
+	return 0;
+}
diff --git a/drivers/mtd/spi/sf_internal.h b/drivers/mtd/spi/sf_internal.h
index 839cdbe..0fb725b 100644
--- a/drivers/mtd/spi/sf_internal.h
+++ b/drivers/mtd/spi/sf_internal.h
@@ -27,7 +27,8 @@ enum spi_nor_option_flags {
 };
 
 #define SPI_FLASH_3B_ADDR_LEN		3
-#define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_3B_ADDR_LEN)
+#define SPI_FLASH_4B_ADDR_LEN		4
+#define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_4B_ADDR_LEN)
 #define SPI_FLASH_16MB_BOUN		0x1000000
 
 /* CFI Manufacture ID's */
@@ -57,6 +58,12 @@ enum spi_nor_option_flags {
 #define CMD_READ_DUAL_IO_FAST		0xbb
 #define CMD_READ_QUAD_OUTPUT_FAST	0x6b
 #define CMD_READ_QUAD_IO_FAST		0xeb
+#define CMD_READ_ARRAY_SLOW_4B		0x13
+#define CMD_READ_ARRAY_FAST_4B		0x0c
+#define CMD_READ_DUAL_OUTPUT_FAST_4B	0x3c
+#define CMD_READ_DUAL_IO_FAST_4B	0xbc
+#define CMD_READ_QUAD_OUTPUT_FAST_4B	0x6c
+#define CMD_READ_QUAD_IO_FAST_4B	0xec
 #define CMD_READ_ID			0x9f
 #define CMD_READ_STATUS			0x05
 #define CMD_READ_STATUS1		0x35
@@ -69,6 +76,8 @@ enum spi_nor_option_flags {
 # define CMD_BANKADDR_BRRD		0x16
 # define CMD_EXTNADDR_WREAR		0xC5
 # define CMD_EXTNADDR_RDEAR		0xC8
+# define CMD_ENTER_4B_ADDRESSING	0xB7
+# define CMD_EXIT_4B_ADDRESSING		0xE9
 #endif
 
 /* Common status */
diff --git a/drivers/mtd/spi/sf_probe.c b/drivers/mtd/spi/sf_probe.c
index 7b29637..676b1df 100644
--- a/drivers/mtd/spi/sf_probe.c
+++ b/drivers/mtd/spi/sf_probe.c
@@ -119,6 +119,7 @@ static int spi_flash_std_read(struct udevice *dev, u32 offset, size_t len,
 	return spi_flash_cmd_read_ops(flash, offset, len, buf);
 }
 
+#if !defined(CONFIG_SPL_BUILD)
 static int spi_flash_std_write(struct udevice *dev, u32 offset, size_t len,
 			const void *buf)
 {
@@ -142,6 +143,7 @@ static int spi_flash_std_erase(struct udevice *dev, u32 offset, size_t len)
 
 	return spi_flash_cmd_erase_ops(flash, offset, len);
 }
+#endif
 
 static int spi_flash_std_probe(struct udevice *dev)
 {
@@ -158,8 +160,10 @@ static int spi_flash_std_probe(struct udevice *dev)
 
 static const struct dm_spi_flash_ops spi_flash_std_ops = {
 	.read = spi_flash_std_read,
+#if !defined(CONFIG_SPL_BUILD)
 	.write = spi_flash_std_write,
 	.erase = spi_flash_std_erase,
+#endif
 };
 
 static const struct udevice_id spi_flash_std_ids[] = {
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index 2e378dc..fb3a3f4 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -22,12 +22,23 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-static void spi_flash_addr(u32 addr, u8 *cmd)
+#if !defined(CONFIG_SPI_FLASH_READ_QUAD_CMD)
+#define CONFIG_SPI_FLASH_READ_QUAD_CMD CMD_READ_QUAD_OUTPUT_FAST
+#endif
+
+static void spi_flash_addr(struct spi_flash *flash, u32 addr, u8 *cmd)
 {
 	/* cmd[0] is actual command */
-	cmd[1] = addr >> 16;
-	cmd[2] = addr >> 8;
-	cmd[3] = addr >> 0;
+	if (flash->spi->addressing_bytes == 4) {
+		cmd[1] = addr >> 24;
+		cmd[2] = addr >> 16;
+		cmd[3] = addr >> 8;
+		cmd[4] = addr >> 0;
+	} else {
+		cmd[1] = addr >> 16;
+		cmd[2] = addr >> 8;
+		cmd[3] = addr >> 0;
+	}
 }
 
 static int read_sr(struct spi_flash *flash, u8 *rs)
@@ -139,9 +150,35 @@ static int read_bar(struct spi_flash *flash, const struct spi_flash_info *info)
 	u8 curr_bank = 0;
 	int ret;
 
+	flash->spi->addressing_bytes = 3;
+
 	if (flash->size <= SPI_FLASH_16MB_BOUN)
 		goto bar_end;
 
+	if (flash->memory_map) {
+		u8 cmd, data;
+
+		/* Switch to 4-byte addressing mode */
+		flash->spi->addressing_bytes = 4;
+
+		/* For Spansion, send Bank Write command with ExtAdd set */
+		cmd = CMD_BANKADDR_BRWR;
+		data = 0x80;
+		ret = spi_flash_cmd_write(flash->spi, &cmd, 1, &data, 1);
+		if (ret) {
+			debug("SF: fail to set 4-byte addressing (Spansion)\n");
+			return ret;
+		}
+
+		/* Everyone else reponds to 0xb7 command */
+		cmd = CMD_ENTER_4B_ADDRESSING;
+		ret = spi_flash_cmd_write(flash->spi, &cmd, 1, NULL, 0);
+		if (ret) {
+			debug("SF: fail to set 4-byte addressing\n");
+			return ret;
+		}
+	}
+
 	switch (JEDEC_MFR(info)) {
 	case SPI_FLASH_CFI_MFR_SPANSION:
 		flash->bank_read_cmd = CMD_BANKADDR_BRRD;
@@ -291,6 +328,7 @@ int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
 	return ret;
 }
 
+#if !defined(CONFIG_SPL_BUILD)
 int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 {
 	u32 erase_size, erase_addr;
@@ -313,6 +351,8 @@ int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 
 	cmd[0] = flash->erase_cmd;
 	while (len) {
+		u8 cmd_len = SPI_FLASH_CMD_LEN;
+
 		erase_addr = offset;
 
 #ifdef CONFIG_SF_DUAL_FLASH
@@ -320,16 +360,20 @@ int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 			spi_flash_dual(flash, &erase_addr);
 #endif
 #ifdef CONFIG_SPI_FLASH_BAR
-		ret = write_bar(flash, erase_addr);
-		if (ret < 0)
-			return ret;
+		if (flash->spi->addressing_bytes == 3) {
+			ret = write_bar(flash, erase_addr);
+			if (ret < 0)
+				return ret;
+		}
 #endif
-		spi_flash_addr(erase_addr, cmd);
+		spi_flash_addr(flash, erase_addr, cmd);
+		if (flash->spi->addressing_bytes == 3)
+			cmd_len--;
 
 		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
 		      cmd[2], cmd[3], erase_addr);
 
-		ret = spi_flash_write_common(flash, cmd, sizeof(cmd), NULL, 0);
+		ret = spi_flash_write_common(flash, cmd, cmd_len, NULL, 0);
 		if (ret < 0) {
 			debug("SF: erase failed\n");
 			break;
@@ -351,6 +395,30 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 	size_t chunk_len, actual;
 	u8 cmd[SPI_FLASH_CMD_LEN];
 	int ret = -1;
+	unsigned long timeout = SPI_FLASH_PROG_TIMEOUT;
+
+	/* Handle memory-mapped SPI */
+	if (flash->memory_map_write) {
+		ret = spi_claim_bus(flash->spi);
+		if (ret) {
+			debug("SF: unable to claim SPI bus\n");
+			return ret;
+		}
+		spi_xfer(flash->spi, 0, NULL, NULL, SPI_XFER_MMAP_WRITE);
+		memcpy(flash->memory_map_write + offset, buf, len);
+		spi_xfer(flash->spi, 0, NULL, NULL, SPI_XFER_MMAP_END);
+
+		ret = spi_flash_wait_till_ready(flash, timeout);
+		if (ret < 0) {
+			debug("SF: write %s timed out\n",
+			      timeout == SPI_FLASH_PROG_TIMEOUT ?
+				"program" : "page erase");
+			return ret;
+		}
+
+		spi_release_bus(flash->spi);
+		return 0;
+	}
 
 	page_size = flash->page_size;
 
@@ -364,6 +432,7 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 
 	cmd[0] = flash->write_cmd;
 	for (actual = 0; actual < len; actual += chunk_len) {
+		u8 cmd_len = SPI_FLASH_CMD_LEN;
 		write_addr = offset;
 
 #ifdef CONFIG_SF_DUAL_FLASH
@@ -382,12 +451,14 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 			chunk_len = min(chunk_len,
 					(size_t)spi->max_write_size);
 
-		spi_flash_addr(write_addr, cmd);
+		spi_flash_addr(flash, write_addr, cmd);
+		if (flash->spi->addressing_bytes == 3)
+			cmd_len--;
 
 		debug("SF: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %zu\n",
 		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
 
-		ret = spi_flash_write_common(flash, cmd, sizeof(cmd),
+		ret = spi_flash_write_common(flash, cmd, cmd_len,
 					buf + actual, chunk_len);
 		if (ret < 0) {
 			debug("SF: write failed\n");
@@ -399,6 +470,7 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 
 	return ret;
 }
+#endif /* !defined(CONFIG_SPL_BUILD) */
 
 int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
 		size_t cmd_len, void *data, size_t data_len)
@@ -468,6 +540,7 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 
 	cmd[0] = flash->read_cmd;
 	while (len) {
+		cmdsz = SPI_FLASH_CMD_LEN + flash->dummy_byte;
 		read_addr = offset;
 
 #ifdef CONFIG_SF_DUAL_FLASH
@@ -487,7 +560,9 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		else
 			read_len = remain_len;
 
-		spi_flash_addr(read_addr, cmd);
+		spi_flash_addr(flash, read_addr, cmd);
+		if (flash->spi->addressing_bytes == 3)
+			cmdsz--;
 
 		ret = spi_flash_read_common(flash, cmd, cmdsz, data, read_len);
 		if (ret < 0) {
@@ -932,6 +1007,9 @@ int spi_flash_decode_fdt(const void *blob, struct spi_flash *flash)
 		return -1;
 	}
 	flash->memory_map = map_sysmem(addr, size);
+
+	if (fdtdec_get_bool(blob, node, "memory-map-write"))
+		flash->memory_map_write = flash->memory_map;
 #endif
 
 	return 0;
@@ -1026,7 +1104,7 @@ int spi_flash_scan(struct spi_flash *flash)
 	if (spi->mode & SPI_RX_SLOW)
 		flash->read_cmd = CMD_READ_ARRAY_SLOW;
 	else if (spi->mode & SPI_RX_QUAD && info->flags & RD_QUAD)
-		flash->read_cmd = CMD_READ_QUAD_OUTPUT_FAST;
+		flash->read_cmd = CONFIG_SPI_FLASH_READ_QUAD_CMD;
 	else if (spi->mode & SPI_RX_DUAL && info->flags & RD_DUAL)
 		flash->read_cmd = CMD_READ_DUAL_OUTPUT_FAST;
 
@@ -1068,11 +1146,38 @@ int spi_flash_scan(struct spi_flash *flash)
 		flash->dummy_byte = 1;
 	}
 
+	/* Equivalent number of dummy cycles to above calculation */
+	flash->dummy_cycles = 8;
+
+	/* Most SPI Flash devices require a different number of dummy cycles
+	 * for operation at higher clock rates, or can operate at lower clock
+	 * rates with fewer dummy cycles. It may not be possible to represent
+	 * the required number of dummy cycles as dummy bytes.
+	 * Therefore, allow it to be specified for drivers that support it.
+	 * This assumes that you will only be accessing a single SF device.
+	 */
+#if defined(CONFIG_SPI_FLASH_DUMMY_CYCLES)
+ #ifdef CONFIG_SPL_BUILD
+	flash->dummy_cycles = CONFIG_SPI_FLASH_DUMMY_CYCLES;
+ #else
+	flash->dummy_cycles = getenv_ulong("sf_dummy_clks", 10,
+			CONFIG_SPI_FLASH_DUMMY_CYCLES);
+ #endif	/* CONFIG_SPL_BUILD */
+#endif
+
 #ifdef CONFIG_SPI_FLASH_STMICRO
 	if (info->flags & E_FSR)
 		flash->flags |= SNOR_F_USE_FSR;
 #endif
 
+#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
+	ret = spi_flash_decode_fdt(gd->fdt_blob, flash);
+	if (ret) {
+		debug("SF: FDT decode error\n");
+		return -EINVAL;
+	}
+#endif
+
 	/* Configure the BAR - discover bank cmds and read current bank */
 #ifdef CONFIG_SPI_FLASH_BAR
 	ret = read_bar(flash, info);
@@ -1080,12 +1185,14 @@ int spi_flash_scan(struct spi_flash *flash)
 		return ret;
 #endif
 
-#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
-	ret = spi_flash_decode_fdt(gd->fdt_blob, flash);
-	if (ret) {
-		debug("SF: FDT decode error\n");
-		return -EINVAL;
-	}
+#ifdef CONFIG_SPI_REGISTER_FLASH
+	/*
+	 * 'clever' SPI controllers that are dedicated to flashes and QSPI
+	 * flashes needs to know all sort of parameters, like the quad mode,
+	 * number of dummy bytes and so on. Therefore we 'register' the flash
+	 * with the slave to give it a chance to keep it around
+	 */
+	spi_slave_register_flash(flash);
 #endif
 
 #ifndef CONFIG_SPL_BUILD
diff --git a/drivers/mtd/spi/spi_flash_ids.c b/drivers/mtd/spi/spi_flash_ids.c
index edca94e..e31131e 100644
--- a/drivers/mtd/spi/spi_flash_ids.c
+++ b/drivers/mtd/spi/spi_flash_ids.c
@@ -123,8 +123,8 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"n25q32a",	   INFO(0x20bb16, 0x0,  64 * 1024,    64, RD_FULL | WR_QPP | SECT_4K) },
 	{"n25q64",	   INFO(0x20ba17, 0x0,  64 * 1024,   128, RD_FULL | WR_QPP | SECT_4K) },
 	{"n25q64a",	   INFO(0x20bb17, 0x0,  64 * 1024,   128, RD_FULL | WR_QPP | SECT_4K) },
-	{"n25q128",	   INFO(0x20ba18, 0x0,  64 * 1024,   256, RD_FULL | WR_QPP) },
-	{"n25q128a",	   INFO(0x20bb18, 0x0,  64 * 1024,   256, RD_FULL | WR_QPP) },
+	{"n25q128",	   INFO(0x20ba18, 0x0,  64 * 1024,   256, RD_FULL | WR_QPP | SECT_4K) },
+	{"n25q128a",	   INFO(0x20bb18, 0x0,  64 * 1024,   256, RD_FULL | WR_QPP | SECT_4K) },
 	{"n25q256",	   INFO(0x20ba19, 0x0,  64 * 1024,   512, RD_FULL | WR_QPP | SECT_4K) },
 	{"n25q256a",	   INFO(0x20bb19, 0x0,  64 * 1024,   512, RD_FULL | WR_QPP | SECT_4K) },
 	{"n25q512",	   INFO(0x20ba20, 0x0,  64 * 1024,  1024, RD_FULL | WR_QPP | E_FSR | SECT_4K) },
diff --git a/drivers/net/designware.c b/drivers/net/designware.c
index 9e6d726..8305ef2 100644
--- a/drivers/net/designware.c
+++ b/drivers/net/designware.c
@@ -269,6 +269,12 @@ static void _dw_eth_halt(struct dw_eth_dev *priv)
 	phy_shutdown(priv->phydev);
 }
 
+int __attribute__((weak)) phy_adjust_link_notifier(struct phy_device *phydev)
+{
+	/* nothing to do here */
+	return 0;
+}
+
 static int _dw_eth_init(struct dw_eth_dev *priv, u8 *enetaddr)
 {
 	struct eth_mac_regs *mac_p = priv->mac_regs_p;
@@ -321,11 +327,29 @@ static int _dw_eth_init(struct dw_eth_dev *priv, u8 *enetaddr)
 		return ret;
 	}
 
-	dw_adjust_link(mac_p, priv->phydev);
+	/* Fixed link? */
+	if (priv->fixed_link_speed) {
+		u32 conf = readl(&mac_p->conf) | FRAMEBURSTENABLE | DISABLERXOWN;
+
+		if (priv->fixed_link_speed != 1000)
+			conf |= MII_PORTSELECT;
+
+		if (priv->fixed_link_speed == 100)
+			conf |= FES_100;
+
+		conf |= FULLDPLXMODE;
+
+		writel(conf, &mac_p->conf);
+	} else {
+		dw_adjust_link(mac_p, priv->phydev);
+	}
 
 	if (!priv->phydev->link)
 		return -EIO;
 
+	if (phy_adjust_link_notifier(priv->phydev) < 0)
+		return -1;
+
 	writel(readl(&mac_p->conf) | RXENABLE | TXENABLE, &mac_p->conf);
 
 	return 0;
@@ -457,6 +481,15 @@ static int dw_phy_init(struct dw_eth_dev *priv, void *dev)
 	mask = 1 << CONFIG_PHY_ADDR;
 #endif
 
+#ifndef CONFIG_DM_ETH
+	struct eth_device *edev = (struct eth_device *)dev;
+
+#ifdef CONFIG_PHY1_ADDR
+	if (edev->index == 1)
+		mask = 1 << CONFIG_PHY1_ADDR;
+#endif
+#endif
+
 	phydev = phy_find_by_mask(priv->bus, mask, priv->interface);
 	if (!phydev)
 		return -ENODEV;
@@ -513,7 +546,7 @@ static int dw_write_hwaddr(struct eth_device *dev)
 	return _dw_write_hwaddr(dev->priv, dev->enetaddr);
 }
 
-int designware_initialize(ulong base_addr, u32 interface)
+int designware_initialize_fixed_link(ulong base_addr, u32 interface, int speed)
 {
 	struct eth_device *dev;
 	struct dw_eth_dev *priv;
@@ -559,12 +592,18 @@ int designware_initialize(ulong base_addr, u32 interface)
 	eth_register(dev);
 
 	priv->interface = interface;
+	priv->fixed_link_speed = speed;
 
 	dw_mdio_init(dev->name, priv->mac_regs_p);
 	priv->bus = miiphy_get_dev_by_name(dev->name);
 
 	return dw_phy_init(priv, dev);
 }
+
+int designware_initialize(ulong base_addr, u32 interface)
+{
+	return designware_initialize_fixed_link(base_addr, interface, 0);
+}
 #endif
 
 #ifdef CONFIG_DM_ETH
diff --git a/drivers/net/designware.h b/drivers/net/designware.h
index d345c5b..30f70f2 100644
--- a/drivers/net/designware.h
+++ b/drivers/net/designware.h
@@ -12,8 +12,8 @@
 #include <asm-generic/gpio.h>
 #endif
 
-#define CONFIG_TX_DESCR_NUM	16
-#define CONFIG_RX_DESCR_NUM	16
+#define CONFIG_TX_DESCR_NUM	2
+#define CONFIG_RX_DESCR_NUM	2
 #define CONFIG_ETH_BUFSIZE	2048
 #define TX_TOTAL_BUFSIZE	(CONFIG_ETH_BUFSIZE * CONFIG_TX_DESCR_NUM)
 #define RX_TOTAL_BUFSIZE	(CONFIG_ETH_BUFSIZE * CONFIG_RX_DESCR_NUM)
@@ -242,6 +242,7 @@ struct dw_eth_dev {
 
 	struct phy_device *phydev;
 	struct mii_dev *bus;
+	int fixed_link_speed;
 };
 
 #ifdef CONFIG_DM_ETH
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index 4eeb0f6..b8b9679 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -13,6 +13,8 @@
 
 #define PHY_AUTONEGOTIATE_TIMEOUT 5000
 
+#define MII_MARVELL_PHY_PAGE		22
+
 /* 88E1011 PHY Status Register */
 #define MIIM_88E1xxx_PHY_STATUS		0x11
 #define MIIM_88E1xxx_PHYSTAT_SPEED	0xc000
@@ -63,6 +65,12 @@
 
 #define MIIM_88E1121_PHY_PAGE		22
 
+#define MII_88E1121_PHY_MSCR_PAGE	2
+#define MII_88E1121_PHY_MSCR_REG	21
+#define MII_88E1121_PHY_MSCR_RX_DELAY	BIT(5)
+#define MII_88E1121_PHY_MSCR_TX_DELAY	BIT(4)
+#define MII_88E1121_PHY_MSCR_DELAY_MASK	(~(0x3 << 4))
+
 /* 88E1145 Extended PHY Specific Control Register */
 #define MIIM_88E1145_PHY_EXT_CR 20
 #define MIIM_M88E1145_RGMII_RX_DELAY	0x0080
@@ -177,10 +185,7 @@ static int m88e1111s_config(struct phy_device *phydev)
 {
 	int reg;
 
-	if ((phydev->interface == PHY_INTERFACE_MODE_RGMII) ||
-			(phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) ||
-			(phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) ||
-			(phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)) {
+	if (phy_interface_is_rgmii(phydev)) {
 		reg = phy_read(phydev,
 			MDIO_DEVAD_NONE, MIIM_88E1111_PHY_EXT_CR);
 		if ((phydev->interface == PHY_INTERFACE_MODE_RGMII) ||
@@ -283,6 +288,8 @@ void m88e1518_phy_writebits(struct phy_device *phydev,
 
 static int m88e1518_config(struct phy_device *phydev)
 {
+	u16 reg;
+
 	/*
 	 * As per Marvell Release Notes - Alaska 88E1510/88E1518/88E1512
 	 * /88E1514 Rev A0, Errata Section 3.1
@@ -317,7 +324,42 @@ static int m88e1518_config(struct phy_device *phydev)
 		udelay(100);
 	}
 
-	return m88e1111s_config(phydev);
+	if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {
+		reg = phy_read(phydev,
+			MDIO_DEVAD_NONE, MIIM_88E1111_PHY_EXT_SR);
+
+		reg &= ~(MIIM_88E1111_HWCFG_MODE_MASK);
+		reg |= MIIM_88E1111_HWCFG_MODE_SGMII_NO_CLK;
+		reg |= MIIM_88E1111_HWCFG_FIBER_COPPER_AUTO;
+
+		phy_write(phydev, MDIO_DEVAD_NONE,
+			MIIM_88E1111_PHY_EXT_SR, reg);
+	}
+
+	if (phy_interface_is_rgmii(phydev)) {
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_MARVELL_PHY_PAGE, MII_88E1121_PHY_MSCR_PAGE);
+
+		reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_88E1121_PHY_MSCR_REG);
+		reg &= ~MII_88E1121_PHY_MSCR_RX_DELAY;
+		reg &= ~MII_88E1121_PHY_MSCR_TX_DELAY;
+		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)
+			reg |= MII_88E1121_PHY_MSCR_RX_DELAY | MII_88E1121_PHY_MSCR_TX_DELAY;
+		else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)
+			reg |= MII_88E1121_PHY_MSCR_RX_DELAY;
+		else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)
+			reg |= MII_88E1121_PHY_MSCR_TX_DELAY;
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_88E1121_PHY_MSCR_REG, reg);
+
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_MARVELL_PHY_PAGE, 0);
+	}
+
+	/* soft reset */
+	phy_reset(phydev);
+
+	genphy_config_aneg(phydev);
+	genphy_restart_aneg(phydev);
+
+	return 0;
 }
 
 /* Marvell 88E1510 */
@@ -553,17 +595,22 @@ static struct phy_driver M88E1149S_driver = {
 static struct phy_driver M88E1510_driver = {
 	.name = "Marvell 88E1510",
 	.uid = 0x1410dd0,
-	.mask = 0xffffff0,
+	.mask = 0xfffffff,
 	.features = PHY_GBIT_FEATURES,
 	.config = &m88e1510_config,
 	.startup = &m88e1011s_startup,
 	.shutdown = &genphy_shutdown,
 };
 
+/*
+ * This supports:
+ *  88E1518, uid 0x1410dd1
+ *  88E1512, uid 0x1410dd4
+ */
 static struct phy_driver M88E1518_driver = {
 	.name = "Marvell 88E1518",
-	.uid = 0x1410dd1,
-	.mask = 0xffffff0,
+	.uid = 0x1410dd0,
+	.mask = 0xffffffa,
 	.features = PHY_GBIT_FEATURES,
 	.config = &m88e1518_config,
 	.startup = &m88e1011s_startup,
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 0f51b3a..7c69aef 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -47,6 +47,13 @@ config CADENCE_QSPI
 	  used to access the SPI NOR flash on platforms embedding this
 	  Cadence IP core.
 
+config CADENCE_QSPI_MMAP
+	bool "Enable direct (memory mapped) mode for Cadence QSPI driver"
+	depends on CADENCE_QSPI
+	help
+	  The IP can be configured to support direct (memory mapped) or indirect
+	  modes. If your hardware supports direct mode, you should use it.
+
 config DESIGNWARE_SPI
 	bool "Designware SPI driver"
 	help
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index c1ce158..7e2a41a 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -21,7 +21,7 @@ obj-$(CONFIG_ATMEL_DATAFLASH_SPI) += atmel_dataflash_spi.o
 obj-$(CONFIG_ATMEL_SPI) += atmel_spi.o
 obj-$(CONFIG_BFIN_SPI) += bfin_spi.o
 obj-$(CONFIG_BFIN_SPI6XX) += bfin_spi6xx.o
-obj-$(CONFIG_CADENCE_QSPI) += cadence_qspi.o cadence_qspi_apb.o
+obj-$(CONFIG_CADENCE_QSPI) += cadence_qspi.o cadence_qspi_apb.o cadence_qspi_mmap.o
 obj-$(CONFIG_CF_SPI) += cf_spi.o
 obj-$(CONFIG_CF_QSPI) += cf_qspi.o
 obj-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
diff --git a/drivers/spi/cadence_qspi.c b/drivers/spi/cadence_qspi.c
index f16f90d..89ad33d 100644
--- a/drivers/spi/cadence_qspi.c
+++ b/drivers/spi/cadence_qspi.c
@@ -39,8 +39,10 @@ static int cadence_spi_write_speed(struct udevice *bus, uint hz)
 /* Calibration sequence to determine the read data capture delay register */
 static int spi_calibration(struct udevice *bus, uint hz)
 {
+	struct cadence_spi_platdata *plat = bus->platdata;
 	struct cadence_spi_priv *priv = dev_get_priv(bus);
 	void *base = priv->regbase;
+	bool edge = plat->sample_edge_rising;
 	u8 opcode_rdid = 0x9F;
 	unsigned int idcode = 0, temp = 0;
 	int err = 0, i, range_lo = -1, range_hi = -1;
@@ -49,7 +51,7 @@ static int spi_calibration(struct udevice *bus, uint hz)
 	cadence_spi_write_speed(bus, 1000000);
 
 	/* configure the read data capture delay register to 0 */
-	cadence_qspi_apb_readdata_capture(base, 1, 0);
+	cadence_qspi_apb_readdata_capture(base, true, edge, 0);
 
 	/* Enable QSPI */
 	cadence_qspi_apb_controller_enable(base);
@@ -69,7 +71,7 @@ static int spi_calibration(struct udevice *bus, uint hz)
 		cadence_qspi_apb_controller_disable(base);
 
 		/* reconfigure the read data capture delay register */
-		cadence_qspi_apb_readdata_capture(base, 1, i);
+		cadence_qspi_apb_readdata_capture(base, true, edge, i);
 
 		/* Enable back QSPI */
 		cadence_qspi_apb_controller_enable(base);
@@ -105,7 +107,8 @@ static int spi_calibration(struct udevice *bus, uint hz)
 	cadence_qspi_apb_controller_disable(base);
 
 	/* configure the final value for read data capture delay register */
-	cadence_qspi_apb_readdata_capture(base, 1, (range_hi + range_lo) / 2);
+	cadence_qspi_apb_readdata_capture(base, true, edge,
+		(range_hi + range_lo) / 2);
 	debug("SF: Read data capture delay calibrated to %i (%i - %i)\n",
 	      (range_hi + range_lo) / 2, range_lo, range_hi);
 
@@ -189,13 +192,19 @@ static int cadence_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	struct udevice *bus = dev->parent;
 	struct cadence_spi_platdata *plat = bus->platdata;
 	struct cadence_spi_priv *priv = dev_get_priv(bus);
+#if !defined(CONFIG_CADENCE_QSPI_MMAP)
 	struct dm_spi_slave_platdata *dm_plat = dev_get_parent_platdata(dev);
+#endif
 	void *base = priv->regbase;
 	u8 *cmd_buf = priv->cmd_buf;
 	size_t data_bytes;
 	int err = 0;
 	u32 mode = CQSPI_STIG_WRITE;
 
+	/* Additional flags used for mmap write protection */
+	if (plat->use_mmap)
+		cadence_spi_xfer_mmap(dev, bitlen, dout, din, flags);
+
 	if (flags & SPI_XFER_BEGIN) {
 		/* copy command to local buffer */
 		priv->cmd_len = bitlen / 8;
@@ -247,6 +256,7 @@ static int cadence_spi_xfer(struct udevice *dev, unsigned int bitlen,
 				priv->cmd_len, cmd_buf,
 				data_bytes, dout);
 		break;
+#if !defined(CONFIG_CADENCE_QSPI_MMAP)
 		case CQSPI_INDIRECT_READ:
 			err = cadence_qspi_apb_indirect_read_setup(plat,
 				priv->cmd_len, dm_plat->mode, cmd_buf);
@@ -263,6 +273,7 @@ static int cadence_spi_xfer(struct udevice *dev, unsigned int bitlen,
 				(plat, data_bytes, dout);
 			}
 		break;
+#endif	/* !defined(CONFIG_CADENCE_QSPI_MMAP) */
 		default:
 			err = -1;
 			break;
@@ -316,6 +327,9 @@ static int cadence_spi_ofdata_to_platdata(struct udevice *bus)
 	plat->tsd2d_ns = fdtdec_get_int(blob, subnode, "tsd2d-ns", 255);
 	plat->tchsh_ns = fdtdec_get_int(blob, subnode, "tchsh-ns", 20);
 	plat->tslch_ns = fdtdec_get_int(blob, subnode, "tslch-ns", 20);
+	plat->sample_edge_rising = fdtdec_get_bool(blob, subnode,
+		"sample-edge-rising");
+	plat->use_mmap = fdtdec_get_bool(blob, subnode, "memory-map-write");
 
 	debug("%s: regbase=%p ahbbase=%p max-frequency=%d page-size=%d\n",
 	      __func__, plat->regbase, plat->ahbbase, plat->max_hz,
@@ -336,6 +350,7 @@ static const struct dm_spi_ops cadence_spi_ops = {
 
 static const struct udevice_id cadence_spi_ids[] = {
 	{ .compatible = "cadence,qspi" },
+	{ .compatible = "renesas,rzn1-qspi" },
 	{ }
 };
 
diff --git a/drivers/spi/cadence_qspi.h b/drivers/spi/cadence_qspi.h
index d1927a4..6b53450 100644
--- a/drivers/spi/cadence_qspi.h
+++ b/drivers/spi/cadence_qspi.h
@@ -14,6 +14,130 @@
 #define CQSPI_DECODER_MAX_CS		16
 #define CQSPI_READ_CAPTURE_MAX_DELAY	16
 
+/* Transfer mode */
+#define CQSPI_INST_TYPE_SINGLE			0
+#define CQSPI_INST_TYPE_DUAL			1
+#define CQSPI_INST_TYPE_QUAD			2
+
+/****************************************************************************
+ * Controller's configuration and status register (offset from QSPI_BASE)
+ ****************************************************************************/
+#define	CQSPI_REG_CONFIG			0x00
+#define	CQSPI_REG_CONFIG_ENABLE			BIT(0)
+#define	CQSPI_REG_CONFIG_CLK_POL		BIT(1)
+#define	CQSPI_REG_CONFIG_CLK_PHA		BIT(2)
+#define	CQSPI_REG_CONFIG_DIRECT			BIT(7)
+#define	CQSPI_REG_CONFIG_DECODE			BIT(9)
+#define	CQSPI_REG_CONFIG_XIP_IMM		BIT(18)
+#define	CQSPI_REG_CONFIG_CHIPSELECT_LSB		10
+#define	CQSPI_REG_CONFIG_BAUD_LSB		19
+#define	CQSPI_REG_CONFIG_IDLE_LSB		31
+#define	CQSPI_REG_CONFIG_CHIPSELECT_MASK	0xF
+#define	CQSPI_REG_CONFIG_BAUD_MASK		0xF
+
+#define	CQSPI_REG_RD_INSTR			0x04
+#define	CQSPI_REG_RD_INSTR_OPCODE_LSB		0
+#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB	8
+#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB	12
+#define	CQSPI_REG_RD_INSTR_TYPE_DATA_LSB	16
+#define	CQSPI_REG_RD_INSTR_MODE_EN_LSB		20
+#define	CQSPI_REG_RD_INSTR_DUMMY_LSB		24
+#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_TYPE_DATA_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_DUMMY_MASK		0x1F
+
+#define	CQSPI_REG_WR_INSTR			0x08
+#define	CQSPI_REG_WR_INSTR_OPCODE_LSB		0
+
+#define	CQSPI_REG_DELAY				0x0C
+#define	CQSPI_REG_DELAY_TSLCH_LSB		0
+#define	CQSPI_REG_DELAY_TCHSH_LSB		8
+#define	CQSPI_REG_DELAY_TSD2D_LSB		16
+#define	CQSPI_REG_DELAY_TSHSL_LSB		24
+#define	CQSPI_REG_DELAY_TSLCH_MASK		0xFF
+#define	CQSPI_REG_DELAY_TCHSH_MASK		0xFF
+#define	CQSPI_REG_DELAY_TSD2D_MASK		0xFF
+#define	CQSPI_REG_DELAY_TSHSL_MASK		0xFF
+
+#define	CQSPI_REG_RD_DATA_CAPTURE		0x10
+#define	CQSPI_REG_RD_DATA_CAPTURE_BYPASS	BIT(0)
+#define	CQSPI_REG_RD_DATA_CAPTURE_DELAY_LSB	1
+#define	CQSPI_REG_RD_DATA_CAPTURE_DELAY_MASK	0xF
+#define	CQSPI_REG_RD_DATA_CAPTURE_EDGE		BIT(5)
+
+#define	CQSPI_REG_SIZE				0x14
+#define	CQSPI_REG_SIZE_ADDRESS_LSB		0
+#define	CQSPI_REG_SIZE_PAGE_LSB			4
+#define	CQSPI_REG_SIZE_BLOCK_LSB		16
+#define	CQSPI_REG_SIZE_ADDRESS_MASK		0xF
+#define	CQSPI_REG_SIZE_PAGE_MASK		0xFFF
+#define	CQSPI_REG_SIZE_BLOCK_MASK		0x3F
+
+#define	CQSPI_REG_SRAMPARTITION			0x18
+#define	CQSPI_REG_INDIRECTTRIGGER		0x1C
+
+#define	CQSPI_REG_REMAP				0x24
+#define	CQSPI_REG_MODE_BIT			0x28
+
+#define	CQSPI_REG_SDRAMLEVEL			0x2C
+#define	CQSPI_REG_SDRAMLEVEL_RD_LSB		0
+#define	CQSPI_REG_SDRAMLEVEL_WR_LSB		16
+#define	CQSPI_REG_SDRAMLEVEL_RD_MASK		0xFFFF
+#define	CQSPI_REG_SDRAMLEVEL_WR_MASK		0xFFFF
+
+#define	CQSPI_REG_IRQSTATUS			0x40
+#define	CQSPI_REG_IRQMASK			0x44
+
+#define	CQSPI_REG_LOWER_WRITE_PROTECT		0x50
+#define	CQSPI_REG_UPPER_WRITE_PROTECT		0x54
+
+#define	CQSPI_REG_WRITE_PROTECT_CTRL		0x58
+#define	CQSPI_REG_WRPROT_ENABLE			BIT(1)
+
+#define	CQSPI_REG_INDIRECTRD			0x60
+#define	CQSPI_REG_INDIRECTRD_START		BIT(0)
+#define	CQSPI_REG_INDIRECTRD_CANCEL		BIT(1)
+#define	CQSPI_REG_INDIRECTRD_INPROGRESS		BIT(2)
+#define	CQSPI_REG_INDIRECTRD_DONE		BIT(5)
+
+#define	CQSPI_REG_INDIRECTRDWATERMARK		0x64
+#define	CQSPI_REG_INDIRECTRDSTARTADDR		0x68
+#define	CQSPI_REG_INDIRECTRDBYTES		0x6C
+
+#define	CQSPI_REG_CMDCTRL			0x90
+#define	CQSPI_REG_CMDCTRL_EXECUTE		BIT(0)
+#define	CQSPI_REG_CMDCTRL_INPROGRESS		BIT(1)
+#define	CQSPI_REG_CMDCTRL_DUMMY_LSB		7
+#define	CQSPI_REG_CMDCTRL_WR_BYTES_LSB		12
+#define	CQSPI_REG_CMDCTRL_WR_EN_LSB		15
+#define	CQSPI_REG_CMDCTRL_ADD_BYTES_LSB		16
+#define	CQSPI_REG_CMDCTRL_ADDR_EN_LSB		19
+#define	CQSPI_REG_CMDCTRL_RD_BYTES_LSB		20
+#define	CQSPI_REG_CMDCTRL_RD_EN_LSB		23
+#define	CQSPI_REG_CMDCTRL_OPCODE_LSB		24
+#define	CQSPI_REG_CMDCTRL_DUMMY_MASK		0x1F
+#define	CQSPI_REG_CMDCTRL_WR_BYTES_MASK		0x7
+#define	CQSPI_REG_CMDCTRL_ADD_BYTES_MASK	0x3
+#define	CQSPI_REG_CMDCTRL_RD_BYTES_MASK		0x7
+#define	CQSPI_REG_CMDCTRL_OPCODE_MASK		0xFF
+
+#define	CQSPI_REG_INDIRECTWR			0x70
+#define	CQSPI_REG_INDIRECTWR_START		BIT(0)
+#define	CQSPI_REG_INDIRECTWR_CANCEL		BIT(1)
+#define	CQSPI_REG_INDIRECTWR_INPROGRESS		BIT(2)
+#define	CQSPI_REG_INDIRECTWR_DONE		BIT(5)
+
+#define	CQSPI_REG_INDIRECTWRWATERMARK		0x74
+#define	CQSPI_REG_INDIRECTWRSTARTADDR		0x78
+#define	CQSPI_REG_INDIRECTWRBYTES		0x7C
+
+#define	CQSPI_REG_CMDADDRESS			0x94
+#define	CQSPI_REG_CMDREADDATALOWER		0xA0
+#define	CQSPI_REG_CMDREADDATAUPPER		0xA4
+#define	CQSPI_REG_CMDWRITEDATALOWER		0xA8
+#define	CQSPI_REG_CMDWRITEDATAUPPER		0xAC
+
 struct cadence_spi_platdata {
 	unsigned int	max_hz;
 	void		*regbase;
@@ -26,6 +150,8 @@ struct cadence_spi_platdata {
 	u32		tchsh_ns;
 	u32		tslch_ns;
 	u32		sram_size;
+	bool		sample_edge_rising;
+	bool		use_mmap;
 };
 
 struct cadence_spi_priv {
@@ -43,6 +169,7 @@ struct cadence_spi_priv {
 
 /* Functions call declaration */
 void cadence_qspi_apb_controller_init(struct cadence_spi_platdata *plat);
+void cadence_qspi_apb_controller_init_mmap(struct cadence_spi_platdata *plat);
 void cadence_qspi_apb_controller_enable(void *reg_base_addr);
 void cadence_qspi_apb_controller_disable(void *reg_base_addr);
 
@@ -72,6 +199,8 @@ void cadence_qspi_apb_delay(void *reg_base,
 	unsigned int tchsh_ns, unsigned int tslch_ns);
 void cadence_qspi_apb_enter_xip(void *reg_base, char xip_dummy);
 void cadence_qspi_apb_readdata_capture(void *reg_base,
-	unsigned int bypass, unsigned int delay);
+	bool bypass, bool edge, unsigned int delay);
+int cadence_spi_xfer_mmap(struct udevice *dev, unsigned int bitlen,
+	const void *dout, void *din, unsigned long flags);
 
 #endif /* __CADENCE_QSPI_H__ */
diff --git a/drivers/spi/cadence_qspi_apb.c b/drivers/spi/cadence_qspi_apb.c
index e02f221..c2e24bc 100644
--- a/drivers/spi/cadence_qspi_apb.c
+++ b/drivers/spi/cadence_qspi_apb.c
@@ -41,11 +41,6 @@
 
 #define CQSPI_REG_SRAM_THRESHOLD_WORDS		50
 
-/* Transfer mode */
-#define CQSPI_INST_TYPE_SINGLE			0
-#define CQSPI_INST_TYPE_DUAL			1
-#define CQSPI_INST_TYPE_QUAD			2
-
 #define CQSPI_STIG_DATA_LEN_MAX			8
 
 #define CQSPI_DUMMY_CLKS_PER_BYTE		8
@@ -54,118 +49,6 @@
 #define CQSPI_REG_SRAM_FILL_THRESHOLD	\
 	((CQSPI_REG_SRAM_SIZE_WORD / 2) * CQSPI_FIFO_WIDTH)
 
-/****************************************************************************
- * Controller's configuration and status register (offset from QSPI_BASE)
- ****************************************************************************/
-#define	CQSPI_REG_CONFIG			0x00
-#define	CQSPI_REG_CONFIG_ENABLE			BIT(0)
-#define	CQSPI_REG_CONFIG_CLK_POL		BIT(1)
-#define	CQSPI_REG_CONFIG_CLK_PHA		BIT(2)
-#define	CQSPI_REG_CONFIG_DIRECT			BIT(7)
-#define	CQSPI_REG_CONFIG_DECODE			BIT(9)
-#define	CQSPI_REG_CONFIG_XIP_IMM		BIT(18)
-#define	CQSPI_REG_CONFIG_CHIPSELECT_LSB		10
-#define	CQSPI_REG_CONFIG_BAUD_LSB		19
-#define	CQSPI_REG_CONFIG_IDLE_LSB		31
-#define	CQSPI_REG_CONFIG_CHIPSELECT_MASK	0xF
-#define	CQSPI_REG_CONFIG_BAUD_MASK		0xF
-
-#define	CQSPI_REG_RD_INSTR			0x04
-#define	CQSPI_REG_RD_INSTR_OPCODE_LSB		0
-#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB	8
-#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB	12
-#define	CQSPI_REG_RD_INSTR_TYPE_DATA_LSB	16
-#define	CQSPI_REG_RD_INSTR_MODE_EN_LSB		20
-#define	CQSPI_REG_RD_INSTR_DUMMY_LSB		24
-#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_MASK	0x3
-#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_MASK	0x3
-#define	CQSPI_REG_RD_INSTR_TYPE_DATA_MASK	0x3
-#define	CQSPI_REG_RD_INSTR_DUMMY_MASK		0x1F
-
-#define	CQSPI_REG_WR_INSTR			0x08
-#define	CQSPI_REG_WR_INSTR_OPCODE_LSB		0
-
-#define	CQSPI_REG_DELAY				0x0C
-#define	CQSPI_REG_DELAY_TSLCH_LSB		0
-#define	CQSPI_REG_DELAY_TCHSH_LSB		8
-#define	CQSPI_REG_DELAY_TSD2D_LSB		16
-#define	CQSPI_REG_DELAY_TSHSL_LSB		24
-#define	CQSPI_REG_DELAY_TSLCH_MASK		0xFF
-#define	CQSPI_REG_DELAY_TCHSH_MASK		0xFF
-#define	CQSPI_REG_DELAY_TSD2D_MASK		0xFF
-#define	CQSPI_REG_DELAY_TSHSL_MASK		0xFF
-
-#define	CQSPI_REG_RD_DATA_CAPTURE		0x10
-#define	CQSPI_REG_RD_DATA_CAPTURE_BYPASS	BIT(0)
-#define	CQSPI_REG_RD_DATA_CAPTURE_DELAY_LSB	1
-#define	CQSPI_REG_RD_DATA_CAPTURE_DELAY_MASK	0xF
-
-#define	CQSPI_REG_SIZE				0x14
-#define	CQSPI_REG_SIZE_ADDRESS_LSB		0
-#define	CQSPI_REG_SIZE_PAGE_LSB			4
-#define	CQSPI_REG_SIZE_BLOCK_LSB		16
-#define	CQSPI_REG_SIZE_ADDRESS_MASK		0xF
-#define	CQSPI_REG_SIZE_PAGE_MASK		0xFFF
-#define	CQSPI_REG_SIZE_BLOCK_MASK		0x3F
-
-#define	CQSPI_REG_SRAMPARTITION			0x18
-#define	CQSPI_REG_INDIRECTTRIGGER		0x1C
-
-#define	CQSPI_REG_REMAP				0x24
-#define	CQSPI_REG_MODE_BIT			0x28
-
-#define	CQSPI_REG_SDRAMLEVEL			0x2C
-#define	CQSPI_REG_SDRAMLEVEL_RD_LSB		0
-#define	CQSPI_REG_SDRAMLEVEL_WR_LSB		16
-#define	CQSPI_REG_SDRAMLEVEL_RD_MASK		0xFFFF
-#define	CQSPI_REG_SDRAMLEVEL_WR_MASK		0xFFFF
-
-#define	CQSPI_REG_IRQSTATUS			0x40
-#define	CQSPI_REG_IRQMASK			0x44
-
-#define	CQSPI_REG_INDIRECTRD			0x60
-#define	CQSPI_REG_INDIRECTRD_START		BIT(0)
-#define	CQSPI_REG_INDIRECTRD_CANCEL		BIT(1)
-#define	CQSPI_REG_INDIRECTRD_INPROGRESS		BIT(2)
-#define	CQSPI_REG_INDIRECTRD_DONE		BIT(5)
-
-#define	CQSPI_REG_INDIRECTRDWATERMARK		0x64
-#define	CQSPI_REG_INDIRECTRDSTARTADDR		0x68
-#define	CQSPI_REG_INDIRECTRDBYTES		0x6C
-
-#define	CQSPI_REG_CMDCTRL			0x90
-#define	CQSPI_REG_CMDCTRL_EXECUTE		BIT(0)
-#define	CQSPI_REG_CMDCTRL_INPROGRESS		BIT(1)
-#define	CQSPI_REG_CMDCTRL_DUMMY_LSB		7
-#define	CQSPI_REG_CMDCTRL_WR_BYTES_LSB		12
-#define	CQSPI_REG_CMDCTRL_WR_EN_LSB		15
-#define	CQSPI_REG_CMDCTRL_ADD_BYTES_LSB		16
-#define	CQSPI_REG_CMDCTRL_ADDR_EN_LSB		19
-#define	CQSPI_REG_CMDCTRL_RD_BYTES_LSB		20
-#define	CQSPI_REG_CMDCTRL_RD_EN_LSB		23
-#define	CQSPI_REG_CMDCTRL_OPCODE_LSB		24
-#define	CQSPI_REG_CMDCTRL_DUMMY_MASK		0x1F
-#define	CQSPI_REG_CMDCTRL_WR_BYTES_MASK		0x7
-#define	CQSPI_REG_CMDCTRL_ADD_BYTES_MASK	0x3
-#define	CQSPI_REG_CMDCTRL_RD_BYTES_MASK		0x7
-#define	CQSPI_REG_CMDCTRL_OPCODE_MASK		0xFF
-
-#define	CQSPI_REG_INDIRECTWR			0x70
-#define	CQSPI_REG_INDIRECTWR_START		BIT(0)
-#define	CQSPI_REG_INDIRECTWR_CANCEL		BIT(1)
-#define	CQSPI_REG_INDIRECTWR_INPROGRESS		BIT(2)
-#define	CQSPI_REG_INDIRECTWR_DONE		BIT(5)
-
-#define	CQSPI_REG_INDIRECTWRWATERMARK		0x74
-#define	CQSPI_REG_INDIRECTWRSTARTADDR		0x78
-#define	CQSPI_REG_INDIRECTWRBYTES		0x7C
-
-#define	CQSPI_REG_CMDADDRESS			0x94
-#define	CQSPI_REG_CMDREADDATALOWER		0xA0
-#define	CQSPI_REG_CMDREADDATAUPPER		0xA4
-#define	CQSPI_REG_CMDWRITEDATALOWER		0xA8
-#define	CQSPI_REG_CMDWRITEDATAUPPER		0xAC
-
 #define CQSPI_REG_IS_IDLE(base)					\
 	((readl(base + CQSPI_REG_CONFIG) >>		\
 		CQSPI_REG_CONFIG_IDLE_LSB) & 0x1)
@@ -235,7 +118,7 @@ static unsigned int cadence_qspi_wait_idle(void *reg_base)
 }
 
 void cadence_qspi_apb_readdata_capture(void *reg_base,
-				unsigned int bypass, unsigned int delay)
+	bool bypass, bool edge, unsigned int delay)
 {
 	unsigned int reg;
 	cadence_qspi_apb_controller_disable(reg_base);
@@ -247,6 +130,11 @@ void cadence_qspi_apb_readdata_capture(void *reg_base,
 	else
 		reg &= ~CQSPI_REG_RD_DATA_CAPTURE_BYPASS;
 
+	if (edge)
+		reg |= CQSPI_REG_RD_DATA_CAPTURE_EDGE;
+	else
+		reg &= ~CQSPI_REG_RD_DATA_CAPTURE_EDGE;
+
 	reg &= ~(CQSPI_REG_RD_DATA_CAPTURE_DELAY_MASK
 		<< CQSPI_REG_RD_DATA_CAPTURE_DELAY_LSB);
 
@@ -405,6 +293,9 @@ void cadence_qspi_apb_controller_init(struct cadence_spi_platdata *plat)
 	/* Disable all interrupts */
 	writel(0, plat->regbase + CQSPI_REG_IRQMASK);
 
+	if (plat->use_mmap)
+		cadence_qspi_apb_controller_init_mmap(plat);
+
 	cadence_qspi_apb_controller_enable(plat->regbase);
 }
 
@@ -534,6 +425,7 @@ int cadence_qspi_apb_command_write(void *reg_base, unsigned int cmdlen,
 	return cadence_qspi_apb_exec_flash_cmd(reg_base, reg);
 }
 
+#if !defined(CONFIG_CADENCE_QSPI_MMAP)
 /* Opcode + Address (3/4 bytes) + dummy bytes (0-4 bytes) */
 int cadence_qspi_apb_indirect_read_setup(struct cadence_spi_platdata *plat,
 	unsigned int cmdlen, unsigned int rx_width, const u8 *cmdbuf)
@@ -795,6 +687,7 @@ failwr:
 	bounce_buffer_stop(&bb);
 	return ret;
 }
+#endif	/* !defined(CONFIG_CADENCE_QSPI_MMAP) */
 
 void cadence_qspi_apb_enter_xip(void *reg_base, char xip_dummy)
 {
diff --git a/drivers/spi/cadence_qspi_mmap.c b/drivers/spi/cadence_qspi_mmap.c
new file mode 100644
index 0000000..6916c83
--- /dev/null
+++ b/drivers/spi/cadence_qspi_mmap.c
@@ -0,0 +1,138 @@
+/*
+ * (C) Copyright 2016 Renesas Electronics Europe Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <linux/errno.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include "../mtd/spi/sf_internal.h"
+#include "cadence_qspi.h"
+
+#ifndef CONFIG_SPI_REGISTER_FLASH
+#error Requires the global define CONFIG_SPI_REGISTER_FLASH in your config file
+#endif
+
+void cadence_qspi_apb_controller_init_mmap(struct cadence_spi_platdata *plat)
+{
+	unsigned reg;
+
+	/* enable direct mode */
+	reg = readl(plat->regbase + CQSPI_REG_CONFIG);
+	reg |= CQSPI_REG_CONFIG_ENABLE;
+	reg |= CQSPI_REG_CONFIG_DIRECT;
+	writel(reg, plat->regbase + CQSPI_REG_CONFIG);
+
+	/* Enable AHB write protection, to prevent random write access
+	 * that could nuke the flash memory. Instead you have to explicitly
+	 * use 'sf write' to change the flash.
+	 * We set the protection range to the maximum, so the whole
+	 * address range should be protected, regardless of what size
+	 * is actually used.
+	 */
+	writel(0, plat->regbase + CQSPI_REG_LOWER_WRITE_PROTECT);
+	writel(~0, plat->regbase + CQSPI_REG_UPPER_WRITE_PROTECT);
+	writel(CQSPI_REG_WRPROT_ENABLE,
+		plat->regbase + CQSPI_REG_WRITE_PROTECT_CTRL);
+}
+
+/*
+ * This is an addition to the general spi slave interface, this function
+ * is called if a flash has been detected, to allow the slave to configure
+ * itself.
+ * In our case here, we need to know the number of address lines and stuff
+ */
+void spi_slave_register_flash(struct spi_flash *flash)
+{
+	struct spi_slave *slave = flash->spi;
+	struct udevice *bus = slave->dev->parent;
+	struct cadence_spi_platdata *plat = bus->platdata;
+	uint32_t rd_reg, wr_reg, reg;
+
+	if (flash->memory_map == NULL)
+		return;
+
+	debug("%s dummy %d - page %d sector %d erase %d(ffs %d)\n", __func__,
+	      flash->dummy_cycles, flash->page_size, flash->sector_size,
+	      flash->erase_size, ffs(flash->erase_size));
+	debug(" CMD rd %2x wr %02x addr:%d\n", flash->read_cmd,
+		flash->write_cmd, slave->addressing_bytes);
+
+	cadence_qspi_apb_controller_disable(plat->regbase);
+
+	/* Configure the device size and address bytes */
+	reg = readl(plat->regbase + CQSPI_REG_SIZE);
+	/* Clear the previous value */
+	reg &= ~(CQSPI_REG_SIZE_PAGE_MASK << CQSPI_REG_SIZE_PAGE_LSB);
+	reg &= ~(CQSPI_REG_SIZE_BLOCK_MASK << CQSPI_REG_SIZE_BLOCK_LSB);
+	reg |= (flash->page_size << CQSPI_REG_SIZE_PAGE_LSB);
+	reg |= ((ffs(flash->erase_size)-1) << CQSPI_REG_SIZE_BLOCK_LSB);
+	writel(reg, plat->regbase + CQSPI_REG_SIZE);
+
+	/* 3 or 4-byte addressing */
+	if (slave->addressing_bytes < 3)
+		slave->addressing_bytes = 3;
+
+	reg = readl(plat->regbase + CQSPI_REG_SIZE);
+	reg &= ~0xf;
+	reg |= slave->addressing_bytes - 1;
+	writel(reg, plat->regbase + CQSPI_REG_SIZE);
+
+	rd_reg = (flash->read_cmd << CQSPI_REG_RD_INSTR_OPCODE_LSB);
+
+	switch (flash->read_cmd) {
+	case CMD_READ_ARRAY_SLOW:		/* 0x03 */
+	case CMD_READ_ARRAY_SLOW_4B:		/* 0x13 */
+	case CMD_READ_ARRAY_FAST:		/* 0x0b */
+	case CMD_READ_ARRAY_FAST_4B:		/* 0x0c */
+		break;
+	case CMD_READ_DUAL_IO_FAST:		/* 0xbb */
+	case CMD_READ_DUAL_IO_FAST_4B:		/* 0xbc */
+		rd_reg |= (CQSPI_INST_TYPE_DUAL << CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB);
+	case CMD_READ_DUAL_OUTPUT_FAST:		/* 0x3b */
+	case CMD_READ_DUAL_OUTPUT_FAST_4B:	/* 0x3c */
+		rd_reg |= (CQSPI_INST_TYPE_DUAL << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB);
+		break;
+	case CMD_READ_QUAD_IO_FAST:		/* 0xeb */
+	case CMD_READ_QUAD_IO_FAST_4B:		/* 0xec */
+		rd_reg |= (CQSPI_INST_TYPE_QUAD << CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB);
+	case CMD_READ_QUAD_OUTPUT_FAST:		/* 0x6b */
+	case CMD_READ_QUAD_OUTPUT_FAST_4B:	/* 0x6c */
+		rd_reg |= (CQSPI_INST_TYPE_QUAD << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB);
+		break;
+	default:
+		debug("%s unsupported read command %02x\n", __func__, flash->read_cmd);
+	}
+
+	rd_reg |= (flash->dummy_cycles & CQSPI_REG_RD_INSTR_DUMMY_MASK) << CQSPI_REG_RD_INSTR_DUMMY_LSB;
+	writel(rd_reg, plat->regbase + CQSPI_REG_RD_INSTR);
+	writel(0xff, plat->regbase + CQSPI_REG_MODE_BIT);
+
+	/* Write cmd */
+	wr_reg = (flash->write_cmd << CQSPI_REG_RD_INSTR_OPCODE_LSB);
+	if  (flash->write_cmd == CMD_QUAD_PAGE_PROGRAM)
+		wr_reg |= (CQSPI_INST_TYPE_QUAD << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB);
+	writel(wr_reg, plat->regbase + CQSPI_REG_WR_INSTR);
+
+	cadence_qspi_apb_controller_enable(plat->regbase);
+}
+
+int cadence_spi_xfer_mmap(struct udevice *dev, unsigned int bitlen,
+	const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct cadence_spi_platdata *plat = bus->platdata;
+	int err = 0;
+
+	if (flags & SPI_XFER_MMAP_WRITE)
+		writel(0, plat->regbase + CQSPI_REG_WRITE_PROTECT_CTRL);
+
+	if (flags & (SPI_XFER_MMAP_END | SPI_XFER_END))
+		writel(CQSPI_REG_WRPROT_ENABLE,
+			plat->regbase + CQSPI_REG_WRITE_PROTECT_CTRL);
+
+	return err;
+}
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 40839d8..10ca346 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -67,6 +67,13 @@ config USB_GADGET_DWC2_OTG_PHY_BUS_WIDTH_8
 
 endif # USB_GADGET_DWC2_OTG
 
+config USB_GADGET_RZN1
+	bool "Renesas RZ/N1 USB gadget controller"
+	select USB_GADGET_DUALSPEED
+	help
+	  Say Y here to enable gadget controller functionality of the
+	  Renesas driver.
+
 config CI_UDC
 	bool "ChipIdea device controller"
 	select USB_GADGET_DUALSPEED
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 0fbbb7c..22c06ae 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -21,6 +21,7 @@ obj-$(CONFIG_USB_GADGET_BCM_UDC_OTG_PHY) += bcm_udc_otg_phy.o
 obj-$(CONFIG_USB_GADGET_DWC2_OTG) += dwc2_udc_otg.o
 obj-$(CONFIG_USB_GADGET_DWC2_OTG_PHY) += dwc2_udc_otg_phy.o
 obj-$(CONFIG_USB_GADGET_FOTG210) += fotg210.o
+obj-$(CONFIG_USB_GADGET_RZN1) += usbf-renesas.o
 obj-$(CONFIG_CI_UDC)	+= ci_udc.o
 ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_USB_GADGET_DOWNLOAD) += g_dnl.o
diff --git a/drivers/usb/gadget/f_dfu.c b/drivers/usb/gadget/f_dfu.c
index 8e7c981..0d23830 100644
--- a/drivers/usb/gadget/f_dfu.c
+++ b/drivers/usb/gadget/f_dfu.c
@@ -757,12 +757,14 @@ static void dfu_unbind(struct usb_configuration *c, struct usb_function *f)
 static int dfu_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 {
 	struct f_dfu *f_dfu = func_to_dfu(f);
+	struct dfu_entity *dfu = dfu_get_entity(f_dfu->altsetting);
 
 	debug("%s: intf:%d alt:%d\n", __func__, intf, alt);
 
 	f_dfu->altsetting = alt;
 	f_dfu->dfu_state = DFU_STATE_dfuIDLE;
 	f_dfu->dfu_status = DFU_STATUS_OK;
+	dfu->inited = 0;
 
 	return 0;
 }
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index 973cd97..8bedd31 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -162,7 +162,11 @@
 #define gadget_is_dwc3(g)        0
 #endif
 
-
+#ifdef CONFIG_USB_GADGET_RZN1
+#define gadget_is_rzn1_usb_f(g)        (!strcmp("rzn1_usbf", (g)->name))
+#else
+#define gadget_is_rzn1_usb_f(g)        0
+#endif
 
 /*
  * CONFIG_USB_GADGET_SX2
@@ -231,5 +235,7 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x21;
 	else if (gadget_is_fotg210(gadget))
 		return 0x22;
+	else if (gadget_is_rzn1_usb_f(gadget))
+		return 0x23;
 	return -ENOENT;
 }
diff --git a/drivers/usb/gadget/usbf-renesas.c b/drivers/usb/gadget/usbf-renesas.c
new file mode 100644
index 0000000..a7eb488
--- /dev/null
+++ b/drivers/usb/gadget/usbf-renesas.c
@@ -0,0 +1,870 @@
+/*
+ * Renesas USB Device/Function driver
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ */
+#include <common.h>
+#include <config.h>
+#include <malloc.h>
+#include <linux/errno.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <usb.h>
+#include "usbf-renesas.h"
+
+static struct usb_endpoint_descriptor ep0_desc = {
+	.bLength = sizeof(struct usb_endpoint_descriptor),
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_CONTROL,
+};
+
+/*
+ * Endpoint 0 callbacks
+ */
+
+static int usbf_ep0_flush_buffer(
+	struct f_regs_ep0 *ep_reg,
+	uint32_t bits)
+{
+	int res = 100000;
+
+	if ((readl(&ep_reg->status) & bits) == bits)
+		return res;
+
+	writel(readl(&ep_reg->control) | D_EP0_BCLR, &ep_reg->control);
+
+	while (res-- && ((readl(&ep_reg->status) & bits) != bits))
+		;
+
+	if (!res)
+		debug("%s timeout on buffer clear!\n", __func__);
+
+	return res;
+}
+
+static void usbf_ep0_clear_inak(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel((readl(&ep_reg->control) | D_EP0_INAK_EN) & ~D_EP0_INAK,
+	       &ep_reg->control);
+}
+
+static void usbf_ep0_clear_onak(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel((readl(&ep_reg->control)) & ~D_EP0_ONAK, &ep_reg->control);
+}
+
+static void usbf_ep0_stall(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel(readl(&ep_reg->control) | D_EP0_STL, &ep_reg->control);
+}
+
+static int usbf_ep0_enable(
+	struct f_endpoint *ep)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+
+	writel(D_EP0_INAK_EN | D_EP0_BCLR, &ep_reg->control);
+	writel(D_EP0_SETUP_EN | D_EP0_STG_START_EN |
+	       D_EP0_OUT_EN,
+	       &ep_reg->int_enable);
+	return 0;
+}
+
+static void usbf_ep0_disable(
+	struct f_endpoint *ep)
+{
+	/* TODO */
+}
+
+static int usbf_ep0_send1(
+	struct f_endpoint *ep,
+	void *data,
+	int reqlen)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+	uint32_t control;
+	int w, len;
+	uint32_t *src = (uint32_t *)data;
+	int pkt_words = reqlen / sizeof(*src);
+
+	/* Wait until there is space to write the pkt */
+	while ((readl(&ep_reg->status) & D_EP0_IN_EMPTY) == 0)
+		;
+
+	/* Note, we don't care about endianness here, as the IP
+	 * and the core will have the same layout anyway, so we
+	 * can happily ignore it */
+	for (w = 0; w < pkt_words; w++)
+		writel(*src++, &ep_reg->write);
+
+	control = readl(&ep_reg->control);
+
+	/* if we have stray bytes, write them off too, and mark the
+	 * control registers so it knows only 1,2,3 bytes are valid in
+	 * the last write we made */
+	len = reqlen & (sizeof(*src) - 1);
+	if (len) {
+		writel(*src, &ep_reg->write);
+		control |= (len << 5);
+	}
+
+	writel(control | D_EP0_DEND, &ep_reg->control);
+
+	return 0;
+}
+
+static int usbf_ep0_send(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+
+	/* Special handling for internally generated NULL packets */
+	if (!req) {
+		writel(readl(&ep_reg->control) | D_EP0_DEND, &ep_reg->control);
+		return 0;
+	}
+
+	if (req->req.length) {
+		char *src = (char *)req->req.buf;
+		int bytes = req->req.length;
+		int maxpkt_bytes = ep->ep.maxpacket;
+
+		while (bytes > 0) {
+			int pkt_bytes = min(bytes, maxpkt_bytes);
+			int ret = usbf_ep0_send1(ep, src, pkt_bytes);
+
+			if (ret < 0) {
+				req->req.status = ret;
+				return ret;
+			}
+
+			bytes -= pkt_bytes;
+			src += pkt_bytes;
+		}
+		req->req.actual = req->req.length;
+		req->req.status = 0;
+	}
+
+	/* UDC asking for a ZLP to follow? */
+	if (req->req.length == 0 || req->req.zero)
+		req->req.status = usbf_ep0_send1(ep, NULL, 0);
+
+	return req->req.status;
+}
+
+/*
+ * This can be called repeatedly until the request is done
+ */
+static int usbf_ep0_recv(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+	uint32_t reqlen = readl(&ep_reg->length);
+	uint32_t len = reqlen;
+	uint32_t *buf  = req->req.buf + req->req.actual;
+
+	TRACE("%s size %d (%d/%d)\n", __func__, len,
+	      req->req.actual, req->req.length);
+	while (len > 0) {
+		*buf++ = readl(&ep_reg->read);
+		len -= 4;
+	}
+	req->req.actual += reqlen;
+
+	if (req->req.actual == req->req.length)
+		req->req.status = 0;
+	return req->req.status;
+}
+
+
+/*
+ * result of setup packet
+ */
+#define CX_IDLE		0
+#define CX_FINISH	1
+#define CX_STALL	2
+
+static void usbf_ep0_setup(
+	struct f_endpoint *ep,
+	struct usb_ctrlrequest *ctrl)
+{
+	int ret = CX_IDLE;
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+	uint16_t value = ctrl->wValue & 0xff;
+
+	if (ctrl->bRequestType & USB_DIR_IN)
+		ep0_desc.bEndpointAddress = USB_DIR_IN;
+	else
+		ep0_desc.bEndpointAddress = USB_DIR_OUT;
+
+	/* TODO:
+	 * This is mandatory, as for the moment at least, we never get an
+	 * interrupt/status flag indicating the speed has changed. And without
+	 * a speed change flag, the gadget upper layer is incapable of finding
+	 * a valid configuration */
+	if (readl(&chip->regs->status) & D_USB_SPEED_MODE)
+		chip->gadget.speed = USB_SPEED_HIGH;
+	else
+		chip->gadget.speed = USB_SPEED_FULL;
+
+	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		switch (ctrl->bRequest) {
+		case USB_REQ_SET_CONFIGURATION:
+			debug("usbf: set_cfg(%d)\n", value);
+			if (!value) {
+				/* Disable all endpoints other than EP0 */
+				writel(readl(&chip->regs->control) & ~D_USB_CONF,
+				       &chip->regs->control);
+
+				chip->state = USB_STATE_ADDRESS;
+			} else {
+				/* Enable all endpoints */
+				writel(readl(&chip->regs->control) | D_USB_CONF,
+				       &chip->regs->control);
+
+				chip->state = USB_STATE_CONFIGURED;
+			}
+			ret = CX_IDLE;
+			break;
+
+		case USB_REQ_SET_ADDRESS:
+			debug("usbf: set_addr(0x%04X)\n", ctrl->wValue);
+			writel(value << 16, &chip->regs->address);
+			chip->state = USB_STATE_ADDRESS;
+			ret = CX_FINISH;
+			break;
+
+		case USB_REQ_CLEAR_FEATURE:
+			debug("usbf: clr_feature(%d, %d)\n",
+			      ctrl->bRequestType & 0x03, ctrl->wValue);
+			switch (ctrl->wValue) {
+			case 0:    /* [Endpoint] halt */
+				/* TODO ? */
+			/*	ep_reset(chip, ctrl->wIndex); */
+				printf("endpoint reset ?!?\n");
+				ret = CX_FINISH;
+				break;
+			case 1:    /* [Device] remote wake-up */
+			case 2:    /* [Device] test mode */
+			default:
+				ret = CX_STALL;
+				break;
+			}
+			break;
+
+		case USB_REQ_SET_FEATURE:
+			debug("usbf: set_feature(%d, %d)\n",
+			      ctrl->wValue, ctrl->wIndex & 0xf);
+			switch (ctrl->wValue) {
+			case 0:    /* Endpoint Halt */
+				ret = CX_FINISH;
+				/* TODO */
+			/*	id = ctrl->wIndex & 0xf; */
+				break;
+			case 1:    /* Remote Wakeup */
+			case 2:    /* Test Mode */
+			default:
+				ret = CX_STALL;
+				break;
+			}
+			break;
+		case USB_REQ_GET_STATUS:
+			debug("usbf: get_status(%d, %d, type %d)\n",
+			      ctrl->wValue, ctrl->wIndex,
+			      ctrl->bRequestType & USB_RECIP_MASK);
+			chip->setup[0] = 0;
+			switch (ctrl->bRequestType & USB_RECIP_MASK) {
+			case USB_RECIP_DEVICE:
+				chip->setup[0] = 1 << USB_DEVICE_SELF_POWERED;
+				break;
+			}
+			/* mark it as static, don't 'free' it */
+			chip->setup_reply.req.complete = NULL;
+			chip->setup_reply.req.buf = &chip->setup;
+			chip->setup_reply.req.length = 2;
+			usb_ep_queue(&ep->ep, &chip->setup_reply.req, 0);
+			ret = CX_FINISH;
+			break;
+		case USB_REQ_SET_DESCRIPTOR:
+			debug("usbf: set_descriptor\n");
+			break;
+		}
+	} /* if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) */
+
+	if (ret == CX_IDLE && chip->driver->setup) {
+		if (chip->driver->setup(&chip->gadget, ctrl) < 0)
+			ret = CX_STALL;
+		else
+			ret = CX_FINISH;
+	}
+
+	switch (ret) {
+	case CX_FINISH:
+		break;
+	case CX_STALL:
+		usbf_ep0_stall(ep_reg);
+		debug("usbf: cx_stall!\n");
+		break;
+	case CX_IDLE:
+		TRACE("usbf: cx_idle?\n");
+	default:
+		break;
+	}
+}
+
+static void usbf_ep0_process_current_io(
+	struct f_endpoint *ep)
+{
+	if (!list_empty(&ep->queue)) {
+		int res = 0;
+		struct f_req *req = list_first_entry(&ep->queue,
+					struct f_req, queue);
+		if (req->process)
+			res = req->process(ep, req);
+		if (res == 0) {
+			if (req->req.complete)
+				req->req.complete(&ep->ep, &req->req);
+
+			if (req->req.status == 0)
+				list_del_init(&req->queue);
+		}
+	}
+}
+
+static int usbf_req_is_control_no_data(struct usb_ctrlrequest *ctrl)
+{
+	return (ctrl->wLength == 0);
+}
+
+static int usbf_req_is_control_read(struct usb_ctrlrequest *ctrl)
+{
+	if (ctrl->wLength && (ctrl->bRequestType & USB_DIR_IN))
+		return 1;
+	return 0;
+}
+
+static int usbf_req_is_control_write(struct usb_ctrlrequest *ctrl)
+{
+	if (ctrl->wLength && !(ctrl->bRequestType & USB_DIR_IN))
+		return 1;
+	return 0;
+}
+
+static void usbf_ep0_interrupt(
+	struct f_endpoint *ep)
+{
+	struct f_regs_ep0 *ep_reg = &ep->chip->regs->ep0;
+	struct f_drv *chip = ep->chip;
+	struct usb_ctrlrequest *ctrl = (struct usb_ctrlrequest *)chip->setup;
+	uint32_t status = readl(&ep_reg->status);
+
+	TRACE("%s status %08x control %08x\n", __func__, status,
+	      readl(&ep_reg->control));
+
+	if (status & D_EP0_OUT_INT) {
+		TRACE("%s OUT (length %d) direction %s\n", __func__,
+		      ep->chip->regs->ep0.length,
+		      (ep->desc->bEndpointAddress & USB_DIR_IN) ?
+				"input" : "output");
+		writel(~D_EP0_OUT_INT, &ep_reg->status);
+
+		usbf_ep0_process_current_io(ep);
+	}
+
+	if (status & D_EP0_SETUP_INT) {
+		writel(~D_EP0_SETUP_INT, &ep_reg->status);
+
+		chip->setup[0] = readl(&ep->chip->regs->setup_data0);
+		chip->setup[1] = readl(&ep->chip->regs->setup_data1);
+
+		TRACE("%s SETUP %08x %08x dir %s len:%d\n", __func__,
+		      chip->setup[0], chip->setup[1],
+		      (ctrl->bRequestType & USB_DIR_IN) ? "input" : "output",
+		      readl(&ep->chip->regs->ep0.length));
+
+		if (usbf_req_is_control_write(ctrl)) {
+			usbf_ep0_clear_onak(ep_reg);
+		}
+		if (usbf_req_is_control_read(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_IN_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+
+		usbf_ep0_setup(ep, ctrl);
+		usbf_ep0_process_current_io(ep);
+	}
+	if (status & D_EP0_STG_START_INT) {
+		writel(~D_EP0_STG_START_INT, &ep_reg->status);
+
+		TRACE("%s START %08x %08x (empty: %s)\n", __func__,
+		      chip->setup[0], chip->setup[1],
+		      (status & D_EP0_IN_EMPTY) ?
+				"IN empty" : "IN NOT empty");
+
+		if (usbf_req_is_control_read(ctrl)) {
+			usbf_ep0_clear_onak(ep_reg);
+		}
+		if (usbf_req_is_control_write(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_OUT_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+		if (usbf_req_is_control_no_data(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_IN_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+
+		/* TODO, we should send a NULL packet for Control-No-Data, but read a NULL packet for Control-Read */
+		usbf_ep0_send(ep, NULL);
+	}
+}
+
+static const struct f_endpoint_drv usbf_ep0_callbacks = {
+	.enable = usbf_ep0_enable,
+	.disable = usbf_ep0_disable,
+	.set_maxpacket = NULL,
+	.recv = usbf_ep0_recv,
+	.send = usbf_ep0_send,
+	.interrupt = usbf_ep0_interrupt,
+};
+
+/*
+ * activate/deactivate link with host.
+ */
+static void pullup(struct f_drv *chip, int is_on)
+{
+	struct f_regs *regs = chip->regs;
+
+	if (is_on) {
+		if (!chip->pullup) {
+			chip->state = USB_STATE_POWERED;
+			chip->pullup = 1;
+
+			writel((readl(&regs->control) & ~D_USB_CONNECTB) |
+				D_USB_PUE2, &regs->control);
+		}
+	} else {
+		chip->state = USB_STATE_NOTATTACHED;
+		chip->pullup = 0;
+		chip->addr = 0;
+		writel((readl(&regs->control) & ~D_USB_PUE2) |
+			D_USB_CONNECTB, &regs->control);
+	}
+}
+
+static int f_pullup(struct usb_gadget *_gadget, int is_on)
+{
+	struct f_drv *chip = container_of(_gadget, struct f_drv, gadget);
+
+	debug("%s: pullup=%d\n", __func__, is_on);
+
+	pullup(chip, is_on);
+
+	return 0;
+}
+
+static struct usb_gadget_ops f_gadget_ops = {
+	.pullup = f_pullup,
+};
+
+/*
+ * USB Gadget Layer
+ */
+static int usbf_ep_enable(
+	struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_drv *chip = ep->chip;
+	struct f_regs *regs = chip->regs;
+	int irq_state;
+
+	TRACE("%s(%d) desctype %d max pktsize %d\n", __func__, ep->id,
+	      desc->bDescriptorType,
+	      le16_to_cpu(desc->wMaxPacketSize));
+	if (!_ep || !(desc && desc->bDescriptorType == USB_DT_ENDPOINT)) {
+		printf("%s: bad ep or descriptor\n", __func__);
+		return -EINVAL;
+	}
+
+	ep->desc = desc;
+	ep->ep.maxpacket = ep->id == 0 ?
+		CFG_EP0_MAX_PACKET_SIZE : CFG_EPX_MAX_PACKET_SIZE;
+
+	/* set max packet here */
+
+	irq_state = disable_interrupts();
+
+	/* enable interrupts for this endpoint */
+	writel(readl(&regs->int_enable) | (D_USB_EP0_EN << ep->id),
+	       &regs->int_enable);
+
+	if (ep->drv->enable)
+		ep->drv->enable(ep);
+	if (ep->drv->set_maxpacket)
+		ep->drv->set_maxpacket(ep);
+	ep->disabled = 0;
+
+	if (irq_state)
+		enable_interrupts();
+	return 0;
+}
+
+static int usbf_ep_disable(struct usb_ep *_ep)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+
+	if (ep->drv->disable)
+		ep->drv->disable(ep);
+	ep->desc = NULL;
+	ep->disabled = 1;
+	return 0;
+}
+
+static struct usb_request *usbf_ep_alloc_request(
+	struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct f_req *req = calloc(1, sizeof(*req));
+
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void usbf_ep_free_request(
+	struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct f_req *req;
+
+	req = container_of(_req, struct f_req, req);
+	free(req);
+}
+
+static int usbf_ep_queue(
+	struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_drv *chip = ep->chip;
+	struct f_req *req;
+
+	req = container_of(_req, struct f_req, req);
+	if (!_req || !_req->complete || !_req->buf ||
+	    !list_empty(&req->queue)) {
+		printf("%s: invalid request to ep%d\n", __func__, ep->id);
+		return -EINVAL;
+	}
+
+	if (!chip || chip->state == USB_STATE_SUSPENDED) {
+		printf("%s: request while chip suspended\n", __func__);
+		return -EINVAL;
+	}
+
+	req->req.actual = 0;
+	req->req.status = -EINPROGRESS;
+	if (ep->desc->bEndpointAddress == USB_DIR_IN)
+		req->process = ep->drv->send;
+	else
+		req->process = ep->drv->recv;
+
+	if (ep->id)
+		TRACE("%s %d, maxpacket %d len %d %s\n", __func__, ep->id,
+		      ep->ep.maxpacket, req->req.length,
+		      ep->desc->bEndpointAddress == USB_DIR_IN ?
+				"input" : "output");
+	if (req->req.length == 0) {
+		req->req.status = 0;
+		if (req->req.complete)
+			req->req.complete(&ep->ep, &req->req);
+		return 0;
+	}
+	list_add_tail(&req->queue, &ep->queue);
+
+	return 0;
+}
+
+static int usbf_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_req *req;
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req)
+		return -EINVAL;
+
+	/* remove the request */
+	list_del_init(&req->queue);
+
+	/* update status & invoke complete callback */
+	if (req->req.status == -EINPROGRESS) {
+		req->req.status = -ECONNRESET;
+		if (req->req.complete)
+			req->req.complete(_ep, &req->req);
+	}
+
+	return 0;
+}
+
+static int usbf_ep_halt(struct usb_ep *_ep, int halt)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	int ret = -1;
+
+	debug("%s: ep%d halt=%d\n", __func__, ep->id, halt);
+	if (ep->drv->halt)
+		ep->drv->halt(ep, halt);
+	return ret;
+}
+
+static struct usb_ep_ops ci_ep_ops = {
+	.enable         = usbf_ep_enable,
+	.disable        = usbf_ep_disable,
+	.queue          = usbf_ep_queue,
+	.dequeue        = usbf_ep_dequeue,
+	.set_halt       = usbf_ep_halt,
+	.alloc_request  = usbf_ep_alloc_request,
+	.free_request   = usbf_ep_free_request,
+};
+
+static struct f_drv controller = {
+	.regs = (void __iomem *)RZN1_USB_DEV_BASE,
+	.gadget = {
+		.name = "rzn1_usbf",
+		.ops = &f_gadget_ops,
+		.ep0 = &controller.ep[0].ep,
+		.speed = USB_SPEED_HIGH, /* USB_SPEED_UNKNOWN */
+		.is_dualspeed = 1,
+		.is_otg = 0,
+		.is_a_peripheral = 1,
+		.b_hnp_enable = 0,
+		.a_hnp_support = 0,
+		.a_alt_hnp_support = 0,
+	},
+};
+
+/*
+	There are two interrupt handlers for the USB function block
+ */
+
+static void usbf_interrupt_epc(void)
+{
+	struct f_drv *chip = &controller;
+	struct f_regs *regs = chip->regs;
+	uint32_t status = readl(&regs->int_status);
+	uint32_t raw_status = status;
+	int i;
+
+	if (!status)
+		return;
+
+	if (status & D_USB_USB_RST_INT) {
+		status &= ~D_USB_USB_RST_INT;
+		writel(status, &regs->int_status);
+		/* TODO clear endpoints buffers: EPx_CONTROL |= D_EPx_BCLR */
+		if (chip->gadget.speed != USB_SPEED_UNKNOWN) {
+			chip->gadget.speed = USB_SPEED_UNKNOWN;
+			chip->driver->disconnect(&chip->gadget);
+		}
+	}
+	if (status & D_USB_SPEED_MODE_INT) {
+		debug("**** %s speed change\n", __func__);
+		status &= ~D_USB_SPEED_MODE_INT;
+		writel(status, &regs->int_status);
+		if ((readl(&chip->regs->status) & D_USB_SPEED_MODE) ==
+				D_USB_SPEED_MODE)
+			chip->gadget.speed = USB_SPEED_HIGH;
+		else
+			chip->gadget.speed = USB_SPEED_FULL;
+	}
+	if (status & D_USB_SPND_INT) {
+		status &= ~D_USB_SPND_INT;
+		writel(status, &regs->int_status);
+	}
+	if (status & D_USB_RSUM_INT) {
+		status &= ~D_USB_RSUM_INT;
+		writel(status, &regs->int_status);
+	}
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; i++) {
+		struct f_endpoint *ep = &chip->ep[i];
+		/* TODO, new callback for reset? */
+		if (raw_status & D_USB_USB_RST_INT) {
+			struct f_regs_ep *ep_reg = ep->id == 0 ?
+				(struct f_regs_ep *)&regs->ep0 :
+				&regs->ep[ep->id - 1];
+			writel(readl(&ep_reg->control) | D_EP0_BCLR,
+			       &ep_reg->control);
+		}
+		/* speed change notification for endpoints */
+		if (raw_status & D_USB_SPEED_MODE_INT && ep->drv->set_maxpacket)
+			ep->drv->set_maxpacket(ep);
+		/* Interrupt notification */
+		if (status & (D_USB_EP0_INT << i) && ep->drv->interrupt)
+			ep->drv->interrupt(ep);
+	}
+}
+
+static void usbf_interrupt(void)
+{
+	struct f_drv *chip = &controller;
+	struct f_regs *regs = chip->regs;
+	uint32_t sysbint = readl(&regs->sysbint);
+
+	if ((sysbint & D_SYS_VBUS_INT) == D_SYS_VBUS_INT) {
+		uint32_t state = readl(&regs->control);
+		/* Interrupt factor clear */
+		sysbint |= D_SYS_VBUS_INT;
+		writel(sysbint, &regs->sysbint);
+		if ((readl(&regs->epctr) & D_SYS_VBUS_LEVEL) ==
+				D_SYS_VBUS_LEVEL) {
+			debug("%s plugged in\n", __func__);
+			/* Enable the USB signal to the Function PHY */
+			state      &= ~D_USB_CONNECTB;
+			/* D + signal Pull-up */
+			state      |=  D_USB_PUE2;
+		} else {
+			debug("%s plugged out\n", __func__);
+			/* disable the USB signal to the Function PHY */
+			state      |=  D_USB_CONNECTB;
+			/* Do not Pull-up the D +  */
+			state      &= ~D_USB_PUE2;
+			/* Disable the endpoint 0 */
+			state      &= ~D_USB_DEFAULT;
+			/* disable the other endpoint 0 */
+			state      &= ~D_USB_CONF;
+		}
+		writel(state, &regs->control);
+	}
+}
+
+int usb_gadget_handle_interrupts(int index)
+{
+	usbf_interrupt();
+	usbf_interrupt_epc();
+
+	return 0;
+}
+
+#ifdef CONFIG_USE_IRQ
+/* DEBUG hack here, ignore for the moment */
+struct pt_regs;
+int rzn1_set_irq_handler(
+	int irqn,
+	int (*handler)(int irqn, struct pt_regs *pt_regs, void *param),
+	void *param);
+
+static int irq_handler(int irqn, struct pt_regs *pt_regs, void *param)
+{
+	return 0;
+}
+#endif
+
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	int ret, i;
+	struct f_drv *chip = &controller;
+	static const char *ep_name[16] = {
+		"ep0", "ep1", "ep2", "ep3", "ep4", "ep5", "ep6", "ep7",
+		"ep8", "ep9", "ep10", "ep11", "ep12", "ep13", "ep14", "ep15",
+	};
+
+	if (!driver    || !driver->bind || !driver->setup) {
+		printf("%s: bad parameter.\n", __func__);
+		return -EINVAL;
+	}
+	INIT_LIST_HEAD(&chip->gadget.ep_list);
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint init = {
+			.ep = {
+				.name = ep_name[i],
+				.ops = &ci_ep_ops,
+				.maxpacket = CFG_EPX_MAX_PACKET_SIZE,
+			},
+			.id = i,
+			.disabled = 1,
+			.chip = chip,
+		};
+		struct f_endpoint *ep = chip->ep + i;
+
+		*ep = init;
+
+		INIT_LIST_HEAD(&ep->queue);
+
+		if (ep->id == 0) {
+			ep->drv = &usbf_ep0_callbacks;
+			ep->ep.maxpacket = CFG_EP0_MAX_PACKET_SIZE;
+		} else {
+#ifdef CONFIG_USBF_RENESAS_FULL
+			if (!usbf_epx_init(ep))
+				list_add_tail(&ep->ep.ep_list,
+					      &chip->gadget.ep_list);
+#endif
+		}
+	}
+#ifdef CONFIG_USE_IRQ
+	rzn1_set_irq_handler(32 + RZN1_IRQ_USBF_EPC, irq_handler, NULL);
+	rzn1_set_irq_handler(32 + RZN1_IRQ_USBF, irq_handler, NULL);
+
+	writel(D_SYS_VBUS_INTEN, &chip->regs->sysbinten);
+#endif
+
+	/* get out of reset */
+	writel(readl(&chip->regs->epctr) & ~((1 << 0)), &chip->regs->epctr);
+	writel(readl(&chip->regs->epctr) & ~((1 << 2)), &chip->regs->epctr);
+
+	writel(readl(&chip->regs->sysmctr) | D_SYS_WBURST_TYPE, &chip->regs->sysmctr);
+
+	writel(D_USB_INT_SEL | D_USB_SOF_RCV | D_USB_SOF_CLK_MODE, &chip->regs->control);
+
+	/* Enable mode change interrupts, and EP0 */
+	writel(D_USB_USB_RST_EN | D_USB_SPEED_MODE_EN | D_USB_EP0_EN,
+	       &chip->regs->int_enable);
+	/* Endpoint zero is always enabled anyway */
+	usbf_ep_enable(&chip->ep[0].ep, &ep0_desc);
+
+	ret = driver->bind(&chip->gadget);
+	if (ret) {
+		debug("%s: driver->bind() returned %d\n", __func__, ret);
+		return ret;
+	}
+	chip->driver = driver;
+
+	return ret;
+}
+
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct f_drv *chip = &controller;
+
+	/* remove the pullup, apparently putting the controller
+	 * in reset doesn't do it! */
+	pullup(chip, 0);
+	/* get back into reset */
+	writel(readl(&chip->regs->epctr) |
+	       ((1 << 0)), &chip->regs->epctr);
+	writel(readl(&chip->regs->epctr) |
+	       ((1 << 2)), &chip->regs->epctr);
+
+	return 0;
+}
diff --git a/drivers/usb/gadget/usbf-renesas.h b/drivers/usb/gadget/usbf-renesas.h
new file mode 100644
index 0000000..1665053
--- /dev/null
+++ b/drivers/usb/gadget/usbf-renesas.h
@@ -0,0 +1,530 @@
+/*
+ * Renesas USB Device/Function driver
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ */
+
+#ifndef __USBF_RENESAS_H__
+#define __USBF_RENESAS_H__
+
+#include <linux/types.h>
+
+#ifdef CONFIG_USBF_RENESAS_FULL
+#define CFG_NUM_ENDPOINTS		16
+#else
+#define CFG_NUM_ENDPOINTS		1
+#endif
+
+#define CFG_EP0_MAX_PACKET_SIZE		64
+#define CFG_EPX_MAX_PACKET_SIZE		512
+#define CFG_EPX_MAX_PACKET_CNT		256
+#define EP0_RAM_USED			0x20	/* 32 bits words */
+
+#ifdef DEBUG
+#define TRACE(...) printf(__VA_ARGS__)
+#else
+#define TRACE(...)
+#endif
+
+/*
+ * io block register for endpoint zero. Annoyingly enough, it differs
+ * from all the other endpoints.
+ */
+struct f_regs_ep0 {
+	/* these 3 are common with every other endpoint */
+	uint32_t control;		/* EP0 control register */
+	uint32_t status;		/* EP0 status register */
+	uint32_t int_enable;		/* EP0 interrupt enable register */
+
+	uint32_t length;		/* EP0 length register */
+	uint32_t read;			/* EP0 read register */
+	uint32_t write;			/* EP0 write register */
+};
+
+/*
+ * io block register for endpoint 1-15
+ */
+struct f_regs_ep {
+	/* these 3 are common with every other endpoint */
+	uint32_t control;		/* EPn control register */
+	uint32_t status;		/* EPn status register */
+	uint32_t int_enable;		/* EPn interrupt enable register */
+
+	uint32_t dma_ctrl;		/* EPn DMA control register */
+	uint32_t pckt_adrs;		/* EPn max packet & base address register */
+	uint32_t len_dcnt;		/* EPn length & DMA count register */
+	uint32_t read;			/* EPn read register */
+	uint32_t write;			/* EPn write register */
+};
+
+/* IO registers for the USB device Ip block */
+struct f_regs {
+	/* The first block of register is 0x1000 long, so we make sure
+	 * it is padded to that size. Use of anonymous union makes it
+	 * painless here
+	 */
+	union {
+		struct {
+			uint32_t control;		/* USB Control register */
+			uint32_t status;		/* USB Status register */
+			uint32_t address;		/* Frame number & USB address register */
+			uint32_t reserved;
+			uint32_t test_control;		/* TEST control register */
+			uint32_t reserved1;
+			uint32_t setup_data0;		/* Setup Data 0 register */
+			uint32_t setup_data1;		/* Setup Data 1 register */
+			uint32_t int_status;		/* USB interrupt status register */
+			uint32_t int_enable;		/* USB interrupt enable register */
+			struct f_regs_ep0 ep0;
+			/* Index zero in this table is for EP1's register, not EP0 */
+			struct f_regs_ep ep[15];
+		};
+		uint8_t pad[0x1000];
+	};
+	/* Follows are the system registers at offset 0x1000 */
+	union {
+		struct {
+			union {	/* Offset 0x1000 */
+				struct {
+					uint32_t syssctr;		/* AHBSCTR register */
+					uint32_t sysmctr;		/* AHBMCTR register */
+					uint32_t sysbint;		/* AHBBINT register */
+					uint32_t sysbinten;		/* AHBBINTEN register */
+					uint32_t epctr;			/* EPCTR register */
+				};
+				uint8_t pada[0x20];
+			};
+			/* Offset 0x1020 */
+			uint32_t usbssver;
+			uint32_t usbssconf;
+		};
+		uint8_t	padb[0x100];
+	};
+};
+
+
+struct f_req;
+struct f_endpoint;
+struct f_drv;
+
+/* processor callback for the requests, return 0 when request is done */
+typedef int (*f_req_process_p)(struct f_endpoint *ep, struct f_req *);
+
+/* Endpoint 'driver', allows top level code to be endpoint agnostic */
+struct f_endpoint_drv {
+	int (*enable)(struct f_endpoint *ep);
+	void (*disable)(struct f_endpoint *ep);
+
+	void (*set_maxpacket)(struct f_endpoint *ep);
+
+	/* receive and send callbacks for this kind of endpoint */
+	f_req_process_p recv;
+	f_req_process_p send;
+	/* handle interrupt status changes */
+	void (*interrupt)(struct f_endpoint *ep);
+
+	void (*halt)(struct f_endpoint *ep, int halt);
+};
+
+/*
+ * USB Queued request, can be read/write, and will definitely be
+ * bigger than the max packet in an endpoint. the 'process' callback
+ * is called repeatedly to fulfill the request (ie, req->actual ==
+ * req->length) and will return 0 when it is, it is then ready to
+ * be 'completed' by the upper layer
+ */
+struct f_req {
+	struct usb_request		req;
+	struct list_head		queue;
+	/* callback used to receive or send this request */
+	f_req_process_p			process;
+};
+
+/* USB Endpoint structure, with callbacks for send/receive etc */
+struct f_endpoint {
+	struct usb_ep			ep;
+	/* endpoint specific callbacks */
+	const struct f_endpoint_drv	*drv;
+	struct list_head		queue;
+	const struct usb_endpoint_descriptor *desc;
+	struct f_drv			*chip;
+	uint8_t				id;
+	uint8_t				disabled;
+};
+
+struct f_drv {
+	struct usb_gadget		gadget;
+	struct usb_gadget_driver	*driver;
+	struct f_regs			*regs;
+	struct f_endpoint		ep[CFG_NUM_ENDPOINTS];
+	int				pullup;
+	enum usb_device_state		state;
+	uint16_t			addr;
+
+	/* for control messages caching */
+	uint32_t			setup[2];
+	struct f_req			setup_reply;
+};
+
+#ifdef CONFIG_USBF_RENESAS_FULL
+int usbf_epx_init(struct f_endpoint *ep);
+#endif
+
+/*=========================================================================*/
+/* USB_CONTROL [0x000] */
+/*=========================================================================*/
+enum {
+	D_USB_F_RST				= (1 << 0),
+	D_USB_PHY_RST				= (1 << 1),
+	D_USB_PUE2				= (1 << 2),
+	D_USB_CONNECTB				= (1 << 3),
+	D_USB_DEFAULT				= (1 << 4),
+	D_USB_CONF				= (1 << 5),
+	D_USB_SUSPEND				= (1 << 6),
+	D_USB_RSUM_IN				= (1 << 7),
+	D_USB_SOF_RCV				= (1 << 8),
+	D_USB_CONSTFS				= (1 << 9),
+	D_USB_INT_SEL				= (1 << 10),
+	D_USB_SOF_CLK_MODE			= (1 << 11),
+	D_USB_USBTESTMODE			= (1 << 16) | (1 << 17) |
+							(1 << 18),
+};
+
+/*=========================================================================*/
+/* USB_STATUS [0x004] */
+/*=========================================================================*/
+enum {
+	D_USB_VBUS_LEVEL			= (1 << 0),
+	D_USB_RSUM_OUT				= (1 << 1),
+	D_USB_SPND_OUT				= (1 << 2),
+	D_USB_USB_RST				= (1 << 3),
+/*	D_USB_DEFAULT				= (1 << 4),*/
+	D_USB_CONF_ST				= (1 << 5),
+	D_USB_SPEED_MODE			= (1 << 6),
+};
+
+/*=========================================================================*/
+/* USB_ADDRESS [0x008] */
+/*=========================================================================*/
+enum {
+	D_USB_SOF_STATUS			= (1 << 15),
+	D_USB_USB_ADDR				= 0x007F0000,
+};
+
+/*=========================================================================*/
+/* USB_INT_STA [0x020] */
+/*=========================================================================*/
+enum {
+/*	D_USB_VBUS_LEVEL			= (1 << 0), */
+	D_USB_RSUM_INT				= (1 << 1),
+	D_USB_SPND_INT				= (1 << 2),
+	D_USB_USB_RST_INT			= (1 << 3),
+	D_USB_SOF_INT				= (1 << 4),
+	D_USB_SOF_ERROR_INT			= (1 << 5),
+	D_USB_SPEED_MODE_INT			= (1 << 6),
+	D_USB_VBUS_INT				= (1 << 7),
+	D_USB_EP0_INT				= (1 << 8),
+	D_USB_EP1_INT				= (1 << 9),
+	D_USB_EP2_INT				= (1 << 10),
+	D_USB_EP3_INT				= (1 << 11),
+	D_USB_EP4_INT				= (1 << 12),
+	D_USB_EP5_INT				= (1 << 13),
+	D_USB_EP6_INT				= (1 << 14),
+	D_USB_EP7_INT				= (1 << 15),
+	D_USB_EP8_INT				= (1 << 16),
+	D_USB_EP9_INT				= (1 << 17),
+	D_USB_EPN_INT				= 0x00FFFF00,
+};
+
+/*=========================================================================*/
+/* USB_INT_ENA [0x024] */
+/*=========================================================================*/
+enum {
+	D_USB_RSUM_EN				= (1 << 1),
+	D_USB_SPND_EN				= (1 << 2),
+	D_USB_USB_RST_EN			= (1 << 3),
+	D_USB_SOF_EN				= (1 << 4),
+	D_USB_SOF_ERROR_EN			= (1 << 5),
+	D_USB_SPEED_MODE_EN			= (1 << 6),
+	D_USB_VBUS_EN				= (1 << 7),
+	D_USB_EP0_EN				= (1 << 8),
+	D_USB_EP1_EN				= (1 << 9),
+	D_USB_EP2_EN				= (1 << 10),
+	D_USB_EP3_EN				= (1 << 11),
+	D_USB_EP4_EN				= (1 << 12),
+	D_USB_EP5_EN				= (1 << 13),
+	D_USB_EP6_EN				= (1 << 14),
+	D_USB_EP7_EN				= (1 << 15),
+	D_USB_EP8_EN				= (1 << 16),
+	D_USB_EP9_EN				= (1 << 17),
+	D_USB_EPN_EN				= 0x00FFFF00,
+};
+
+/*=========================================================================*/
+/* EP0_CONTROL [0x028] */
+/*=========================================================================*/
+enum {
+	D_EP0_ONAK				= (1 << 0),
+	D_EP0_INAK				= (1 << 1),
+	D_EP0_STL				= (1 << 2),
+	D_EP0_PERR_NAK_CLR			= (1 << 3),
+	D_EP0_INAK_EN				= (1 << 4),
+	D_EP0_DW				= (1 << 5) | (1 << 6),
+	D_EP0_DEND				= (1 << 7),
+	D_EP0_BCLR				= (1 << 8),
+	D_EP0_PIDCLR				= (1 << 9),
+	D_EP0_AUTO				= (1 << 16),
+	D_EP0_OVERSEL				= (1 << 17),
+	D_EP0_STGSEL				= (1 << 18),
+};
+
+/*=========================================================================*/
+/* EP0_STATUS [0x02C] */
+/*=========================================================================*/
+enum {
+	D_EP0_SETUP_INT				= (1 << 0),
+	D_EP0_STG_START_INT			= (1 << 1),
+	D_EP0_STG_END_INT			= (1 << 2),
+	D_EP0_STALL_INT				= (1 << 3),
+	D_EP0_IN_INT				= (1 << 4),
+	D_EP0_OUT_INT				= (1 << 5),
+	D_EP0_OUT_OR_INT			= (1 << 6),
+	D_EP0_OUT_NULL_INT			= (1 << 7),
+	D_EP0_IN_EMPTY				= (1 << 8),
+	D_EP0_IN_FULL				= (1 << 9),
+	D_EP0_IN_DATA				= (1 << 10),
+	D_EP0_IN_NAK_INT			= (1 << 11),
+	D_EP0_OUT_EMPTY				= (1 << 12),
+	D_EP0_OUT_FULL				= (1 << 13),
+	D_EP0_OUT_NULL				= (1 << 14),
+	D_EP0_OUT_NAK_INT			= (1 << 15),
+	D_EP0_PERR_NAK_INT			= (1 << 16),
+	D_EP0_PERR_NAK				= (1 << 17),
+	D_EP0_PID				= (1 << 18),
+};
+
+/*=========================================================================*/
+/* EP0_INT_ENA [0x030] */
+/*=========================================================================*/
+enum {
+	D_EP0_SETUP_EN				= (1 << 0),
+	D_EP0_STG_START_EN			= (1 << 1),
+	D_EP0_STG_END_EN			= (1 << 2),
+	D_EP0_STALL_EN				= (1 << 3),
+	D_EP0_IN_EN				= (1 << 4),
+	D_EP0_OUT_EN				= (1 << 5),
+	D_EP0_OUT_OR_EN				= (1 << 6),
+	D_EP0_OUT_NULL_EN			= (1 << 7),
+	D_EP0_IN_NAK_EN				= (1 << 11),
+	D_EP0_OUT_NAK_EN			= (1 << 15),
+	D_EP0_PERR_NAK_EN			= (1 << 16),
+};
+
+/*=========================================================================*/
+/* EP0_LENGTH [0x034] */
+/*=========================================================================*/
+enum {
+	D_EP0_LDATA				= 0x0000007F,
+};
+
+/*=========================================================================*/
+/* EPN_CONTROL_BIT */
+/*=========================================================================*/
+enum {
+	D_EPN_ONAK				= (1 << 0),
+	D_EPN_OSTL				= (1 << 2),
+	D_EPN_ISTL				= (1 << 3),
+	D_EPN_OSTL_EN				= (1 << 4),
+	D_EPN_DW				= (1 << 5) | (1 << 6),
+	D_EPN_DEND				= (1 << 7),
+	D_EPN_CBCLR				= (1 << 8),
+	D_EPN_BCLR				= (1 << 9),
+	D_EPN_OPIDCLR				= (1 << 10),
+	D_EPN_IPIDCLR				= (1 << 11),
+	D_EPN_AUTO				= (1 << 16),
+	D_EPN_OVERSEL				= (1 << 17),
+	D_EPN_MODE				= (1 << 24) | (1 << 25),
+	D_EPN_DIR0				= (1 << 26),
+	D_EPN_BUF_TYPE				= (1 << 30),
+	D_EPN_EN				= (1 << 31),
+};
+
+/*=========================================================================*/
+/* EPN_STATUS_BIT */
+/*=========================================================================*/
+enum {
+	D_EPN_IN_EMPTY				= (1 << 0),
+	D_EPN_IN_FULL				= (1 << 1),
+	D_EPN_IN_DATA				= (1 << 2),
+	D_EPN_IN_INT				= (1 << 3),
+	D_EPN_IN_STALL_INT			= (1 << 4),
+	D_EPN_IN_NAK_ERR_INT			= (1 << 5),
+	D_EPN_IN_END_INT			= (1 << 7),
+	D_EPN_IPID				= (1 << 10),
+	D_EPN_OUT_EMPTY				= (1 << 16),
+	D_EPN_OUT_FULL				= (1 << 17),
+	D_EPN_OUT_NULL_INT			= (1 << 18),
+	D_EPN_OUT_INT				= (1 << 19),
+	D_EPN_OUT_STALL_INT			= (1 << 20),
+	D_EPN_OUT_NAK_ERR_INT			= (1 << 21),
+	D_EPN_OUT_OR_INT			= (1 << 22),
+	D_EPN_OUT_END_INT			= (1 << 23),
+	D_EPN_OPID				= (1 << 28),
+};
+
+/*=========================================================================*/
+/* EPN_INT_ENA */
+/*=========================================================================*/
+enum {
+	D_EPN_IN_EN				= (1 << 3),
+	D_EPN_IN_STALL_EN			= (1 << 4),
+	D_EPN_IN_NAK_ERR_EN			= (1 << 5),
+	D_EPN_IN_END_EN				= (1 << 7),
+	D_EPN_OUT_NULL_EN			= (1 << 18),
+	D_EPN_OUT_EN				= (1 << 19),
+	D_EPN_OUT_STALL_EN			= (1 << 20),
+	D_EPN_OUT_NAK_ERR_EN			= (1 << 21),
+	D_EPN_OUT_OR_EN				= (1 << 22),
+	D_EPN_OUT_END_EN			= (1 << 23),
+};
+
+/*=========================================================================*/
+/* EPN_DMA_CTRL */
+/*=========================================================================*/
+enum {
+	D_EPN_DMAMODE0				= (1 << 0),
+	D_EPN_DMAMODE2				= (1 << 2),
+	D_EPN_DMA_EN				= (1 << 4),
+	D_EPN_STOP_SET				= (1 << 8),
+	D_EPN_BURST_SET				= (1 << 9),
+	D_EPN_DEND_SET				= (1 << 10),
+	D_EPN_STOP_MODE				= (1 << 11),
+	D_EPN_BUS_SEL				= (1 << 12) | (1 << 13),
+};
+
+/*=========================================================================*/
+/* EPN_PCKT_ADRS */
+/*=========================================================================*/
+enum {
+	D_EPN_MPKT				= 0x000007FF,
+	D_EPN_BASEAD				= 0x1FFF0000,
+};
+
+/*=========================================================================*/
+/* EPN_LEN_DCNT */
+/*=========================================================================*/
+enum {
+	D_EPN_LDATA				= 0x000007FF,
+	D_EPN_DMACNT				= 0x01FF0000,
+};
+
+
+/*=========================================================================*/
+/* SYSSCTR [0x1000] */
+/*=========================================================================*/
+enum {
+	D_SYS_WAIT_MODE				= (1 << 0),
+	D_SYS_NOT_RETRY_MASTER			= 0xFFFF0000,
+};
+
+/*=========================================================================*/
+/* SYSMCTR [0x1004] */
+/*=========================================================================*/
+enum {
+	D_SYS_ARBITER_CTR			= (1 << 31),
+	D_SYS_WBURST_TYPE			= (1 << 2),
+};
+
+/*=========================================================================*/
+/* SYSBINT [0x1008] */
+/*=========================================================================*/
+enum {
+	D_SYS_ERR_MASTER			= 0x0000000F,
+	D_SYS_SBUS_ERRINT0			= (1 << 4),
+	D_SYS_SBUS_ERRINT1			= (1 << 5),
+	D_SYS_MBUS_ERRINT			= (1 << 6),
+	D_SYS_VBUS_INT				= (1 << 13),
+	D_SYS_DMA_ENDINT_EP1			= (1 << 17),
+	D_SYS_DMA_ENDINT_EP2			= (1 << 18),
+	D_SYS_DMA_ENDINT_EP3			= (1 << 19),
+	D_SYS_DMA_ENDINT_EP4			= (1 << 20),
+	D_SYS_DMA_ENDINT_EP5			= (1 << 21),
+	D_SYS_DMA_ENDINT_EP6			= (1 << 22),
+	D_SYS_DMA_ENDINT_EP7			= (1 << 23),
+	D_SYS_DMA_ENDINT_EP8			= (1 << 24),
+	D_SYS_DMA_ENDINT_EP9			= (1 << 25),
+	D_SYS_DMA_ENDINT_EPN			= 0xFFFE0000,
+};
+
+/*=========================================================================*/
+/* SYSBINTEN [ 0x100C ] */
+/*=========================================================================*/
+enum {
+	D_SYS_SBUS_ERRINT0EN			= (1 << 4),
+	D_SYS_SBUS_ERRINT1EN			= (1 << 5),
+	D_SYS_MBUS_ERRINTEN			= (1 << 6),
+	D_SYS_VBUS_INTEN			= (1 << 13),
+	D_SYS_DMA_ENDINTEN_EP1			= (1 << 17),
+	D_SYS_DMA_ENDINTEN_EP2			= (1 << 18),
+	D_SYS_DMA_ENDINTEN_EP3			= (1 << 19),
+	D_SYS_DMA_ENDINTEN_EP4			= (1 << 20),
+	D_SYS_DMA_ENDINTEN_EP5			= (1 << 21),
+	D_SYS_DMA_ENDINTEN_EP6			= (1 << 22),
+	D_SYS_DMA_ENDINTEN_EP7			= (1 << 23),
+	D_SYS_DMA_ENDINTEN_EP8			= (1 << 24),
+	D_SYS_DMA_ENDINTEN_EP9			= (1 << 25),
+	D_SYS_DMA_ENDINTEN_EPN			= 0xFFFE0000,
+};
+
+/*=========================================================================*/
+/* EPCTR [ 0x1010 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_EPC_RST				= (1 << 0),
+	D_SYS_USBH_RST				= (1 << 1),
+	D_SYS_PLL_RST				= (1 << 2),
+	D_SYS_PCICLK_MASK			= (1 << 3),
+	D_SYS_PLL_LOCK				= (1 << 4),
+	D_SYS_PLL_RESUME			= (1 << 5),
+	D_SYS_VBUS_LEVEL			= (1 << 8),
+	D_SYS_DIRPD				= (1 << 12),
+};
+
+/*=========================================================================*/
+/* USBSSVER [ 0x1020 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_SS_VER				= 0x000000FF,
+	D_SYS_EPC_VER				= 0x0000FF00,
+	D_SYS_SYSB_VER				= 0x00FF0000,
+};
+
+/*=========================================================================*/
+/* USBSSCONF [ 0x1024 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_DMA_AVAILABLE			= 0x0000FFFF,
+	D_SYS_EP_AVAILABLE			= 0xFFFF0000,
+};
+
+/*=========================================================================*/
+/* DCR1 */
+/*=========================================================================*/
+enum {
+	D_SYS_EPN_REQEN				= (1 << 0),
+	D_SYS_EPN_DIR0				= (1 << 1),
+	D_SYS_EPN_DMACNT			= 0x00FF0000,
+};
+
+/*=========================================================================*/
+/* DCR2 */
+/*=========================================================================*/
+enum {
+	D_SYS_EPN_MPKT				= 0x000007FF,
+	D_SYS_EPN_LMPKT				= 0x07FF0000,
+};
+
+#endif /* __USBF_RENESAS_H__ */
diff --git a/drivers/usb/host/ehci-rmobile.c b/drivers/usb/host/ehci-rmobile.c
index 7fe79ef..2381f7c 100644
--- a/drivers/usb/host/ehci-rmobile.c
+++ b/drivers/usb/host/ehci-rmobile.c
@@ -9,8 +9,10 @@
 
 #include <common.h>
 #include <asm/io.h>
-#include <asm/arch/ehci-rmobile.h>
+#include "ohci.h"
 #include "ehci.h"
+#include "ehci-rmobile.h"
+#include <pci.h>
 
 #if defined(CONFIG_R8A7740)
 static u32 usb_base_address[] = {
@@ -28,24 +30,32 @@ static u32 usb_base_address[] = {
 	0xEE080000,	/* USB0 (EHCI) */
 	0xEE0C0000,	/* USB1 */
 };
+#elif defined(CONFIG_ARCH_RZN1)
+static u32 usb_base_address[] = {
+	0x40020000,	/* USB0 (EHCI) */
+};
 #else
 #error rmobile EHCI USB driver not supported on this platform
 #endif
 
+#define EHCI_USBCMD_OFF		0x20
+#define EHCI_USBCMD_HCRESET	(1 << 1)
+
 int ehci_hcd_stop(int index)
 {
 	int i;
-	u32 base;
-	struct ahbcom_pci_bridge *ahbcom_pci;
+	u32 base, reg, ehci;
 
 	base = usb_base_address[index];
-	ahbcom_pci = (struct ahbcom_pci_bridge *)(base + AHBPCI_OFFSET);
-	writel(0, &ahbcom_pci->ahb_bus_ctr);
+	reg = base + PCI_CONF_AHBPCI_OFFSET;
+	ehci = base + EHCI_OFFSET;
+
+	writel(0, reg + RCAR_AHB_BUS_CTR_REG);
 
 	/* reset ehci */
-	setbits_le32(base + EHCI_USBCMD, CMD_RESET);
+	setbits_le32(ehci + EHCI_USBCMD_OFF, EHCI_USBCMD_HCRESET);
 	for (i = 100; i > 0; i--) {
-		if (!(readl(base + EHCI_USBCMD) & CMD_RESET))
+		if (!(readl(ehci + EHCI_USBCMD_OFF) & EHCI_USBCMD_HCRESET))
 			break;
 		udelay(100);
 	}
@@ -53,77 +63,143 @@ int ehci_hcd_stop(int index)
 	if (!i)
 		printf("error : ehci(%d) reset failed.\n", index);
 
+#if !defined(CONFIG_ARCH_RZN1)
+	/* Turn off IP clock */
 	if (index == (ARRAY_SIZE(usb_base_address) - 1))
 		setbits_le32(SMSTPCR7, SMSTPCR703);
+#endif
 
 	return 0;
 }
 
+static u32 pci_config_fn(u32 reg, int devfn, u32 addr)
+{
+	/* devfn 0 is the root */
+	/* devfn 1 is OHCI */
+	/* devfn 2 is ECHI */
+	u32 ctrl = devfn ? RCAR_AHBPCI_WIN1_DEVICE | RCAR_AHBPCI_WIN_CTR_CFG :
+		     RCAR_AHBPCI_WIN1_HOST | RCAR_AHBPCI_WIN_CTR_CFG;
+	u32 tmp = readl(reg + RCAR_AHBPCI_WIN1_CTR_REG);
+
+	if (tmp != ctrl)
+		writel(ctrl, reg + RCAR_AHBPCI_WIN1_CTR_REG);
+
+	/* this simple redirects to the ECHI or OCHI config space */
+	if (devfn)
+		addr += (devfn - 1) * 0x100;
+
+	return addr;
+}
+
+static void pci_writel_fn(u32 reg, int devfn, u32 val, u32 addr)
+{
+	addr = pci_config_fn(reg, devfn, addr);
+	writel(val, reg + addr);
+}
+
+static void pci_writew_fn(u32 reg, int devfn, u16 val, u32 addr)
+{
+	addr = pci_config_fn(reg, devfn, addr);
+	writew(val, reg + addr);
+}
+
+/*
+ * This code sets up the PCI Bridge so that there is:
+ *  * Two outbound (AHB to PCI) address windows:
+ *     a) the PCI Bridge Configuration registers
+ *     b) the OHCI/EHCI Configuration registers.
+ *  * One inbound (PCI to AHB) address window, so the OHCI/EHCI controller has
+ *    read/write access to the data in DDR.
+ */
 int ehci_hcd_init(int index, enum usb_init_type init,
 	struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 {
-	u32 base;
-	u32 phys_base;
+	u32 base, reg;
+	struct ohci_regs *rohci;
 	struct rmobile_ehci_reg *rehci;
-	struct ahbcom_pci_bridge *ahbcom_pci;
-	struct ahbconf_pci_bridge *ahbconf_pci;
-	struct ahb_pciconf *ahb_pciconf_ohci;
-	struct ahb_pciconf *ahb_pciconf_ehci;
 	uint32_t cap_base;
-
+	u32 val;
+	/* The mask applied to the window addr depends on the window size */
+#if !defined(CONFIG_SYS_STAY_IN_SRAM)
+	u32 win1_addr = CONFIG_SYS_SDRAM_BASE & 0xc0000000;
+#else
+	u32 win1_addr = CONFIG_SYS_SRAM_BASE & 0xc0000000;
+#endif
 	base = usb_base_address[index];
-	phys_base = base;
+
+#if !defined(CONFIG_ARCH_RZN1)
+	/* Turn on IP clock */
 	if (index == 0)
 		clrbits_le32(SMSTPCR7, SMSTPCR703);
+#endif
 
+	reg = base + PCI_CONF_AHBPCI_OFFSET;
+	rohci = (struct ohci_regs *)(base + OHCI_OFFSET);
 	rehci = (struct rmobile_ehci_reg *)(base + EHCI_OFFSET);
-	ahbcom_pci = (struct ahbcom_pci_bridge *)(base + AHBPCI_OFFSET);
-	ahbconf_pci =
-		(struct ahbconf_pci_bridge *)(base + PCI_CONF_AHBPCI_OFFSET);
-	ahb_pciconf_ohci = (struct ahb_pciconf *)(base + PCI_CONF_OHCI_OFFSET);
-	ahb_pciconf_ehci = (struct ahb_pciconf *)(base + PCI_CONF_EHCI_OFFSET);
-
-	/* Clock & Reset & Direct Power Down */
-	clrsetbits_le32(&ahbcom_pci->usbctr,
-			(DIRPD | PCICLK_MASK | USBH_RST), USBCTR_WIN_SIZE_1GB);
-	clrbits_le32(&ahbcom_pci->usbctr, PLL_RST);
-
-	/* AHB-PCI Bridge Communication Registers */
-	writel(AHB_BUS_CTR_INIT, &ahbcom_pci->ahb_bus_ctr);
-	writel((CONFIG_SYS_SDRAM_BASE & 0xf0000000) | PCIAHB_WIN_PREFETCH,
-	       &ahbcom_pci->pciahb_win1_ctr);
-	writel(0xf0000000 | PCIAHB_WIN_PREFETCH,
-	       &ahbcom_pci->pciahb_win2_ctr);
-	writel(phys_base | PCIWIN2_PCICMD, &ahbcom_pci->ahbpci_win2_ctr);
-
-	setbits_le32(&ahbcom_pci->pci_arbiter_ctr,
-		     PCIBP_MODE | PCIREQ1 | PCIREQ0);
-
-	/* PCI Configuration Registers for AHBPCI */
-	writel(PCIWIN1_PCICMD | AHB_CFG_AHBPCI,
-	       &ahbcom_pci->ahbpci_win1_ctr);
-	writel(phys_base + AHBPCI_OFFSET, &ahbconf_pci->basead);
-	writel(CONFIG_SYS_SDRAM_BASE & 0xf0000000, &ahbconf_pci->win1_basead);
-	writel(0xf0000000, &ahbconf_pci->win2_basead);
-	writel(SERREN | PERREN | MASTEREN | MEMEN,
-	       &ahbconf_pci->cmnd_sts);
-
-	/* PCI Configuration Registers for EHCI */
-	writel(PCIWIN1_PCICMD | AHB_CFG_HOST, &ahbcom_pci->ahbpci_win1_ctr);
-	writel(phys_base + OHCI_OFFSET, &ahb_pciconf_ohci->basead);
-	writel(phys_base + EHCI_OFFSET, &ahb_pciconf_ehci->basead);
-	writel(SERREN | PERREN | MASTEREN | MEMEN,
-	       &ahb_pciconf_ohci->cmnd_sts);
-	writel(SERREN | PERREN | MASTEREN | MEMEN,
-	       &ahb_pciconf_ehci->cmnd_sts);
-
-	/* Enable PCI interrupt */
-	setbits_le32(&ahbcom_pci->pci_int_enable,
-		     USBH_PMEEN | USBH_INTBEN | USBH_INTAEN);
+
+	/* Disable Direct Power Down State and assert reset */
+	val = readl(reg + RCAR_USBCTR_REG);
+	val &= ~RCAR_USBCTR_DIRPD;
+	val |= RCAR_USBCTR_USBH_RST;
+	writel(val, reg + RCAR_USBCTR_REG);
+	udelay(4);
+
+	/* De-assert reset and set PCIAHB window1 size */
+	val &= ~(RCAR_USBCTR_PCIAHB_WIN1_MASK | RCAR_USBCTR_PCICLK_MASK |
+		 RCAR_USBCTR_USBH_RST | RCAR_USBCTR_PLL_RST);
+	val |= RCAR_USBCTR_PCIAHB_WIN1_1G;
+	writel(val, reg + RCAR_USBCTR_REG);
+	udelay(100);
+
+	/* Configure AHB master and slave modes */
+	writel(RCAR_AHB_BUS_MODE, reg + RCAR_AHB_BUS_CTR_REG);
+
+	/* Configure PCI arbiter */
+	val = readl(reg + RCAR_PCI_ARBITER_CTR_REG);
+	val |= RCAR_PCI_ARBITER_PCIREQ0 | RCAR_PCI_ARBITER_PCIREQ1 |
+	       RCAR_PCI_ARBITER_PCIBP_MODE;
+	writel(val, reg + RCAR_PCI_ARBITER_CTR_REG);
+
+	/* PCI-AHB mapping */
+	writel(win1_addr | RCAR_PCIAHB_PREFETCH16,
+		  reg + RCAR_PCIAHB_WIN1_CTR_REG);
+
+	/* AHB-PCI mapping: OHCI/EHCI registers */
+	val = base | RCAR_AHBPCI_WIN_CTR_MEM;
+	writel(val, reg + RCAR_AHBPCI_WIN2_CTR_REG);
+
+	/* Configure interrupts */
+	writel(RCAR_PCI_INT_ALLERRORS, reg + RCAR_PCI_INT_ENABLE_REG);
+
+	/* Set AHB-PCI bridge PCI communication area address */
+	val = reg;
+	pci_writel_fn(reg, 0, val, PCI_BASE_ADDRESS_0);
+
+	/* Set PCI-AHB Window1 address */
+	val = win1_addr | PCI_BASE_ADDRESS_MEM_PREFETCH;
+	pci_writel_fn(reg, 0, val, PCI_BASE_ADDRESS_1);
+
+	val = PCI_COMMAND_SERR | PCI_COMMAND_PARITY | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;
+	pci_writew_fn(reg, 0, val, PCI_COMMAND);
+
+	/* PCI Configuration Registers for EHCI/OHCI */
+	pci_writel_fn(reg, 1, base + OHCI_OFFSET, PCI_BASE_ADDRESS_0);
+	pci_writew_fn(reg, 1, val, PCI_COMMAND);
+	pci_writel_fn(reg, 2, base + EHCI_OFFSET, PCI_BASE_ADDRESS_0);
+	pci_writew_fn(reg, 2, val, PCI_COMMAND);
 
 	*hccr = (struct ehci_hccr *)((uint32_t)&rehci->hciversion);
 	cap_base = ehci_readl(&(*hccr)->cr_capbase);
 	*hcor = (struct ehci_hcor *)((uint32_t)*hccr + HC_LENGTH(cap_base));
 
+
+	/* OHCI init */
+#define	USBH_POTPGT_WAIT_TIME			(0xFF << 24)
+#define	USBH_NOCP_ENABLE			0
+#define	USBH_OCPM_PORT_UNIT			BIT(11)
+#define	USBH_NPS_ALWAYS_POWERON			BIT(9)
+#define	USBH_PSM_PORT_UNIT			BIT(8)
+	writel(USBH_POTPGT_WAIT_TIME | USBH_NOCP_ENABLE | USBH_OCPM_PORT_UNIT | USBH_NPS_ALWAYS_POWERON | USBH_PSM_PORT_UNIT, &rohci->roothub.a);
+
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-rmobile.h b/drivers/usb/host/ehci-rmobile.h
new file mode 100644
index 0000000..d8b2a0e
--- /dev/null
+++ b/drivers/usb/host/ehci-rmobile.h
@@ -0,0 +1,122 @@
+/*
+ *  Copyright (C) 2013,2014 Renesas Electronics Corporation
+ *  Copyright (C) 2014 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
+ *
+ *  SPDX-License-Identifier:     GPL-2.0
+ */
+
+#ifndef __EHCI_RMOBILE_H__
+#define __EHCI_RMOBILE_H__
+
+/* Register offset */
+#define OHCI_OFFSET	0x00
+#define OHCI_SIZE	0x1000
+#define EHCI_OFFSET	0x1000
+#define EHCI_SIZE	0x1000
+
+#define SMSTPCR7        0xE615014C
+#define SMSTPCR703      (1 << 3)
+
+/* PCI Configuration Registers */
+#define PCI_CONF_OHCI_OFFSET	0x10000
+#define PCI_CONF_EHCI_OFFSET	0x10100
+struct ahb_pciconf {
+	u32 vid_did;
+	u32 cmnd_sts;
+	u32 rev;
+	u32 cache_line;
+	u32 basead;
+};
+
+/* PCI Configuration Registers for AHB-PCI Bridge Registers */
+#define PCI_CONF_AHBPCI_OFFSET	0x10000
+
+struct rmobile_ehci_reg {
+	u32 hciversion;		/* hciversion/caplength */
+	u32 hcsparams;		/* hcsparams */
+	u32 hccparams;		/* hccparams */
+	u32 hcsp_portroute;	/* hcsp_portroute */
+	u32 usbcmd;		/* usbcmd */
+	u32 usbsts;		/* usbsts */
+	u32 usbintr;		/* usbintr */
+	u32 frindex;		/* frindex */
+	u32 ctrldssegment;	/* ctrldssegment */
+	u32 periodiclistbase;	/* periodiclistbase */
+	u32 asynclistaddr;	/* asynclistaddr */
+	u32 dummy[9];
+	u32 configflag;		/* configflag */
+	u32 portsc;		/* portsc */
+};
+
+/* AHB-PCI Bridge PCI communication registers */
+#define RCAR_AHBPCI_PCICOM_OFFSET	0x800
+
+#define RCAR_PCIAHB_WIN1_CTR_REG	(RCAR_AHBPCI_PCICOM_OFFSET + 0x00)
+#define RCAR_PCIAHB_WIN2_CTR_REG	(RCAR_AHBPCI_PCICOM_OFFSET + 0x04)
+#define RCAR_PCIAHB_PREFETCH0		0x0
+#define RCAR_PCIAHB_PREFETCH4		0x1
+#define RCAR_PCIAHB_PREFETCH8		0x2
+#define RCAR_PCIAHB_PREFETCH16		0x3
+
+#define RCAR_AHBPCI_WIN1_CTR_REG	(RCAR_AHBPCI_PCICOM_OFFSET + 0x10)
+#define RCAR_AHBPCI_WIN2_CTR_REG	(RCAR_AHBPCI_PCICOM_OFFSET + 0x14)
+#define RCAR_AHBPCI_WIN_CTR_MEM		(3 << 1)
+#define RCAR_AHBPCI_WIN_CTR_CFG		(5 << 1)
+#define RCAR_AHBPCI_WIN1_HOST		(1 << 30)
+#define RCAR_AHBPCI_WIN1_DEVICE		(1 << 31)
+
+#define RCAR_PCI_INT_ENABLE_REG		(RCAR_AHBPCI_PCICOM_OFFSET + 0x20)
+#define RCAR_PCI_INT_STATUS_REG		(RCAR_AHBPCI_PCICOM_OFFSET + 0x24)
+#define RCAR_PCI_INT_SIGTABORT		(1 << 0)
+#define RCAR_PCI_INT_SIGRETABORT	(1 << 1)
+#define RCAR_PCI_INT_REMABORT		(1 << 2)
+#define RCAR_PCI_INT_PERR		(1 << 3)
+#define RCAR_PCI_INT_SIGSERR		(1 << 4)
+#define RCAR_PCI_INT_RESERR		(1 << 5)
+#define RCAR_PCI_INT_WIN1ERR		(1 << 12)
+#define RCAR_PCI_INT_WIN2ERR		(1 << 13)
+#define RCAR_PCI_INT_A			(1 << 16)
+#define RCAR_PCI_INT_B			(1 << 17)
+#define RCAR_PCI_INT_PME		(1 << 19)
+#define RCAR_PCI_INT_ALLERRORS (RCAR_PCI_INT_SIGTABORT		| \
+				RCAR_PCI_INT_SIGRETABORT	| \
+				RCAR_PCI_INT_SIGRETABORT	| \
+				RCAR_PCI_INT_REMABORT		| \
+				RCAR_PCI_INT_PERR		| \
+				RCAR_PCI_INT_SIGSERR		| \
+				RCAR_PCI_INT_RESERR		| \
+				RCAR_PCI_INT_WIN1ERR		| \
+				RCAR_PCI_INT_WIN2ERR)
+
+#define RCAR_AHB_BUS_CTR_REG		(RCAR_AHBPCI_PCICOM_OFFSET + 0x30)
+#define RCAR_AHB_BUS_MMODE_HTRANS	(1 << 0)
+#define RCAR_AHB_BUS_MMODE_BYTE_BURST	(1 << 1)
+#define RCAR_AHB_BUS_MMODE_WR_INCR	(1 << 2)
+#define RCAR_AHB_BUS_MMODE_HBUS_REQ	(1 << 7)
+#define RCAR_AHB_BUS_SMODE_READYCTR	(1 << 17)
+#define RCAR_AHB_BUS_MODE		(RCAR_AHB_BUS_MMODE_HTRANS |	\
+					RCAR_AHB_BUS_MMODE_BYTE_BURST |	\
+					RCAR_AHB_BUS_MMODE_WR_INCR |	\
+					RCAR_AHB_BUS_MMODE_HBUS_REQ |	\
+					RCAR_AHB_BUS_SMODE_READYCTR)
+
+#define RCAR_USBCTR_REG			(RCAR_AHBPCI_PCICOM_OFFSET + 0x34)
+#define RCAR_USBCTR_USBH_RST		(1 << 0)
+#define RCAR_USBCTR_PCICLK_MASK		(1 << 1)
+#define RCAR_USBCTR_PLL_RST		(1 << 2)
+#define RCAR_USBCTR_DIRPD		(1 << 8)
+#define RCAR_USBCTR_PCIAHB_WIN2_EN	(1 << 9)
+#define RCAR_USBCTR_PCIAHB_WIN1_256M	(0 << 10)
+#define RCAR_USBCTR_PCIAHB_WIN1_512M	(1 << 10)
+#define RCAR_USBCTR_PCIAHB_WIN1_1G	(2 << 10)
+#define RCAR_USBCTR_PCIAHB_WIN1_2G	(3 << 10)
+#define RCAR_USBCTR_PCIAHB_WIN1_MASK	(3 << 10)
+
+#define RCAR_PCI_ARBITER_CTR_REG	(RCAR_AHBPCI_PCICOM_OFFSET + 0x40)
+#define RCAR_PCI_ARBITER_PCIREQ0	(1 << 0)
+#define RCAR_PCI_ARBITER_PCIREQ1	(1 << 1)
+#define RCAR_PCI_ARBITER_PCIBP_MODE	(1 << 12)
+
+#define RCAR_PCI_UNIT_REV_REG		(RCAR_AHBPCI_PCICOM_OFFSET + 0x48)
+
+#endif /* __EHCI_RMOBILE_H__ */
diff --git a/include/asm-generic/global_data.h b/include/asm-generic/global_data.h
index e02863d..7a3b8e1 100644
--- a/include/asm-generic/global_data.h
+++ b/include/asm-generic/global_data.h
@@ -59,6 +59,11 @@ typedef struct global_data {
 	unsigned long start_addr_sp;	/* start_addr_stackpointer */
 	unsigned long reloc_off;
 	struct global_data *new_gd;	/* relocated global data */
+#ifdef CONFIG_SYS_STAY_IN_SRAM
+	/* if we don't relocate uboot, we cannot hardcode the malloc
+	 * pool to be under the uboot code, it's silly */
+	unsigned long malloc_pool_addr;
+#endif
 
 #ifdef CONFIG_DM
 	struct udevice	*dm_root;	/* Root instance for Driver Model */
diff --git a/include/cadence_ddr_ctrl.h b/include/cadence_ddr_ctrl.h
new file mode 100644
index 0000000..898d345
--- /dev/null
+++ b/include/cadence_ddr_ctrl.h
@@ -0,0 +1,130 @@
+/*
+ * Cadence DDR Controller
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ */
+
+#ifndef CADENCE_DDR_CTRL_H
+#define CADENCE_DDR_CTRL_H
+
+/**
+ * Initialise the Cadence DDR Controller, but doesn't start it.
+ *
+ * It sets up the controller so that all 4 AXI slave ports allow access to all
+ * of the DDR with the same settings. This means that:
+ *  - Full access permisions.
+ *  - All read/write priorities are set to 2.
+ *  - Bandwidth is set to 50%, overflow is allowed, i.e. it's a soft limit.
+ *
+ * @ddr_ctrl_base  Physical address of the DDR Controller.
+ * @async          0 if DDR clock is synchronous with the controller clock
+ *                 otherwise 1.
+ * @reg0           Pointer to array of 32-bit values to be written to registers
+ *                 0 to 87. The values are generated by Cadence TCL scripts.
+ * @reg350         Pointer to array of 32-bit values to be written to registers
+ *                 350 to 374. The values are generated by Cadence TCL scripts.
+ * @ddr_start_addr Physical address of the start of DDR.
+ * @ddr_size       Size of the DDR in bytes. The controller will set the port
+ *                 protection range to match this size.
+ */
+void cdns_ddr_ctrl_init(void *ddr_ctrl_base, int async,
+			const u32 *reg0, const u32 *reg350,
+			u32 ddr_start_addr, u32 ddr_size);
+
+/**
+ * Start the Cadence DDR Controller.
+ *
+ * @ddr_ctrl_base  Physical address of the DDR Controller.
+ */
+void cdns_ddr_ctrl_start(void *ddr_ctrl_base);
+
+/**
+ * Set the priority for read and write operations for a specific AXI slave port.
+ *
+ * @base      Physical address of the DDR Controller.
+ * @port      Port number. Range is 0 to 3.
+ * @read_pri  Priority for reads.  Range is 0 to 3, where 0 is highest priority.
+ * @write_pri Priority for writes. Range is 0 to 3, where 0 is highest priority.
+ */
+void cdns_ddr_set_port_rw_priority(void *base, int port,
+			  u8 read_pri, u8 write_pri, u8 fifo_type);
+
+/**
+ * Specify address range for a protection entry, for a specific AXI slave port.
+ *
+ * @base       Physical address of the DDR Controller.
+ * @port       Port number. Range is 0 to 3.
+ * @entry      The protection entry. Range is 0 to 15.
+ * @start_addr Physical of the address range, must be aligned to 16KB.
+ * @size       Size of the address range, must be multiple of 16KB.
+ */
+void cdns_ddr_enable_port_addr_range_x(void *base, int port, int entry,
+			      u32 addr_start, u32 size);
+
+/**
+ * Specify protection entry details, for a specific AXI slave port.
+ *
+ * See the hardware manual for details of the range check bits.
+ *
+ * @base       Physical address of the DDR Controller.
+ * @port       Port number. Range is 0 to 3.
+ * @entry      The protection entry. Range is 0 to 15.
+ */
+void cdns_ddr_enable_port_prot_x(void *base, int port, int entry,
+	u8 range_protection_bits,
+	u16 range_RID_check_bits,
+	u16 range_WID_check_bits,
+	u8 range_RID_check_bits_ID_lookup,
+	u8 range_WID_check_bits_ID_lookup);
+
+void set_port_bandwidth(void *base, int port,
+		        u8 max_percent, u8 overflow_ok);
+
+/* Standard JEDEC registers */
+#define MODE_REGISTER_MASK		(3 << 14)
+#define MODE_REGISTER_MR0		(0 << 14)
+#define MODE_REGISTER_MR1		(1 << 14)
+#define MODE_REGISTER_MR2		(2 << 14)
+#define MODE_REGISTER_MR3		(3 << 14)
+#define MR1_DRIVE_STRENGTH_MASK		((1 << 5) | (1 << 1))
+#define MR1_DRIVE_STRENGTH_34_OHMS	((0 << 5) | (1 << 1))
+#define MR1_DRIVE_STRENGTH_40_OHMS	((0 << 5) | (0 << 1))
+#define MR1_ODT_IMPEDANCE_MASK		((1 << 9) | (1 << 6) | (1 << 2))
+#define MR1_ODT_IMPEDANCE_60_OHMS	((0 << 9) | (0 << 6) | (1 << 2))
+#define MR1_ODT_IMPEDANCE_120_OHMS	((0 << 9) | (1 << 6) | (0 << 2))
+#define MR1_ODT_IMPEDANCE_40_OHMS	((0 << 9) | (1 << 6) | (1 << 2))
+#define MR1_ODT_IMPEDANCE_20_OHMS	((1 << 9) | (0 << 6) | (0 << 2))
+#define MR1_ODT_IMPEDANCE_30_OHMS	((1 << 9) | (0 << 6) | (1 << 2))
+#define MR2_DYNAMIC_ODT_MASK		(3 << 9)
+#define MR2_DYNAMIC_ODT_OFF		(0 << 9)
+#define MR2_SELF_REFRESH_TEMP_MASK	(1 << 7)
+#define MR2_SELF_REFRESH_TEMP_EXT	(1 << 7)
+
+/**
+ * Set certain fields of the JEDEC MR1 register.
+ */
+void cdns_ddr_set_mr1(void *base, int cs, u16 odt_impedance, u16 drive_strength);
+
+/**
+ * Set certain fields of the JEDEC MR2 register.
+ */
+void cdns_ddr_set_mr2(void *base, int cs, u16 dynamic_odt, u16 self_refresh_temp);
+
+/**
+ * Set ODT map of the DDR Controller.
+ */
+void cdns_ddr_set_odt_map(void *base, int cs, u16 odt_map);
+
+/**
+ * Set ODT settings in the DDR Controller.
+ */
+void cdns_ddr_set_odt_times(void *base, u8 TODTL_2CMD, u8 TODTH_WR, u8 TODTH_RD,
+			    u8 WR_TO_ODTH, u8 RD_TO_ODTH);
+
+void cdns_ddr_set_same_cs_delays(void *base, u8 r2r, u8 r2w, u8 w2r, u8 w2w);
+void cdns_ddr_set_diff_cs_delays(void *base, u8 r2r, u8 r2w, u8 w2r, u8 w2w);
+
+#endif
diff --git a/include/configs/rzn1-common.h b/include/configs/rzn1-common.h
new file mode 100644
index 0000000..82fed67
--- /dev/null
+++ b/include/configs/rzn1-common.h
@@ -0,0 +1,88 @@
+/*
+ * (C) Copyright 2016 Renesas Electronics Europe Ltd
+ * Phil Edworthy <phil.edworthy@renesas.com>
+ *
+ * Renesas RZ/N1 device configuration - you should not change these!
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __RZN1_COMMON_H
+#define __RZN1_COMMON_H
+
+#include "renesas/rzn1-memory-map.h"
+
+#define CONFIG_CORTEX_A7
+#define CONFIG_SMP_PEN_WFE
+#define CONFIG_BOARD_EARLY_INIT_F
+#ifndef CONFIG_ARCH_RZN1L
+ #define CONFIG_SYS_CACHELINE_SIZE	64	/* Needed by DFU */
+#endif
+
+/* Clocks. All but the ARM timer clock are used to program clock dividers */
+/* ARM timer clock, this is fixed */
+#define CONFIG_SYS_HZ_CLOCK		6250000
+#define CONFIG_SYS_CLK_FREQ		CONFIG_SYS_HZ_CLOCK
+
+/* 20MHz UART clock. This can generate 114942 baud, i.e 0.22% error. */
+#define CONFIG_SYS_NS16550_CLK		20000000
+
+/* 83.33MHz NAND Flash Ctrl clock, fastest as NAND is an async i/f. */
+#define CONFIG_SYS_NAND_CLOCK		83333333
+
+/* 250MHz QSPI Ctrl clock. The driver divides to meet the requested
+ * SPI clock. This sysctrl divider can divide by any number, whereas
+ * the divider in the IP can only divide by even numbers. However,
+ * Cadence recommend the IP divider is set to a minimum of 4 and the
+ * SPI clock maximum is 62.5MHz. With this setting you can get SPI
+ * clocks of 62.5MHz, 31.25MHz, etc.
+ */
+#define CONFIG_CQSPI_REF_CLK		250000000
+
+/* 83.33MHz I2C clock */
+#define IC_CLK				83
+
+/* 50MHz SDHCI clock */
+#define SDHC_CLK_MHZ			50
+
+
+/* SRAM */
+#define CONFIG_SYS_SRAM_BASE		RZN1_SRAM_ID_BASE
+#define CONFIG_SYS_SRAM_SIZE		RZN1_SRAM_ID_SIZE
+
+/* DDR Memory */
+#ifdef CONFIG_ARCH_RZN1D
+#define CONFIG_CADENCE_DDR_CTRL
+#define CONFIG_SYS_SDRAM_BASE		RZN1_V_DDR_BASE
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_SIZE		(256 * 1024 * 1024)
+#endif
+
+/* Serial */
+#define CONFIG_SYS_NS16550_MEM32
+
+/* Serial: sensible defaults */
+#define CONFIG_SYS_CBSIZE		256
+#define CONFIG_SYS_MAXARGS		16
+
+/* SPI */
+#define CONFIG_SPI_REGISTER_FLASH	/* required */
+
+/* NAND Flash */
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_NAND_BASE		RZN1_NAND_BASE
+#define CONFIG_SYS_NAND_SELF_INIT
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* NAND: sensible defaults */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+
+/* Timer */
+#define CONFIG_SYS_ARCH_TIMER
+
+/* Ethernet */
+#define CONFIG_DW_ALTDESCRIPTOR
+
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#endif /* RZN1_COMMON_H */
diff --git a/include/configs/rzn1-spl.h b/include/configs/rzn1-spl.h
new file mode 100644
index 0000000..2f9d70c
--- /dev/null
+++ b/include/configs/rzn1-spl.h
@@ -0,0 +1,26 @@
+/*
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ * Phil Edworthy <phil.edworthy@renesas.com>
+ *
+ * Renesas RZ/N1 device configuration for SPL builds - you should not change these!
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __RZN1_SPL_H
+#define __RZN1_SPL_H
+
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_BOARD_INIT
+
+/* This is required to fish the ethernet addresses from the environment */
+#if defined(RZN1_ENABLE_ETHERNET)
+#define CONFIG_SPL_ENV_SUPPORT
+#endif
+
+#if defined(CONFIG_SPL_NAND_LOAD)
+	#define CONFIG_SPL_NAND_DRIVERS
+	#define CONFIG_SPL_NAND_ONFI
+#endif
+
+#endif /* RZN1_SPL_H */
diff --git a/include/configs/rzn1d400-db.h b/include/configs/rzn1d400-db.h
new file mode 100644
index 0000000..ffa7ba5
--- /dev/null
+++ b/include/configs/rzn1d400-db.h
@@ -0,0 +1,256 @@
+/*
+ * Renesas RZN1-400  module (RZ/N1D device) base board
+ *
+ * (C) Copyright 2016 Renesas Electronics Europe Limited
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __RZN1D400_DB_H
+#define __RZN1D400_DB_H
+
+#include "rzn1-common.h"
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-sysctrl.h"
+
+#define CONFIG_BOARD_NAME	"Renesas RZN1D-DB"
+
+/*
+ * The BootROM will start the 2nd core and execute WFE. On an event it will
+ * read from the SYSCTRL BOOTADDR register. However, this register can only
+ * be accessed from SECURE mode. U-Boot switches to NONSEC mode by writing
+ * the address of _smp_pen to BOOTADDR, then kicking the 2nd CPU. The _smp_pen
+ * code switches mode, then runs the smp_waitloop code. The smp_waitloop code
+ * uses a second holding pen to allow so it can be used in NONSEC mode.
+ *
+ * U-Boot switches into NONSEC mode based on the "bootm_boot_mode" environment
+ * variable and the CONFIG_ARMV7_BOOT_SEC_DEFAULT symbol.
+ * However, RZ/N1 checks an additional "boot_hyp" environment variable to
+ * decide whether to switch to NONSEC+HYP mode.
+ */
+#define CONFIG_SMP_PEN_ADDR		smp_secondary_bootaddr
+#define CONFIG_OF_BOARD_SETUP
+
+#define CONFIG_SYS_THUMB_BUILD
+#define CONFIG_SYS_LONGHELP
+#define	CONFIG_CMDLINE_EDITING
+#define CONFIG_VERSION_VARIABLE		/* include version env variable */
+/* debug purpose */
+#define CONFIG_MD5
+#define CONFIG_CMD_MD5SUM
+
+/* Local helper symbols to enable/disable functionality */
+#define RZN1_ENABLE_I2C
+#define RZN1_ENABLE_GPIO
+#define RZN1_ENABLE_SDHC
+#define RZN1_ENABLE_ETHERNET
+#define RZN1_ENABLE_QSPI
+#undef RZN1_ENABLE_NAND
+#define RZN1_ENABLE_USBF
+#define RZN1_ENABLE_USBH
+#define RZN1_ENABLE_SPL
+
+/* ECC is disabled */
+/*#define RZN1_ENABLE_DDR_ECC*/
+
+/* SRAM */
+#define CONFIG_SYS_TEXT_BASE		0x200a0000
+#define CONFIG_SYS_STAY_IN_SRAM
+/* Very early stack, 320KB above start of U-Boot image */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_TEXT_BASE + (320 * 1024) - 4)
+#define CONFIG_SYS_MALLOC_LEN		(320 * 1024)
+
+/* DDR Memory */
+#ifdef RZN1_ENABLE_DDR_ECC
+#define CONFIG_CADENCE_DDR_CTRL_8BIT_WIDTH
+#define CONFIG_CADENCE_DDR_CTRL_ENABLE_ECC
+#define DDR_MAX_SIZE 			128
+#else
+#define DDR_MAX_SIZE 			256
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	(CONFIG_SYS_SDRAM_BASE)
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + DDR_MAX_SIZE * 1024 * 1024 - 1)
+#define	CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_SYS_MEMTEST_SCRATCH	RZN1_SRAM_SYS_BASE
+#undef CONFIG_SYS_SDRAM_SIZE
+#define CONFIG_SYS_SDRAM_SIZE		(DDR_MAX_SIZE * 1024 * 1024)
+
+/* This is not used by uboot startup, just by qspi etc */
+#define CONFIG_SYS_LOAD_ADDR		0x80008000
+
+/* Serial */
+#define CONFIG_BAUDRATE			115200
+
+
+/* ENV settings.
+ * To avoid U-Boot accessing NAND/QSPI, you might want to set NOWHERE instead.
+ */
+#if defined(RZN1_ENABLE_QSPI)
+ #define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+ #define CONFIG_ENV_IS_NOWHERE		/* Store ENV in memory only */
+#endif
+
+/* The ENV offsets match the DFU offsets for *_env */
+#if defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+ #define CONFIG_ENV_OFFSET		0xa0000
+ #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#endif
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+
+/***** SPI Flash *****/
+#if defined(RZN1_ENABLE_QSPI)
+ #define CONFIG_SF_DEFAULT_SPEED	62500000
+ #define CONFIG_ENV_SPI_MAX_HZ		62500000
+/* Reading using QuadIO can achieve 20% better throughput compared to QuadOutput
+ * on this board. However, the if you want to use the same U-Boot binary on
+ * boards with a second source SPI Flash, check that all use the same number of
+ * dummy cycles in this mode. If not, you may want to use the QuadOuput read
+ * command instead */
+/* Macronix MX25L25635F : 8 dummy cycles for Quad Output Fast,  6 for QuadIO */
+/* Micron   N25Q128     : 8 dummy cycles for Quad Output Fast, 10 for QuadIO */
+ #define CONFIG_SPI_FLASH_READ_QUAD_CMD	CMD_READ_QUAD_IO_FAST
+ #define CONFIG_SPI_FLASH_DUMMY_CYCLES	6
+ #define CONFIG_CQSPI_DECODER		0	/* i.e. don't use 4-to-16 CS decoder */
+#endif /* RZN1_ENABLE_QSPI */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+
+
+/***** Ethernet *****/
+#if defined(RZN1_ENABLE_ETHERNET)
+ #define CONFIG_MII
+ #define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+ #define CONFIG_PHY_MICREL
+ #define CONFIG_PHY_MARVELL
+ #define CONFIG_PHY_RESET_DELAY		1000	/* PHY RESET recovery delay in usec */
+ #define RZN1_APPLY_ETH_PHY_RESET_PULSE /* Reset cycle on signal phy reset */
+
+/*
+ * GMAC1 is connected to a Marvell PHY on the Extension board
+ * RGMII/GMII Conv   PHY Addr    PHY     Connector
+ *        1             8       Marvell  J22 (Ext Board)
+ */
+ #define CONFIG_PHY_ADDR		8
+
+/*
+ * GMAC2 is connected to the 5-port Switch and all ports are enabled.
+ * Two Micrel PHYs are on the CPU board, two additional Marvell PHYs are on the
+ * Extension board. The board setup code specifies the MII interface type used,
+ * see call to designware_initialize_fixed_link().
+ * We can only use one PHY in U-Boot.
+ * Switch Port   RGMII/GMII Conv   PHY Addr    PHY     Connector
+ *      3               2             1       Marvell  J23 (Ext Board)
+ *      2               3            10       Marvell  J24 (Ext Board)
+ *      1               4             4       Micrel   CN1
+ *      0               5             5       Micrel   CN4
+ */
+ #define CONFIG_HAS_ETH1
+ #define CONFIG_PHY1_ADDR		4
+#endif /* RZN1_ENABLE_ETHERNET */
+
+/***** SDHC *****/
+#if defined(RZN1_ENABLE_SDHC)
+ #define CONFIG_SDHCI_ARASAN_QUIRKS	SDHCI_QUIRK_WAIT_SEND_CMD
+ #define CONFIG_GENERIC_MMC
+ #define CONFIG_DOS_PARTITION
+ #define CONFIG_FS_FAT_MAX_CLUSTSIZE (8 * 1024)
+#endif /* RZN1_ENABLE_SDHC */
+
+#if defined(RZN1_ENABLE_USBH)
+ #define CONFIG_USB_EHCI
+ #define CONFIG_USB_EHCI_RMOBILE
+ #define CONFIG_USB_MAX_CONTROLLER_COUNT	1
+ #define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	1
+#endif /* RZN1_ENABLE_USBH */
+
+/***** USB Device aka Gadget aka Function *****/
+#if defined(RZN1_ENABLE_USBF)
+ /* Default is... 8 MB !! Note that it needs to be AT LEAST the size of
+  * a single erase block of the nand/qspi, otherwise the operation will fail */
+ #define CONFIG_SYS_DFU_DATA_BUF_SIZE	(64 * 1024)
+ #define DFU_DEFAULT_POLL_TIMEOUT	100
+
+ #define DFU_EXT_INFO \
+	"dfu_ext_info=" \
+	"sf sf_spl raw 0 10000;" \
+	"sf sf_rpkgt raw 10000 10000;" \
+	"sf sf_uboot raw 20000 80000;" \
+	"sf sf_env raw a0000 10000;" \
+	"sf sf_dtb raw b0000 20000;" \
+	"sf sf_cm3 raw d0000 100000;" \
+	"sf sf_kernel raw 1d0000 600000;" \
+	"sf sf_data raw 7d0000 0;" \
+	"sf sf_vxworks raw d0000 600000;" \
+	"ram r_kernel ram 80008000 d80000;" \
+	"ram r_vxworks ram 80008000 d80000\0"
+#else
+ #define DFU_EXT_INFO
+#endif /* RZN1_ENABLE_USBF */
+
+#define CONFIG_BOOTDELAY 1
+#define CONFIG_BOOTCOMMAND ""
+/* Default environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	DFU_EXT_INFO \
+	"bootdelay=1\0" \
+	"loadaddr=80008000\0" \
+	"ethaddr=00:00:0a:02:57:CD\0" \
+	"eth1addr=00:00:0a:02:57:CE\0" \
+	"netmask=255.255.255.0\0" \
+	"serverip=192.168.1.30\0" \
+	"ipaddr=192.168.1.50\0"
+
+
+/***** SPL (Secondary Program Loader) *****/
+#if defined(RZN1_ENABLE_SPL)
+
+/* U-Boot/SPL is at the top of UA SRAM, out of the way of CM3 code which has to
+ * be at the start of UA SRAM. These definitions setup SPL so that code, heap,
+ * and stack at located together. */
+#define CONFIG_SPL_MAX_FOOTPRINT	(80 * 1024)
+#define CONFIG_SYS_SPL_MALLOC_SIZE	(40 * 1024)
+#define RZN1_SPL_STACK_SIZE		(8 * 1024)
+
+#define RZN1_SPL_SRAM_SIZE		(CONFIG_SPL_MAX_FOOTPRINT + \
+						CONFIG_SYS_SPL_MALLOC_SIZE + \
+						RZN1_SPL_STACK_SIZE)
+#define CONFIG_SPL_TEXT_BASE		0x040e0000 // (0x04100000 - RZN1_SPL_SRAM_SIZE)
+
+#define CONFIG_SYS_SPL_MALLOC_START	(CONFIG_SPL_TEXT_BASE + CONFIG_SPL_MAX_FOOTPRINT)
+#define CONFIG_SPL_STACK		(CONFIG_SYS_SPL_MALLOC_START + CONFIG_SYS_SPL_MALLOC_SIZE + RZN1_SPL_STACK_SIZE)
+
+/* If QSPI is enabled, default to loading the image or Package Table from QSPI */
+#if defined(RZN1_ENABLE_QSPI)
+ #define CONFIG_SPL_SPI_LOAD
+#endif
+
+#include "rzn1-spl.h"
+	/* Offset corresponds to DFU sf_rpkgt */
+	#define CONFIG_SYS_SPI_U_BOOT_OFFS      0x10000
+
+/* Make SPL skip checking the signatures of loaded images */
+/* WARNING! This is for development & testing only */
+#define RZN1_SKIP_BOOTROM_CALLS
+
+/*
+ * This is the hash of the public key used to sign BLp wrapped images that is
+ * loaded by U-Boot/SPL. If you are not verifying the signature of packages, it
+ * will not be used.
+ * This particular hash is key 6 from keys used during testing of the BootROM.
+ */
+#define RZN1_SPL_RPKG_HASH \
+	0xf5, 0x05, 0x93, 0x54, \
+	0xda, 0x47, 0x4f, 0xe4, \
+	0x1f, 0x2c, 0x7d, 0xfe, \
+	0xbb, 0x41, 0x0d, 0xed, \
+	0xa3, 0x25, 0x3f, 0xef, \
+	0xa7, 0x29, 0x0c, 0x28, \
+	0x07, 0x1f, 0xbf, 0x76, \
+	0x26, 0xa3, 0x7e, 0x4c,
+
+#endif /* RZN1_ENABLE_SPL */
+
+#endif /* __RZN1D400_DB_H */
diff --git a/include/configs/rzn1s324-db.h b/include/configs/rzn1s324-db.h
new file mode 100644
index 0000000..6f8a9c8
--- /dev/null
+++ b/include/configs/rzn1s324-db.h
@@ -0,0 +1,239 @@
+/*
+ * Renesas RZN1S-324 Demo board
+ *
+ * (C) Copyright 2017 Renesas Electronics Europe Ltd
+ * Phil Edworthy <phil.edworthy@renesas.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __RZN1S324_DB_H
+#define __RZN1S324_DB_H
+
+#include "rzn1-common.h"
+#include "renesas/rzn1-memory-map.h"
+#include "renesas/rzn1-sysctrl.h"
+
+#define CONFIG_BOARD_NAME	"Renesas RZN1S-DB"
+
+/* The RZ/N1S can only support a 45MHz SDHCI clock */
+#undef SDHC_CLK_MHZ
+#define SDHC_CLK_MHZ			45
+
+/*
+ * U-Boot switches into NONSEC mode based on the "bootm_boot_mode" environment
+ * variable and the CONFIG_ARMV7_BOOT_SEC_DEFAULT symbol.
+ * However, RZ/N1 checks an additional "boot_hyp" environment variable to
+ * decide whether to switch to NONSEC+HYP mode.
+ */
+#define CONFIG_SMP_PEN_ADDR		smp_secondary_bootaddr
+#define CONFIG_OF_BOARD_SETUP
+
+#define CONFIG_SYS_THUMB_BUILD
+#define CONFIG_SYS_LONGHELP
+#define	CONFIG_CMDLINE_EDITING
+#define CONFIG_VERSION_VARIABLE		/* include version env variable */
+/* debug purpose */
+#define CONFIG_MD5
+#define CONFIG_CMD_MD5SUM
+
+/* Local helper symbols to enable/disable functionality */
+#define RZN1_ENABLE_I2C
+#define RZN1_ENABLE_GPIO
+#define RZN1_ENABLE_SDHC
+#define RZN1_ENABLE_ETHERNET
+#define RZN1_ENABLE_QSPI
+#undef RZN1_ENABLE_NAND
+#define RZN1_ENABLE_USBF
+#define RZN1_ENABLE_USBH
+#define RZN1_ENABLE_SPL
+
+/* SRAM */
+#define CONFIG_SYS_TEXT_BASE		0x200a0000
+#define CONFIG_SYS_STAY_IN_SRAM
+/* Very early stack, 320KB above start of U-Boot image */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_TEXT_BASE + (320 * 1024) - 4)
+#define CONFIG_SYS_MALLOC_LEN		(320 * 1024)
+
+#define	CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_SYS_MEMTEST_SCRATCH	RZN1_SRAM_SYS_BASE
+
+/* This is not used by uboot startup, just by nand etc */
+#define CONFIG_SYS_LOAD_ADDR		0x20000000
+
+/* Serial */
+#define CONFIG_BAUDRATE			115200
+
+
+/* ENV settings.
+ * To avoid U-Boot accessing NAND/QSPI, you might want to set NOWHERE instead.
+ */
+#if defined(RZN1_ENABLE_QSPI)
+ #define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+ #define CONFIG_ENV_IS_NOWHERE		/* Store ENV in memory only */
+#endif
+
+/* The ENV offsets match the DFU offsets for *_env */
+#if defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+ #define CONFIG_ENV_OFFSET		0xa0000
+ #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#endif
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+
+/***** SPI Flash *****/
+#if defined(RZN1_ENABLE_QSPI)
+ #define CONFIG_SF_DEFAULT_SPEED	62500000
+ #define CONFIG_ENV_SPI_MAX_HZ		62500000
+/* Reading using QuadIO can achieve 20% better throughput compared to QuadOutput
+ * on this board. However, the if you want to use the same U-Boot binary on
+ * boards with a second source SPI Flash, check that all use the same number of
+ * dummy cycles in this mode. If not, you may want to use the QuadOuput read
+ * command instead */
+/* Macronix MX25L25635F : 8 dummy cycles for Quad Output Fast,  6 for QuadIO */
+/* Micron   N25Q128     : 8 dummy cycles for Quad Output Fast, 10 for QuadIO */
+ #define CONFIG_SPI_FLASH_READ_QUAD_CMD	CMD_READ_QUAD_IO_FAST
+ #define CONFIG_SPI_FLASH_DUMMY_CYCLES	6
+ #define CONFIG_CQSPI_DECODER		0	/* i.e. don't use 4-to-16 CS decoder */
+#endif /* RZN1_ENABLE_QSPI */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+
+
+/***** Ethernet *****/
+#if defined(RZN1_ENABLE_ETHERNET)
+ #define CONFIG_MII
+ #define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+ #define CONFIG_PHY_MICREL
+ #define CONFIG_PHY_MARVELL
+ #define CONFIG_PHY_RESET_DELAY		1000	/* PHY RESET recovery delay in usec */
+ #define RZN1_APPLY_ETH_PHY_RESET_PULSE /* Reset cycle on signal phy reset */
+
+/*
+ * GMAC1 is connected to a Marvell PHY on the Extension board
+ * RGMII/GMII Conv   PHY Addr    PHY     Connector
+ *        1             8       Marvell  J22 (Ext Board)
+ */
+ #define CONFIG_PHY_ADDR		8
+
+/*
+ * GMAC2 is connected to the 5-port Switch and all ports are enabled.
+ * Two Micrel PHYs are on the CPU board, two additional Marvell PHYs are on the
+ * Extension board. The board setup code specifies the MII interface type used,
+ * see call to designware_initialize_fixed_link().
+ * We can only use one PHY in U-Boot.
+ * Switch Port   RGMII/GMII Conv   PHY Addr    PHY     Connector
+ *      3               2             1       Marvell  J23 (Ext Board)
+ *      2               3            10       Marvell  J24 (Ext Board)
+ *      1               4             4       Micrel   CN1
+ *      0               5             5       Micrel   CN4
+ */
+ #define CONFIG_HAS_ETH1
+ #define CONFIG_PHY1_ADDR		4
+#endif /* RZN1_ENABLE_ETHERNET */
+
+/***** SDHC *****/
+#if defined(RZN1_ENABLE_SDHC)
+ #define CONFIG_SDHCI_ARASAN_QUIRKS	SDHCI_QUIRK_WAIT_SEND_CMD
+ #define CONFIG_GENERIC_MMC
+ #define CONFIG_DOS_PARTITION
+ #define CONFIG_FS_FAT_MAX_CLUSTSIZE (8 * 1024)
+#endif /* RZN1_ENABLE_SDHC */
+
+#if defined(RZN1_ENABLE_USBH)
+ #define CONFIG_USB_EHCI
+ #define CONFIG_USB_EHCI_RMOBILE
+ #define CONFIG_USB_MAX_CONTROLLER_COUNT	1
+ #define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	1
+#endif /* RZN1_ENABLE_USBH */
+
+/***** USB Device aka Gadget aka Function *****/
+#if defined(RZN1_ENABLE_USBF)
+ /* Default is... 8 MB !! Note that it needs to be AT LEAST the size of
+  * a single erase block of the nand/qspi, otherwise the operation will fail */
+ #define CONFIG_SYS_DFU_DATA_BUF_SIZE	(64 * 1024)
+ #define DFU_DEFAULT_POLL_TIMEOUT	100
+
+ #define DFU_EXT_INFO \
+	"dfu_ext_info=" \
+	"sf sf_spl raw 0 10000;" \
+	"sf sf_rpkgt raw 10000 10000;" \
+	"sf sf_uboot raw 20000 80000;" \
+	"sf sf_env raw a0000 10000;" \
+	"sf sf_dtb raw b0000 20000;" \
+	"sf sf_cm3 raw d0000 100000;" \
+	"sf sf_kernel raw 1d0000 600000;" \
+	"sf sf_data raw 7d0000 0;" \
+	"sf sf_vxworks raw d0000 600000;" \
+	"sf 1:0 qspi1 raw 0 0;" \
+	"ram r_kernel ram 80008000 d80000;" \
+	"ram r_vxworks ram 80008000 d80000\0"
+#else
+ #define DFU_EXT_INFO
+#endif /* RZN1_ENABLE_USBF */
+
+#define CONFIG_BOOTDELAY 1
+#define CONFIG_BOOTCOMMAND ""
+/* Default environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	DFU_EXT_INFO \
+	"bootdelay=1\0" \
+	"loadaddr=20000000\0" \
+	"ethaddr=00:00:0a:02:57:CD\0" \
+	"eth1addr=00:00:0a:02:57:CE\0" \
+	"netmask=255.255.255.0\0" \
+	"serverip=192.168.1.30\0" \
+	"ipaddr=192.168.1.60\0"
+
+
+/***** SPL (Secondary Program Loader) *****/
+#if defined(RZN1_ENABLE_SPL)
+
+/* U-Boot/SPL is at the top of UA SRAM, out of the way of CM3 code which has to
+ * be at the start of UA SRAM. These definitions setup SPL so that code, heap,
+ * and stack at located together. */
+#define CONFIG_SPL_MAX_FOOTPRINT	(80 * 1024)
+#define CONFIG_SYS_SPL_MALLOC_SIZE	(40 * 1024)
+#define RZN1_SPL_STACK_SIZE		(8 * 1024)
+
+#define RZN1_SPL_SRAM_SIZE		(CONFIG_SPL_MAX_FOOTPRINT + \
+						CONFIG_SYS_SPL_MALLOC_SIZE + \
+						RZN1_SPL_STACK_SIZE)
+#define CONFIG_SPL_TEXT_BASE		0x040e0000 // (0x04100000 - RZN1_SPL_SRAM_SIZE)
+
+#define CONFIG_SYS_SPL_MALLOC_START	(CONFIG_SPL_TEXT_BASE + CONFIG_SPL_MAX_FOOTPRINT)
+#define CONFIG_SPL_STACK		(CONFIG_SYS_SPL_MALLOC_START + CONFIG_SYS_SPL_MALLOC_SIZE + RZN1_SPL_STACK_SIZE)
+
+/* If QSPI is enabled, default to loading the image or Package Table from QSPI */
+#if defined(RZN1_ENABLE_QSPI)
+ #define CONFIG_SPL_SPI_LOAD
+#endif
+
+#include "rzn1-spl.h"
+/* Offset corresponds to DFU sf_rpkgt */
+#define CONFIG_SYS_SPI_U_BOOT_OFFS      0x10000
+
+/* Make SPL skip checking the signatures of loaded images */
+/* WARNING! This is for development & testing only */
+#define RZN1_SKIP_BOOTROM_CALLS
+
+/*
+ * This is the hash of the public key used to sign BLp wrapped images that is
+ * loaded by U-Boot/SPL. If you are not verifying the signature of packages, it
+ * will not be used.
+ * This particular hash is key 6 from keys used during testing of the BootROM.
+ */
+#define RZN1_SPL_RPKG_HASH \
+	0xf5, 0x05, 0x93, 0x54, \
+	0xda, 0x47, 0x4f, 0xe4, \
+	0x1f, 0x2c, 0x7d, 0xfe, \
+	0xbb, 0x41, 0x0d, 0xed, \
+	0xa3, 0x25, 0x3f, 0xef, \
+	0xa7, 0x29, 0x0c, 0x28, \
+	0x07, 0x1f, 0xbf, 0x76, \
+	0x26, 0xa3, 0x7e, 0x4c,
+
+#endif /* RZN1_ENABLE_SPL */
+
+#endif /* __RZN1S324_DB_H */
diff --git a/include/linux/compat.h b/include/linux/compat.h
index 533983f..6b425e2 100644
--- a/include/linux/compat.h
+++ b/include/linux/compat.h
@@ -27,6 +27,8 @@ extern struct p_current *current;
 	printf(fmt, ##args)
 #define dev_warn(dev, fmt, args...)		\
 	printf(fmt, ##args)
+#define dev_crit(dev, fmt, args...)		\
+	printf(fmt, ##args)
 #define printk	printf
 #define printk_once	printf
 
@@ -267,6 +269,13 @@ struct device {
 	/* This is used from drivers/usb/musb-new subsystem only */
 	void		*driver_data;	/* data private to the driver */
 	void            *device_data;   /* data private to the device */
+
+	/* Linux driver compatibility only */
+	void		*platform_data;
+};
+/* Linux driver compatibility only */
+struct platform_device {
+	struct device dev;
 };
 struct mutex { int i; };
 struct kernel_param { int i; };
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index d55807b..f2329b9 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -645,6 +645,7 @@ struct nand_buffers {
  * @ecc_step_ds:	[INTERN] ECC step required by the @ecc_strength_ds,
  *                      also from the datasheet. It is the recommended ECC step
  *			size, if known; if unknown, set to zero.
+ * @ecc_on_chip:	[INTERN] ECC is handled internally by the Flash chip.
  * @onfi_timing_mode_default: [INTERN] default ONFI timing mode. This field is
  *			      either deduced from the datasheet if the NAND
  *			      chip is not ONFI compliant or set to 0 if it is
@@ -735,6 +736,7 @@ struct nand_chip {
 	uint8_t bits_per_cell;
 	uint16_t ecc_strength_ds;
 	uint16_t ecc_step_ds;
+	bool ecc_on_chip;
 	int onfi_timing_mode_default;
 	int badblockpos;
 	int badblockbits;
@@ -1060,39 +1062,39 @@ uint8_t nand_read_byte(struct mtd_info *mtd);
 struct nand_sdr_timings {
 	u32 tALH_min;
 	u32 tADL_min;
-	u32 tALS_min;
-	u32 tAR_min;
+	u16 tALS_min;
+	u16 tAR_min;
 	u32 tCEA_max;
-	u32 tCEH_min;
-	u32 tCH_min;
+	u16 tCEH_min;
+	u16 tCH_min;
 	u32 tCHZ_max;
-	u32 tCLH_min;
-	u32 tCLR_min;
-	u32 tCLS_min;
-	u32 tCOH_min;
+	u16 tCLH_min;
+	u16 tCLR_min;
+	u16 tCLS_min;
+	u16 tCOH_min;
 	u32 tCS_min;
-	u32 tDH_min;
-	u32 tDS_min;
+	u16 tDH_min;
+	u16 tDS_min;
 	u32 tFEAT_max;
-	u32 tIR_min;
+	u16 tIR_min;
 	u32 tITC_max;
 	u32 tRC_min;
-	u32 tREA_max;
-	u32 tREH_min;
-	u32 tRHOH_min;
+	u16 tREA_max;
+	u16 tREH_min;
+	u16 tRHOH_min;
 	u32 tRHW_min;
 	u32 tRHZ_max;
-	u32 tRLOH_min;
-	u32 tRP_min;
-	u32 tRR_min;
+	u16 tRLOH_min;
+	u16 tRP_min;
+	u16 tRR_min;
 	u64 tRST_max;
 	u32 tWB_max;
 	u32 tWC_min;
-	u32 tWH_min;
+	u16 tWH_min;
 	u32 tWHR_min;
-	u32 tWP_min;
+	u16 tWP_min;
 	u32 tWW_min;
-};
+} __attribute__((packed));
 
 /* get timing characteristics from ONFI timing mode. */
 const struct nand_sdr_timings *onfi_async_timing_mode_to_sdr_timings(int mode);
diff --git a/include/nand.h b/include/nand.h
index b6eb223..2af6c1a 100644
--- a/include/nand.h
+++ b/include/nand.h
@@ -129,7 +129,7 @@ void nand_deselect(void);
 void board_nand_select_device(struct nand_chip *nand, int chip);
 #endif
 
-__attribute__((noreturn)) void nand_boot(void);
+void nand_boot(void);
 
 #endif
 
diff --git a/include/netdev.h b/include/netdev.h
index 7a211bc..6edb217 100644
--- a/include/netdev.h
+++ b/include/netdev.h
@@ -35,6 +35,8 @@ int cs8900_initialize(u8 dev_num, int base_addr);
 int davinci_emac_initialize(void);
 int dc21x4x_initialize(bd_t *bis);
 int designware_initialize(ulong base_addr, u32 interface);
+int designware_initialize_fixed_link(ulong base_addr, u32 interface, int speed);
+int phy_adjust_link_notifier(struct phy_device *phydev);
 int dm9000_initialize(bd_t *bis);
 int dnet_eth_initialize(int id, void *regs, unsigned int phy_addr);
 int e1000_initialize(bd_t *bis);
diff --git a/include/renesas/jedec_ddr2_1g_x16_533c_250_CL4.h b/include/renesas/jedec_ddr2_1g_x16_533c_250_CL4.h
new file mode 100755
index 0000000..6b7db0d
--- /dev/null
+++ b/include/renesas/jedec_ddr2_1g_x16_533c_250_CL4.h
@@ -0,0 +1,400 @@
+
+/* ****************************************************************
+ *        CADENCE                    Copyright (c) 2001-2011      *
+ *                                   Cadence Design Systems, Inc. *
+ *                                   All rights reserved.         *
+ *                                                                *
+ ******************************************************************
+ *  The values calculated from this script are meant to be        *
+ *  representative programmings.   The values may not reflect the *
+ *  actual required programming for production use.   Please      *
+ *  closely review all programmed values for technical accuracy   *
+ *  before use in production parts.                               *
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior.
+ ******************************************************************
+ ******************************************************************/
+
+
+#define               DENALI_CTL_00_DATA 0x00000400
+#define               DENALI_CTL_01_DATA 0x00000000
+#define               DENALI_CTL_02_DATA 0x00000000
+#define               DENALI_CTL_03_DATA 0x00000000
+#define               DENALI_CTL_04_DATA 0x00000000
+#define               DENALI_CTL_05_DATA 0x00000000
+#define               DENALI_CTL_06_DATA 0x00000000
+#define               DENALI_CTL_07_DATA 0x0000c350
+#define               DENALI_CTL_08_DATA 0x00000032
+#define               DENALI_CTL_09_DATA 0x0000007d
+#define               DENALI_CTL_10_DATA 0x00006402
+#define               DENALI_CTL_11_DATA 0x080000c8
+#define               DENALI_CTL_12_DATA 0x02040003
+#define               DENALI_CTL_13_DATA 0x020c0f03
+#define               DENALI_CTL_14_DATA 0x02020d04
+#define               DENALI_CTL_15_DATA 0x00445c03
+#define               DENALI_CTL_16_DATA 0x04000303
+#define               DENALI_CTL_17_DATA 0x01010004
+#define               DENALI_CTL_18_DATA 0x00050308
+#define               DENALI_CTL_19_DATA 0x01000000
+#define               DENALI_CTL_20_DATA 0x07990020
+#define               DENALI_CTL_21_DATA 0x00000005
+#define               DENALI_CTL_22_DATA 0x000a0002
+#define               DENALI_CTL_23_DATA 0x00060002
+#define               DENALI_CTL_24_DATA 0x002300c8
+#define               DENALI_CTL_25_DATA 0x00010000
+#define               DENALI_CTL_26_DATA 0x00030300
+#define               DENALI_CTL_27_DATA 0x00000000
+#define               DENALI_CTL_28_DATA 0x00000000
+#define               DENALI_CTL_29_DATA 0x00000000
+#define               DENALI_CTL_30_DATA 0x00000000
+#define               DENALI_CTL_31_DATA 0x00064300
+#define               DENALI_CTL_32_DATA 0x00000004
+#define               DENALI_CTL_33_DATA 0x00000000
+#define               DENALI_CTL_34_DATA 0x00040643
+#define               DENALI_CTL_35_DATA 0x00000000
+#define               DENALI_CTL_36_DATA 0x00010000
+#define               DENALI_CTL_37_DATA 0x00000000
+#define               DENALI_CTL_38_DATA 0x00000000
+#define               DENALI_CTL_39_DATA 0x00000000
+#define               DENALI_CTL_40_DATA 0x00000000
+#define               DENALI_CTL_41_DATA 0x00000000
+#define               DENALI_CTL_42_DATA 0x00000000
+#define               DENALI_CTL_43_DATA 0x00000000
+#define               DENALI_CTL_44_DATA 0x00000000
+#define               DENALI_CTL_45_DATA 0x01000200
+#define               DENALI_CTL_46_DATA 0x02000040
+#define               DENALI_CTL_47_DATA 0x00000040
+#define               DENALI_CTL_48_DATA 0x03000100
+#define               DENALI_CTL_49_DATA 0xffff0a01
+#define               DENALI_CTL_50_DATA 0x01010101
+#define               DENALI_CTL_51_DATA 0x01010101
+#define               DENALI_CTL_52_DATA 0x01030101
+#define               DENALI_CTL_53_DATA 0x0c030000
+#define               DENALI_CTL_54_DATA 0x00000000
+#define               DENALI_CTL_55_DATA 0x00000100
+#define               DENALI_CTL_56_DATA 0x00000000
+#define               DENALI_CTL_57_DATA 0x00000000
+#define               DENALI_CTL_58_DATA 0x00000000
+#define               DENALI_CTL_59_DATA 0x00000000
+#define               DENALI_CTL_60_DATA 0x00000000
+#define               DENALI_CTL_61_DATA 0x00000000
+#define               DENALI_CTL_62_DATA 0x01010000
+#define               DENALI_CTL_63_DATA 0x05030202
+#define               DENALI_CTL_64_DATA 0x01000105
+#define               DENALI_CTL_65_DATA 0x00000000
+#define               DENALI_CTL_66_DATA 0x02020202
+#define               DENALI_CTL_67_DATA 0x00000200
+#define               DENALI_CTL_68_DATA 0x00000000
+#define               DENALI_CTL_69_DATA 0x00000000
+#define               DENALI_CTL_70_DATA 0x00000000
+#define               DENALI_CTL_71_DATA 0x00280d00
+#define               DENALI_CTL_72_DATA 0x00000000
+#define               DENALI_CTL_73_DATA 0x00000100
+#define               DENALI_CTL_74_DATA 0x00010001
+#define               DENALI_CTL_75_DATA 0x00000000
+#define               DENALI_CTL_76_DATA 0x00000000
+#define               DENALI_CTL_77_DATA 0x00000000
+#define               DENALI_CTL_78_DATA 0x00000000
+#define               DENALI_CTL_79_DATA 0x001b1b00
+#define               DENALI_CTL_80_DATA 0x00000001
+#define               DENALI_CTL_81_DATA 0x00000000
+#define               DENALI_CTL_82_DATA 0x00000000
+#define               DENALI_CTL_83_DATA 0x00011b1b
+#define               DENALI_CTL_84_DATA 0x00000000
+#define               DENALI_CTL_85_DATA 0x00000000
+#define               DENALI_CTL_86_DATA 0x001b1b00
+#define               DENALI_CTL_87_DATA 0x02020001
+#define               DENALI_CTL_88_DATA 0x00020200
+#define               DENALI_CTL_89_DATA 0x02000202
+#define               DENALI_CTL_90_DATA 0x01000002
+#define               DENALI_CTL_91_DATA 0x00000000
+#define               DENALI_CTL_92_DATA 0x0003ffff
+#define               DENALI_CTL_93_DATA 0x00000000
+#define               DENALI_CTL_94_DATA 0x0003ffff
+#define               DENALI_CTL_95_DATA 0x00000000
+#define               DENALI_CTL_96_DATA 0x0003ffff
+#define               DENALI_CTL_97_DATA 0x00000000
+#define               DENALI_CTL_98_DATA 0x0003ffff
+#define               DENALI_CTL_99_DATA 0x00000000
+#define              DENALI_CTL_100_DATA 0x0003ffff
+#define              DENALI_CTL_101_DATA 0x00000000
+#define              DENALI_CTL_102_DATA 0x0003ffff
+#define              DENALI_CTL_103_DATA 0x00000000
+#define              DENALI_CTL_104_DATA 0x0003ffff
+#define              DENALI_CTL_105_DATA 0x00000000
+#define              DENALI_CTL_106_DATA 0x0003ffff
+#define              DENALI_CTL_107_DATA 0x00000000
+#define              DENALI_CTL_108_DATA 0x0003ffff
+#define              DENALI_CTL_109_DATA 0x00000000
+#define              DENALI_CTL_110_DATA 0x0003ffff
+#define              DENALI_CTL_111_DATA 0x00000000
+#define              DENALI_CTL_112_DATA 0x0003ffff
+#define              DENALI_CTL_113_DATA 0x00000000
+#define              DENALI_CTL_114_DATA 0x0003ffff
+#define              DENALI_CTL_115_DATA 0x00000000
+#define              DENALI_CTL_116_DATA 0x0003ffff
+#define              DENALI_CTL_117_DATA 0x00000000
+#define              DENALI_CTL_118_DATA 0x0003ffff
+#define              DENALI_CTL_119_DATA 0x00000000
+#define              DENALI_CTL_120_DATA 0x0003ffff
+#define              DENALI_CTL_121_DATA 0x00000000
+#define              DENALI_CTL_122_DATA 0x0003ffff
+#define              DENALI_CTL_123_DATA 0x00000000
+#define              DENALI_CTL_124_DATA 0x0003ffff
+#define              DENALI_CTL_125_DATA 0x00000000
+#define              DENALI_CTL_126_DATA 0x0003ffff
+#define              DENALI_CTL_127_DATA 0x00000000
+#define              DENALI_CTL_128_DATA 0x0003ffff
+#define              DENALI_CTL_129_DATA 0x00000000
+#define              DENALI_CTL_130_DATA 0x0003ffff
+#define              DENALI_CTL_131_DATA 0x00000000
+#define              DENALI_CTL_132_DATA 0x0003ffff
+#define              DENALI_CTL_133_DATA 0x00000000
+#define              DENALI_CTL_134_DATA 0x0003ffff
+#define              DENALI_CTL_135_DATA 0x00000000
+#define              DENALI_CTL_136_DATA 0x0003ffff
+#define              DENALI_CTL_137_DATA 0x00000000
+#define              DENALI_CTL_138_DATA 0x0003ffff
+#define              DENALI_CTL_139_DATA 0x00000000
+#define              DENALI_CTL_140_DATA 0x0003ffff
+#define              DENALI_CTL_141_DATA 0x00000000
+#define              DENALI_CTL_142_DATA 0x0003ffff
+#define              DENALI_CTL_143_DATA 0x00000000
+#define              DENALI_CTL_144_DATA 0x0003ffff
+#define              DENALI_CTL_145_DATA 0x00000000
+#define              DENALI_CTL_146_DATA 0x0003ffff
+#define              DENALI_CTL_147_DATA 0x00000000
+#define              DENALI_CTL_148_DATA 0x0003ffff
+#define              DENALI_CTL_149_DATA 0x00000000
+#define              DENALI_CTL_150_DATA 0x0003ffff
+#define              DENALI_CTL_151_DATA 0x00000000
+#define              DENALI_CTL_152_DATA 0x0003ffff
+#define              DENALI_CTL_153_DATA 0x00000000
+#define              DENALI_CTL_154_DATA 0x0003ffff
+#define              DENALI_CTL_155_DATA 0x00000000
+#define              DENALI_CTL_156_DATA 0x0003ffff
+#define              DENALI_CTL_157_DATA 0x00000000
+#define              DENALI_CTL_158_DATA 0x0003ffff
+#define              DENALI_CTL_159_DATA 0x00000000
+#define              DENALI_CTL_160_DATA 0x0003ffff
+#define              DENALI_CTL_161_DATA 0x00000000
+#define              DENALI_CTL_162_DATA 0x0003ffff
+#define              DENALI_CTL_163_DATA 0x00000000
+#define              DENALI_CTL_164_DATA 0x0003ffff
+#define              DENALI_CTL_165_DATA 0x00000000
+#define              DENALI_CTL_166_DATA 0x0003ffff
+#define              DENALI_CTL_167_DATA 0x00000000
+#define              DENALI_CTL_168_DATA 0x0003ffff
+#define              DENALI_CTL_169_DATA 0x00000000
+#define              DENALI_CTL_170_DATA 0x0003ffff
+#define              DENALI_CTL_171_DATA 0x00000000
+#define              DENALI_CTL_172_DATA 0x0003ffff
+#define              DENALI_CTL_173_DATA 0x00000000
+#define              DENALI_CTL_174_DATA 0x0003ffff
+#define              DENALI_CTL_175_DATA 0x00000000
+#define              DENALI_CTL_176_DATA 0x0003ffff
+#define              DENALI_CTL_177_DATA 0x00000000
+#define              DENALI_CTL_178_DATA 0x0003ffff
+#define              DENALI_CTL_179_DATA 0x00000000
+#define              DENALI_CTL_180_DATA 0x0003ffff
+#define              DENALI_CTL_181_DATA 0x00000000
+#define              DENALI_CTL_182_DATA 0x0003ffff
+#define              DENALI_CTL_183_DATA 0x00000000
+#define              DENALI_CTL_184_DATA 0x0003ffff
+#define              DENALI_CTL_185_DATA 0x00000000
+#define              DENALI_CTL_186_DATA 0x0003ffff
+#define              DENALI_CTL_187_DATA 0x00000000
+#define              DENALI_CTL_188_DATA 0x0003ffff
+#define              DENALI_CTL_189_DATA 0x00000000
+#define              DENALI_CTL_190_DATA 0x0003ffff
+#define              DENALI_CTL_191_DATA 0x00000000
+#define              DENALI_CTL_192_DATA 0x0003ffff
+#define              DENALI_CTL_193_DATA 0x00000000
+#define              DENALI_CTL_194_DATA 0x0003ffff
+#define              DENALI_CTL_195_DATA 0x00000000
+#define              DENALI_CTL_196_DATA 0x0003ffff
+#define              DENALI_CTL_197_DATA 0x00000000
+#define              DENALI_CTL_198_DATA 0x0003ffff
+#define              DENALI_CTL_199_DATA 0x00000000
+#define              DENALI_CTL_200_DATA 0x0003ffff
+#define              DENALI_CTL_201_DATA 0x00000000
+#define              DENALI_CTL_202_DATA 0x0003ffff
+#define              DENALI_CTL_203_DATA 0x00000000
+#define              DENALI_CTL_204_DATA 0x0003ffff
+#define              DENALI_CTL_205_DATA 0x00000000
+#define              DENALI_CTL_206_DATA 0x0003ffff
+#define              DENALI_CTL_207_DATA 0x00000000
+#define              DENALI_CTL_208_DATA 0x0003ffff
+#define              DENALI_CTL_209_DATA 0x00000000
+#define              DENALI_CTL_210_DATA 0x0003ffff
+#define              DENALI_CTL_211_DATA 0x00000000
+#define              DENALI_CTL_212_DATA 0x0003ffff
+#define              DENALI_CTL_213_DATA 0x00000000
+#define              DENALI_CTL_214_DATA 0x0003ffff
+#define              DENALI_CTL_215_DATA 0x00000000
+#define              DENALI_CTL_216_DATA 0x0003ffff
+#define              DENALI_CTL_217_DATA 0x00000000
+#define              DENALI_CTL_218_DATA 0x0303ffff
+#define              DENALI_CTL_219_DATA 0xffffffff
+#define              DENALI_CTL_220_DATA 0x00030f0f
+#define              DENALI_CTL_221_DATA 0xffffffff
+#define              DENALI_CTL_222_DATA 0x00030f0f
+#define              DENALI_CTL_223_DATA 0xffffffff
+#define              DENALI_CTL_224_DATA 0x00030f0f
+#define              DENALI_CTL_225_DATA 0xffffffff
+#define              DENALI_CTL_226_DATA 0x00030f0f
+#define              DENALI_CTL_227_DATA 0xffffffff
+#define              DENALI_CTL_228_DATA 0x00030f0f
+#define              DENALI_CTL_229_DATA 0xffffffff
+#define              DENALI_CTL_230_DATA 0x00030f0f
+#define              DENALI_CTL_231_DATA 0xffffffff
+#define              DENALI_CTL_232_DATA 0x00030f0f
+#define              DENALI_CTL_233_DATA 0xffffffff
+#define              DENALI_CTL_234_DATA 0x00030f0f
+#define              DENALI_CTL_235_DATA 0xffffffff
+#define              DENALI_CTL_236_DATA 0x00030f0f
+#define              DENALI_CTL_237_DATA 0xffffffff
+#define              DENALI_CTL_238_DATA 0x00030f0f
+#define              DENALI_CTL_239_DATA 0xffffffff
+#define              DENALI_CTL_240_DATA 0x00030f0f
+#define              DENALI_CTL_241_DATA 0xffffffff
+#define              DENALI_CTL_242_DATA 0x00030f0f
+#define              DENALI_CTL_243_DATA 0xffffffff
+#define              DENALI_CTL_244_DATA 0x00030f0f
+#define              DENALI_CTL_245_DATA 0xffffffff
+#define              DENALI_CTL_246_DATA 0x00030f0f
+#define              DENALI_CTL_247_DATA 0xffffffff
+#define              DENALI_CTL_248_DATA 0x00030f0f
+#define              DENALI_CTL_249_DATA 0xffffffff
+#define              DENALI_CTL_250_DATA 0x00030f0f
+#define              DENALI_CTL_251_DATA 0xffffffff
+#define              DENALI_CTL_252_DATA 0x00030f0f
+#define              DENALI_CTL_253_DATA 0xffffffff
+#define              DENALI_CTL_254_DATA 0x00030f0f
+#define              DENALI_CTL_255_DATA 0xffffffff
+#define              DENALI_CTL_256_DATA 0x00030f0f
+#define              DENALI_CTL_257_DATA 0xffffffff
+#define              DENALI_CTL_258_DATA 0x00030f0f
+#define              DENALI_CTL_259_DATA 0xffffffff
+#define              DENALI_CTL_260_DATA 0x00030f0f
+#define              DENALI_CTL_261_DATA 0xffffffff
+#define              DENALI_CTL_262_DATA 0x00030f0f
+#define              DENALI_CTL_263_DATA 0xffffffff
+#define              DENALI_CTL_264_DATA 0x00030f0f
+#define              DENALI_CTL_265_DATA 0xffffffff
+#define              DENALI_CTL_266_DATA 0x00030f0f
+#define              DENALI_CTL_267_DATA 0xffffffff
+#define              DENALI_CTL_268_DATA 0x00030f0f
+#define              DENALI_CTL_269_DATA 0xffffffff
+#define              DENALI_CTL_270_DATA 0x00030f0f
+#define              DENALI_CTL_271_DATA 0xffffffff
+#define              DENALI_CTL_272_DATA 0x00030f0f
+#define              DENALI_CTL_273_DATA 0xffffffff
+#define              DENALI_CTL_274_DATA 0x00030f0f
+#define              DENALI_CTL_275_DATA 0xffffffff
+#define              DENALI_CTL_276_DATA 0x00030f0f
+#define              DENALI_CTL_277_DATA 0xffffffff
+#define              DENALI_CTL_278_DATA 0x00030f0f
+#define              DENALI_CTL_279_DATA 0xffffffff
+#define              DENALI_CTL_280_DATA 0x00030f0f
+#define              DENALI_CTL_281_DATA 0xffffffff
+#define              DENALI_CTL_282_DATA 0x00030f0f
+#define              DENALI_CTL_283_DATA 0xffffffff
+#define              DENALI_CTL_284_DATA 0x00030f0f
+#define              DENALI_CTL_285_DATA 0xffffffff
+#define              DENALI_CTL_286_DATA 0x00030f0f
+#define              DENALI_CTL_287_DATA 0xffffffff
+#define              DENALI_CTL_288_DATA 0x00030f0f
+#define              DENALI_CTL_289_DATA 0xffffffff
+#define              DENALI_CTL_290_DATA 0x00030f0f
+#define              DENALI_CTL_291_DATA 0xffffffff
+#define              DENALI_CTL_292_DATA 0x00030f0f
+#define              DENALI_CTL_293_DATA 0xffffffff
+#define              DENALI_CTL_294_DATA 0x00030f0f
+#define              DENALI_CTL_295_DATA 0xffffffff
+#define              DENALI_CTL_296_DATA 0x00030f0f
+#define              DENALI_CTL_297_DATA 0xffffffff
+#define              DENALI_CTL_298_DATA 0x00030f0f
+#define              DENALI_CTL_299_DATA 0xffffffff
+#define              DENALI_CTL_300_DATA 0x00030f0f
+#define              DENALI_CTL_301_DATA 0xffffffff
+#define              DENALI_CTL_302_DATA 0x00030f0f
+#define              DENALI_CTL_303_DATA 0xffffffff
+#define              DENALI_CTL_304_DATA 0x00030f0f
+#define              DENALI_CTL_305_DATA 0xffffffff
+#define              DENALI_CTL_306_DATA 0x00030f0f
+#define              DENALI_CTL_307_DATA 0xffffffff
+#define              DENALI_CTL_308_DATA 0x00030f0f
+#define              DENALI_CTL_309_DATA 0xffffffff
+#define              DENALI_CTL_310_DATA 0x00030f0f
+#define              DENALI_CTL_311_DATA 0xffffffff
+#define              DENALI_CTL_312_DATA 0x00030f0f
+#define              DENALI_CTL_313_DATA 0xffffffff
+#define              DENALI_CTL_314_DATA 0x00030f0f
+#define              DENALI_CTL_315_DATA 0xffffffff
+#define              DENALI_CTL_316_DATA 0x00030f0f
+#define              DENALI_CTL_317_DATA 0xffffffff
+#define              DENALI_CTL_318_DATA 0x00030f0f
+#define              DENALI_CTL_319_DATA 0xffffffff
+#define              DENALI_CTL_320_DATA 0x00030f0f
+#define              DENALI_CTL_321_DATA 0xffffffff
+#define              DENALI_CTL_322_DATA 0x00030f0f
+#define              DENALI_CTL_323_DATA 0xffffffff
+#define              DENALI_CTL_324_DATA 0x00030f0f
+#define              DENALI_CTL_325_DATA 0xffffffff
+#define              DENALI_CTL_326_DATA 0x00030f0f
+#define              DENALI_CTL_327_DATA 0xffffffff
+#define              DENALI_CTL_328_DATA 0x00030f0f
+#define              DENALI_CTL_329_DATA 0xffffffff
+#define              DENALI_CTL_330_DATA 0x00030f0f
+#define              DENALI_CTL_331_DATA 0xffffffff
+#define              DENALI_CTL_332_DATA 0x00030f0f
+#define              DENALI_CTL_333_DATA 0xffffffff
+#define              DENALI_CTL_334_DATA 0x00030f0f
+#define              DENALI_CTL_335_DATA 0xffffffff
+#define              DENALI_CTL_336_DATA 0x00030f0f
+#define              DENALI_CTL_337_DATA 0xffffffff
+#define              DENALI_CTL_338_DATA 0x00030f0f
+#define              DENALI_CTL_339_DATA 0xffffffff
+#define              DENALI_CTL_340_DATA 0x00030f0f
+#define              DENALI_CTL_341_DATA 0xffffffff
+#define              DENALI_CTL_342_DATA 0x00030f0f
+#define              DENALI_CTL_343_DATA 0xffffffff
+#define              DENALI_CTL_344_DATA 0x00030f0f
+#define              DENALI_CTL_345_DATA 0xffffffff
+#define              DENALI_CTL_346_DATA 0x32030f0f
+#define              DENALI_CTL_347_DATA 0x01320001
+#define              DENALI_CTL_348_DATA 0x00013200
+#define              DENALI_CTL_349_DATA 0x00000132
+#define              DENALI_CTL_350_DATA 0x00000000
+#define              DENALI_CTL_351_DATA 0x000c0000
+#define              DENALI_CTL_352_DATA 0x0f320000
+#define              DENALI_CTL_353_DATA 0x02000200
+#define              DENALI_CTL_354_DATA 0x02000200
+#define              DENALI_CTL_355_DATA 0x00000f32
+#define              DENALI_CTL_356_DATA 0x00004bfa
+#define              DENALI_CTL_357_DATA 0x00020304
+#define              DENALI_CTL_358_DATA 0x000a0a01
+#define              DENALI_CTL_359_DATA 0x00000000
+#define              DENALI_CTL_360_DATA 0x00000000
+#define              DENALI_CTL_361_DATA 0x04038000
+#define              DENALI_CTL_362_DATA 0x07030a07
+#define              DENALI_CTL_363_DATA 0x00ffff19
+#define              DENALI_CTL_364_DATA 0x000f0010
+#define              DENALI_CTL_365_DATA 0x00000000
+#define              DENALI_CTL_366_DATA 0x00000000
+#define              DENALI_CTL_367_DATA 0x00000000
+#define              DENALI_CTL_368_DATA 0x00000000
+#define              DENALI_CTL_369_DATA 0x00000000
+#define              DENALI_CTL_370_DATA 0x00000204
+#define              DENALI_CTL_371_DATA 0x00000000
+#define              DENALI_CTL_372_DATA 0x01000001
+#define              DENALI_CTL_373_DATA 0x00000001
+#define              DENALI_CTL_374_DATA 0x00000000
diff --git a/include/renesas/jedec_ddr3_2g_x16_1333h_500_cl8.h b/include/renesas/jedec_ddr3_2g_x16_1333h_500_cl8.h
new file mode 100644
index 0000000..1231aeb
--- /dev/null
+++ b/include/renesas/jedec_ddr3_2g_x16_1333h_500_cl8.h
@@ -0,0 +1,400 @@
+
+/* ****************************************************************
+ *        CADENCE                    Copyright (c) 2001-2011      *
+ *                                   Cadence Design Systems, Inc. *
+ *                                   All rights reserved.         *
+ *                                                                *
+ ******************************************************************
+ *  The values calculated from this script are meant to be        *
+ *  representative programmings.   The values may not reflect the *
+ *  actual required programming for production use.   Please      *
+ *  closely review all programmed values for technical accuracy   *
+ *  before use in production parts.                               *
+ ******************************************************************
+ *                                                                 
+ *   Module:         regconfig.h
+ *   Documentation:  Register programming header file
+ *
+ ******************************************************************
+ ******************************************************************
+ * WARNING:  This file was automatically generated.  Manual
+ * editing may result in undetermined behavior.
+ ******************************************************************
+ ******************************************************************/
+
+
+#define               DENALI_CTL_00_DATA 0x00000600
+#define               DENALI_CTL_01_DATA 0x00000000
+#define               DENALI_CTL_02_DATA 0x00000000
+#define               DENALI_CTL_03_DATA 0x00000000
+#define               DENALI_CTL_04_DATA 0x00000000
+#define               DENALI_CTL_05_DATA 0x00000000
+#define               DENALI_CTL_06_DATA 0x00000000
+#define               DENALI_CTL_07_DATA 0x00000005
+#define               DENALI_CTL_08_DATA 0x000186a0
+#define               DENALI_CTL_09_DATA 0x0003d090
+#define               DENALI_CTL_10_DATA 0x00000000
+#define               DENALI_CTL_11_DATA 0x10000200
+#define               DENALI_CTL_12_DATA 0x04040006
+#define               DENALI_CTL_13_DATA 0x04121904
+#define               DENALI_CTL_14_DATA 0x04041707
+#define               DENALI_CTL_15_DATA 0x00891c0c
+#define               DENALI_CTL_16_DATA 0x07000503
+#define               DENALI_CTL_17_DATA 0x01010008
+#define               DENALI_CTL_18_DATA 0x0007030f
+#define               DENALI_CTL_19_DATA 0x01000000
+#define               DENALI_CTL_20_DATA 0x0f340050
+#define               DENALI_CTL_21_DATA 0x00000005
+#define               DENALI_CTL_22_DATA 0x000c0003
+#define               DENALI_CTL_23_DATA 0x00000000
+#define               DENALI_CTL_24_DATA 0x00550200
+#define               DENALI_CTL_25_DATA 0x00010000
+#define               DENALI_CTL_26_DATA 0x00050500
+#define               DENALI_CTL_27_DATA 0x00000000
+#define               DENALI_CTL_28_DATA 0x00000000
+#define               DENALI_CTL_29_DATA 0x00000000
+#define               DENALI_CTL_30_DATA 0x00000000
+#define               DENALI_CTL_31_DATA 0x00084000
+#define               DENALI_CTL_32_DATA 0x00080046
+#define               DENALI_CTL_33_DATA 0x00000000
+#define               DENALI_CTL_34_DATA 0x00460840
+#define               DENALI_CTL_35_DATA 0x00000008
+#define               DENALI_CTL_36_DATA 0x00010000
+#define               DENALI_CTL_37_DATA 0x00000000
+#define               DENALI_CTL_38_DATA 0x00000000
+#define               DENALI_CTL_39_DATA 0x00000000
+#define               DENALI_CTL_40_DATA 0x00000000
+#define               DENALI_CTL_41_DATA 0x00000000
+#define               DENALI_CTL_42_DATA 0x00000000
+#define               DENALI_CTL_43_DATA 0x00000000
+#define               DENALI_CTL_44_DATA 0x00000000
+#define               DENALI_CTL_45_DATA 0x01000200
+#define               DENALI_CTL_46_DATA 0x02000040
+#define               DENALI_CTL_47_DATA 0x00000040
+#define               DENALI_CTL_48_DATA 0x02000100
+#define               DENALI_CTL_49_DATA 0xffff0a01
+#define               DENALI_CTL_50_DATA 0x01010101
+#define               DENALI_CTL_51_DATA 0x01010101
+#define               DENALI_CTL_52_DATA 0x01030101
+#define               DENALI_CTL_53_DATA 0x0c030000
+#define               DENALI_CTL_54_DATA 0x00000000
+#define               DENALI_CTL_55_DATA 0x00000100
+#define               DENALI_CTL_56_DATA 0x00000000
+#define               DENALI_CTL_57_DATA 0x00000000
+#define               DENALI_CTL_58_DATA 0x00000000
+#define               DENALI_CTL_59_DATA 0x00000000
+#define               DENALI_CTL_60_DATA 0x00000000
+#define               DENALI_CTL_61_DATA 0x00000000
+#define               DENALI_CTL_62_DATA 0x01020000
+#define               DENALI_CTL_63_DATA 0x06050201
+#define               DENALI_CTL_64_DATA 0x02000106
+#define               DENALI_CTL_65_DATA 0x00000000
+#define               DENALI_CTL_66_DATA 0x02020202
+#define               DENALI_CTL_67_DATA 0x00000200
+#define               DENALI_CTL_68_DATA 0x00000000
+#define               DENALI_CTL_69_DATA 0x00000000
+#define               DENALI_CTL_70_DATA 0x00000000
+#define               DENALI_CTL_71_DATA 0x00280d00
+#define               DENALI_CTL_72_DATA 0x00000000
+#define               DENALI_CTL_73_DATA 0x00000100
+#define               DENALI_CTL_74_DATA 0x00010001
+#define               DENALI_CTL_75_DATA 0x00000000
+#define               DENALI_CTL_76_DATA 0x00000000
+#define               DENALI_CTL_77_DATA 0x00000000
+#define               DENALI_CTL_78_DATA 0x00000000
+#define               DENALI_CTL_79_DATA 0x00222200
+#define               DENALI_CTL_80_DATA 0x00000001
+#define               DENALI_CTL_81_DATA 0x00000000
+#define               DENALI_CTL_82_DATA 0x00000000
+#define               DENALI_CTL_83_DATA 0x00012222
+#define               DENALI_CTL_84_DATA 0x00000000
+#define               DENALI_CTL_85_DATA 0x00000000
+#define               DENALI_CTL_86_DATA 0x00222200
+#define               DENALI_CTL_87_DATA 0x02020001
+#define               DENALI_CTL_88_DATA 0x00020200
+#define               DENALI_CTL_89_DATA 0x02000202
+#define               DENALI_CTL_90_DATA 0x01000002
+#define               DENALI_CTL_91_DATA 0x00000000
+#define               DENALI_CTL_92_DATA 0x0003ffff
+#define               DENALI_CTL_93_DATA 0x00000000
+#define               DENALI_CTL_94_DATA 0x0003ffff
+#define               DENALI_CTL_95_DATA 0x00000000
+#define               DENALI_CTL_96_DATA 0x0003ffff
+#define               DENALI_CTL_97_DATA 0x00000000
+#define               DENALI_CTL_98_DATA 0x0003ffff
+#define               DENALI_CTL_99_DATA 0x00000000
+#define              DENALI_CTL_100_DATA 0x0003ffff
+#define              DENALI_CTL_101_DATA 0x00000000
+#define              DENALI_CTL_102_DATA 0x0003ffff
+#define              DENALI_CTL_103_DATA 0x00000000
+#define              DENALI_CTL_104_DATA 0x0003ffff
+#define              DENALI_CTL_105_DATA 0x00000000
+#define              DENALI_CTL_106_DATA 0x0003ffff
+#define              DENALI_CTL_107_DATA 0x00000000
+#define              DENALI_CTL_108_DATA 0x0003ffff
+#define              DENALI_CTL_109_DATA 0x00000000
+#define              DENALI_CTL_110_DATA 0x0003ffff
+#define              DENALI_CTL_111_DATA 0x00000000
+#define              DENALI_CTL_112_DATA 0x0003ffff
+#define              DENALI_CTL_113_DATA 0x00000000
+#define              DENALI_CTL_114_DATA 0x0003ffff
+#define              DENALI_CTL_115_DATA 0x00000000
+#define              DENALI_CTL_116_DATA 0x0003ffff
+#define              DENALI_CTL_117_DATA 0x00000000
+#define              DENALI_CTL_118_DATA 0x0003ffff
+#define              DENALI_CTL_119_DATA 0x00000000
+#define              DENALI_CTL_120_DATA 0x0003ffff
+#define              DENALI_CTL_121_DATA 0x00000000
+#define              DENALI_CTL_122_DATA 0x0003ffff
+#define              DENALI_CTL_123_DATA 0x00000000
+#define              DENALI_CTL_124_DATA 0x0003ffff
+#define              DENALI_CTL_125_DATA 0x00000000
+#define              DENALI_CTL_126_DATA 0x0003ffff
+#define              DENALI_CTL_127_DATA 0x00000000
+#define              DENALI_CTL_128_DATA 0x0003ffff
+#define              DENALI_CTL_129_DATA 0x00000000
+#define              DENALI_CTL_130_DATA 0x0003ffff
+#define              DENALI_CTL_131_DATA 0x00000000
+#define              DENALI_CTL_132_DATA 0x0003ffff
+#define              DENALI_CTL_133_DATA 0x00000000
+#define              DENALI_CTL_134_DATA 0x0003ffff
+#define              DENALI_CTL_135_DATA 0x00000000
+#define              DENALI_CTL_136_DATA 0x0003ffff
+#define              DENALI_CTL_137_DATA 0x00000000
+#define              DENALI_CTL_138_DATA 0x0003ffff
+#define              DENALI_CTL_139_DATA 0x00000000
+#define              DENALI_CTL_140_DATA 0x0003ffff
+#define              DENALI_CTL_141_DATA 0x00000000
+#define              DENALI_CTL_142_DATA 0x0003ffff
+#define              DENALI_CTL_143_DATA 0x00000000
+#define              DENALI_CTL_144_DATA 0x0003ffff
+#define              DENALI_CTL_145_DATA 0x00000000
+#define              DENALI_CTL_146_DATA 0x0003ffff
+#define              DENALI_CTL_147_DATA 0x00000000
+#define              DENALI_CTL_148_DATA 0x0003ffff
+#define              DENALI_CTL_149_DATA 0x00000000
+#define              DENALI_CTL_150_DATA 0x0003ffff
+#define              DENALI_CTL_151_DATA 0x00000000
+#define              DENALI_CTL_152_DATA 0x0003ffff
+#define              DENALI_CTL_153_DATA 0x00000000
+#define              DENALI_CTL_154_DATA 0x0003ffff
+#define              DENALI_CTL_155_DATA 0x00000000
+#define              DENALI_CTL_156_DATA 0x0003ffff
+#define              DENALI_CTL_157_DATA 0x00000000
+#define              DENALI_CTL_158_DATA 0x0003ffff
+#define              DENALI_CTL_159_DATA 0x00000000
+#define              DENALI_CTL_160_DATA 0x0003ffff
+#define              DENALI_CTL_161_DATA 0x00000000
+#define              DENALI_CTL_162_DATA 0x0003ffff
+#define              DENALI_CTL_163_DATA 0x00000000
+#define              DENALI_CTL_164_DATA 0x0003ffff
+#define              DENALI_CTL_165_DATA 0x00000000
+#define              DENALI_CTL_166_DATA 0x0003ffff
+#define              DENALI_CTL_167_DATA 0x00000000
+#define              DENALI_CTL_168_DATA 0x0003ffff
+#define              DENALI_CTL_169_DATA 0x00000000
+#define              DENALI_CTL_170_DATA 0x0003ffff
+#define              DENALI_CTL_171_DATA 0x00000000
+#define              DENALI_CTL_172_DATA 0x0003ffff
+#define              DENALI_CTL_173_DATA 0x00000000
+#define              DENALI_CTL_174_DATA 0x0003ffff
+#define              DENALI_CTL_175_DATA 0x00000000
+#define              DENALI_CTL_176_DATA 0x0003ffff
+#define              DENALI_CTL_177_DATA 0x00000000
+#define              DENALI_CTL_178_DATA 0x0003ffff
+#define              DENALI_CTL_179_DATA 0x00000000
+#define              DENALI_CTL_180_DATA 0x0003ffff
+#define              DENALI_CTL_181_DATA 0x00000000
+#define              DENALI_CTL_182_DATA 0x0003ffff
+#define              DENALI_CTL_183_DATA 0x00000000
+#define              DENALI_CTL_184_DATA 0x0003ffff
+#define              DENALI_CTL_185_DATA 0x00000000
+#define              DENALI_CTL_186_DATA 0x0003ffff
+#define              DENALI_CTL_187_DATA 0x00000000
+#define              DENALI_CTL_188_DATA 0x0003ffff
+#define              DENALI_CTL_189_DATA 0x00000000
+#define              DENALI_CTL_190_DATA 0x0003ffff
+#define              DENALI_CTL_191_DATA 0x00000000
+#define              DENALI_CTL_192_DATA 0x0003ffff
+#define              DENALI_CTL_193_DATA 0x00000000
+#define              DENALI_CTL_194_DATA 0x0003ffff
+#define              DENALI_CTL_195_DATA 0x00000000
+#define              DENALI_CTL_196_DATA 0x0003ffff
+#define              DENALI_CTL_197_DATA 0x00000000
+#define              DENALI_CTL_198_DATA 0x0003ffff
+#define              DENALI_CTL_199_DATA 0x00000000
+#define              DENALI_CTL_200_DATA 0x0003ffff
+#define              DENALI_CTL_201_DATA 0x00000000
+#define              DENALI_CTL_202_DATA 0x0003ffff
+#define              DENALI_CTL_203_DATA 0x00000000
+#define              DENALI_CTL_204_DATA 0x0003ffff
+#define              DENALI_CTL_205_DATA 0x00000000
+#define              DENALI_CTL_206_DATA 0x0003ffff
+#define              DENALI_CTL_207_DATA 0x00000000
+#define              DENALI_CTL_208_DATA 0x0003ffff
+#define              DENALI_CTL_209_DATA 0x00000000
+#define              DENALI_CTL_210_DATA 0x0003ffff
+#define              DENALI_CTL_211_DATA 0x00000000
+#define              DENALI_CTL_212_DATA 0x0003ffff
+#define              DENALI_CTL_213_DATA 0x00000000
+#define              DENALI_CTL_214_DATA 0x0003ffff
+#define              DENALI_CTL_215_DATA 0x00000000
+#define              DENALI_CTL_216_DATA 0x0003ffff
+#define              DENALI_CTL_217_DATA 0x00000000
+#define              DENALI_CTL_218_DATA 0x0303ffff
+#define              DENALI_CTL_219_DATA 0xffffffff
+#define              DENALI_CTL_220_DATA 0x00030f0f
+#define              DENALI_CTL_221_DATA 0xffffffff
+#define              DENALI_CTL_222_DATA 0x00030f0f
+#define              DENALI_CTL_223_DATA 0xffffffff
+#define              DENALI_CTL_224_DATA 0x00030f0f
+#define              DENALI_CTL_225_DATA 0xffffffff
+#define              DENALI_CTL_226_DATA 0x00030f0f
+#define              DENALI_CTL_227_DATA 0xffffffff
+#define              DENALI_CTL_228_DATA 0x00030f0f
+#define              DENALI_CTL_229_DATA 0xffffffff
+#define              DENALI_CTL_230_DATA 0x00030f0f
+#define              DENALI_CTL_231_DATA 0xffffffff
+#define              DENALI_CTL_232_DATA 0x00030f0f
+#define              DENALI_CTL_233_DATA 0xffffffff
+#define              DENALI_CTL_234_DATA 0x00030f0f
+#define              DENALI_CTL_235_DATA 0xffffffff
+#define              DENALI_CTL_236_DATA 0x00030f0f
+#define              DENALI_CTL_237_DATA 0xffffffff
+#define              DENALI_CTL_238_DATA 0x00030f0f
+#define              DENALI_CTL_239_DATA 0xffffffff
+#define              DENALI_CTL_240_DATA 0x00030f0f
+#define              DENALI_CTL_241_DATA 0xffffffff
+#define              DENALI_CTL_242_DATA 0x00030f0f
+#define              DENALI_CTL_243_DATA 0xffffffff
+#define              DENALI_CTL_244_DATA 0x00030f0f
+#define              DENALI_CTL_245_DATA 0xffffffff
+#define              DENALI_CTL_246_DATA 0x00030f0f
+#define              DENALI_CTL_247_DATA 0xffffffff
+#define              DENALI_CTL_248_DATA 0x00030f0f
+#define              DENALI_CTL_249_DATA 0xffffffff
+#define              DENALI_CTL_250_DATA 0x00030f0f
+#define              DENALI_CTL_251_DATA 0xffffffff
+#define              DENALI_CTL_252_DATA 0x00030f0f
+#define              DENALI_CTL_253_DATA 0xffffffff
+#define              DENALI_CTL_254_DATA 0x00030f0f
+#define              DENALI_CTL_255_DATA 0xffffffff
+#define              DENALI_CTL_256_DATA 0x00030f0f
+#define              DENALI_CTL_257_DATA 0xffffffff
+#define              DENALI_CTL_258_DATA 0x00030f0f
+#define              DENALI_CTL_259_DATA 0xffffffff
+#define              DENALI_CTL_260_DATA 0x00030f0f
+#define              DENALI_CTL_261_DATA 0xffffffff
+#define              DENALI_CTL_262_DATA 0x00030f0f
+#define              DENALI_CTL_263_DATA 0xffffffff
+#define              DENALI_CTL_264_DATA 0x00030f0f
+#define              DENALI_CTL_265_DATA 0xffffffff
+#define              DENALI_CTL_266_DATA 0x00030f0f
+#define              DENALI_CTL_267_DATA 0xffffffff
+#define              DENALI_CTL_268_DATA 0x00030f0f
+#define              DENALI_CTL_269_DATA 0xffffffff
+#define              DENALI_CTL_270_DATA 0x00030f0f
+#define              DENALI_CTL_271_DATA 0xffffffff
+#define              DENALI_CTL_272_DATA 0x00030f0f
+#define              DENALI_CTL_273_DATA 0xffffffff
+#define              DENALI_CTL_274_DATA 0x00030f0f
+#define              DENALI_CTL_275_DATA 0xffffffff
+#define              DENALI_CTL_276_DATA 0x00030f0f
+#define              DENALI_CTL_277_DATA 0xffffffff
+#define              DENALI_CTL_278_DATA 0x00030f0f
+#define              DENALI_CTL_279_DATA 0xffffffff
+#define              DENALI_CTL_280_DATA 0x00030f0f
+#define              DENALI_CTL_281_DATA 0xffffffff
+#define              DENALI_CTL_282_DATA 0x00030f0f
+#define              DENALI_CTL_283_DATA 0xffffffff
+#define              DENALI_CTL_284_DATA 0x00030f0f
+#define              DENALI_CTL_285_DATA 0xffffffff
+#define              DENALI_CTL_286_DATA 0x00030f0f
+#define              DENALI_CTL_287_DATA 0xffffffff
+#define              DENALI_CTL_288_DATA 0x00030f0f
+#define              DENALI_CTL_289_DATA 0xffffffff
+#define              DENALI_CTL_290_DATA 0x00030f0f
+#define              DENALI_CTL_291_DATA 0xffffffff
+#define              DENALI_CTL_292_DATA 0x00030f0f
+#define              DENALI_CTL_293_DATA 0xffffffff
+#define              DENALI_CTL_294_DATA 0x00030f0f
+#define              DENALI_CTL_295_DATA 0xffffffff
+#define              DENALI_CTL_296_DATA 0x00030f0f
+#define              DENALI_CTL_297_DATA 0xffffffff
+#define              DENALI_CTL_298_DATA 0x00030f0f
+#define              DENALI_CTL_299_DATA 0xffffffff
+#define              DENALI_CTL_300_DATA 0x00030f0f
+#define              DENALI_CTL_301_DATA 0xffffffff
+#define              DENALI_CTL_302_DATA 0x00030f0f
+#define              DENALI_CTL_303_DATA 0xffffffff
+#define              DENALI_CTL_304_DATA 0x00030f0f
+#define              DENALI_CTL_305_DATA 0xffffffff
+#define              DENALI_CTL_306_DATA 0x00030f0f
+#define              DENALI_CTL_307_DATA 0xffffffff
+#define              DENALI_CTL_308_DATA 0x00030f0f
+#define              DENALI_CTL_309_DATA 0xffffffff
+#define              DENALI_CTL_310_DATA 0x00030f0f
+#define              DENALI_CTL_311_DATA 0xffffffff
+#define              DENALI_CTL_312_DATA 0x00030f0f
+#define              DENALI_CTL_313_DATA 0xffffffff
+#define              DENALI_CTL_314_DATA 0x00030f0f
+#define              DENALI_CTL_315_DATA 0xffffffff
+#define              DENALI_CTL_316_DATA 0x00030f0f
+#define              DENALI_CTL_317_DATA 0xffffffff
+#define              DENALI_CTL_318_DATA 0x00030f0f
+#define              DENALI_CTL_319_DATA 0xffffffff
+#define              DENALI_CTL_320_DATA 0x00030f0f
+#define              DENALI_CTL_321_DATA 0xffffffff
+#define              DENALI_CTL_322_DATA 0x00030f0f
+#define              DENALI_CTL_323_DATA 0xffffffff
+#define              DENALI_CTL_324_DATA 0x00030f0f
+#define              DENALI_CTL_325_DATA 0xffffffff
+#define              DENALI_CTL_326_DATA 0x00030f0f
+#define              DENALI_CTL_327_DATA 0xffffffff
+#define              DENALI_CTL_328_DATA 0x00030f0f
+#define              DENALI_CTL_329_DATA 0xffffffff
+#define              DENALI_CTL_330_DATA 0x00030f0f
+#define              DENALI_CTL_331_DATA 0xffffffff
+#define              DENALI_CTL_332_DATA 0x00030f0f
+#define              DENALI_CTL_333_DATA 0xffffffff
+#define              DENALI_CTL_334_DATA 0x00030f0f
+#define              DENALI_CTL_335_DATA 0xffffffff
+#define              DENALI_CTL_336_DATA 0x00030f0f
+#define              DENALI_CTL_337_DATA 0xffffffff
+#define              DENALI_CTL_338_DATA 0x00030f0f
+#define              DENALI_CTL_339_DATA 0xffffffff
+#define              DENALI_CTL_340_DATA 0x00030f0f
+#define              DENALI_CTL_341_DATA 0xffffffff
+#define              DENALI_CTL_342_DATA 0x00030f0f
+#define              DENALI_CTL_343_DATA 0xffffffff
+#define              DENALI_CTL_344_DATA 0x00030f0f
+#define              DENALI_CTL_345_DATA 0xffffffff
+#define              DENALI_CTL_346_DATA 0x32030f0f
+#define              DENALI_CTL_347_DATA 0x01320001
+#define              DENALI_CTL_348_DATA 0x00013200
+#define              DENALI_CTL_349_DATA 0x00000132
+#define              DENALI_CTL_350_DATA 0x00000000
+#define              DENALI_CTL_351_DATA 0x000d0000
+#define              DENALI_CTL_352_DATA 0x1e680000
+#define              DENALI_CTL_353_DATA 0x02000200
+#define              DENALI_CTL_354_DATA 0x02000200
+#define              DENALI_CTL_355_DATA 0x00001e68
+#define              DENALI_CTL_356_DATA 0x00009808
+#define              DENALI_CTL_357_DATA 0x00020608
+#define              DENALI_CTL_358_DATA 0x000a0a01
+#define              DENALI_CTL_359_DATA 0x00000000
+#define              DENALI_CTL_360_DATA 0x00000000
+#define              DENALI_CTL_361_DATA 0x04038000
+#define              DENALI_CTL_362_DATA 0x07030a07
+#define              DENALI_CTL_363_DATA 0x00ffff22
+#define              DENALI_CTL_364_DATA 0x000f0010
+#define              DENALI_CTL_365_DATA 0x00000000
+#define              DENALI_CTL_366_DATA 0x00000000
+#define              DENALI_CTL_367_DATA 0x00000000
+#define              DENALI_CTL_368_DATA 0x00000000
+#define              DENALI_CTL_369_DATA 0x00000000
+#define              DENALI_CTL_370_DATA 0x00000204
+#define              DENALI_CTL_371_DATA 0x00000000
+#define              DENALI_CTL_372_DATA 0x01000001
+#define              DENALI_CTL_373_DATA 0x00000001
+#define              DENALI_CTL_374_DATA 0x00000000
diff --git a/include/renesas/pinctrl-rzn1.h b/include/renesas/pinctrl-rzn1.h
new file mode 100644
index 0000000..93214eb
--- /dev/null
+++ b/include/renesas/pinctrl-rzn1.h
@@ -0,0 +1,197 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PINCTRL_RZN1_H__
+#define __PINCTRL_RZN1_H__
+
+#define RZN1_MUX_FUNC_BIT			8
+#define RZN1_MUX_HAS_FUNC_BIT			15
+#define RZN1_MUX_HAS_DRIVE_BIT			16
+#define RZN1_MUX_DRIVE_BIT			17
+#define RZN1_MUX_HAS_PULL_BIT			19
+#define RZN1_MUX_PULL_BIT			20
+
+#define RZN1_MUX_PULL_UP			1
+#define RZN1_MUX_PULL_DOWN			3
+#define RZN1_MUX_PULL_NONE			0
+
+#define RZN1_MUX_DRIVE_4MA			0
+#define RZN1_MUX_DRIVE_6MA			1
+#define RZN1_MUX_DRIVE_8MA			2
+#define RZN1_MUX_DRIVE_12MA			3
+
+#define RZN1_MUX(_gpio, _func) \
+	(((RZN1_FUNC_##_func) << RZN1_MUX_FUNC_BIT) | \
+		(1 << RZN1_MUX_HAS_FUNC_BIT) | \
+		(_gpio))
+
+#define RZN1_MUX_PULL(_pull) \
+		((1 << RZN1_MUX_HAS_PULL_BIT) | \
+		((_pull) << RZN1_MUX_PULL_BIT))
+
+#define RZN1_MUX_DRIVE(_drive) \
+		((1 << RZN1_MUX_HAS_DRIVE_BIT) | \
+		((_drive) << RZN1_MUX_DRIVE_BIT))
+
+#define RZN1_MUX_PUP(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_PULL(RZN1_MUX_PULL_UP))
+#define RZN1_MUX_PDOWN(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_PULL(RZN1_MUX_PULL_DOWN))
+#define RZN1_MUX_PNONE(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_PULL(RZN1_MUX_PULL_NONE))
+
+#define RZN1_MUX_4MA(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_4MA))
+#define RZN1_MUX_6MA(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_6MA))
+#define RZN1_MUX_8MA(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_8MA))
+#define RZN1_MUX_12MA(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_12MA))
+
+#define RZN1_MUX_PUP_4MA(_gpio, _func) \
+	(RZN1_MUX_PUP(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_4MA))
+#define RZN1_MUX_PUP_6MA(_gpio, _func) \
+	(RZN1_MUX_PUP(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_6MA))
+#define RZN1_MUX_PUP_8MA(_gpio, _func) \
+	(RZN1_MUX_PUP(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_8MA))
+#define RZN1_MUX_PUP_12MA(_gpio, _func) \
+	(RZN1_MUX_PUP(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_12MA))
+
+#define RZN1_MUX_PDOWN_4MA(_gpio, _func) \
+	(RZN1_MUX_PDOWN(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_4MA))
+#define RZN1_MUX_PDOWN_6MA(_gpio, _func) \
+	(RZN1_MUX_PDOWN(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_6MA))
+#define RZN1_MUX_PDOWN_8MA(_gpio, _func) \
+	(RZN1_MUX_PDOWN(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_8MA))
+#define RZN1_MUX_PDOWN_12MA(_gpio, _func) \
+	(RZN1_MUX_PDOWN(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_12MA))
+
+#define RZN1_MUX_PNONE_4MA(_gpio, _func) \
+	(RZN1_MUX_PNONE(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_4MA))
+#define RZN1_MUX_PNONE_6MA(_gpio, _func) \
+	(RZN1_MUX_PNONE(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_6MA))
+#define RZN1_MUX_PNONE_8MA(_gpio, _func) \
+	(RZN1_MUX_PNONE(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_8MA))
+#define RZN1_MUX_PNONE_12MA(_gpio, _func) \
+	(RZN1_MUX_PNONE(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_12MA))
+
+
+/* Use these "gpio" numbers with the RZN1_FUNC_MDIO_MUX* functions
+ * to set the destination of the two MDIO busses. */
+#define RZN1_MDIO_BUS0				170
+#define RZN1_MDIO_BUS1				171
+
+#define RZN1_FUNC_HIGHZ				0
+#define RZN1_FUNC_0L				1
+#define RZN1_FUNC_CLK_ETH_MII_RGMII_RMII	2
+#define RZN1_FUNC_CLK_ETH_NAND			3
+#define RZN1_FUNC_QSPI				4
+#define RZN1_FUNC_SDIO				5
+#define RZN1_FUNC_LCD				6
+#define RZN1_FUNC_LCD_E				7
+#define RZN1_FUNC_MSEBIM			8
+#define RZN1_FUNC_MSEBIS			9
+#define RZN1_FUNC_LEVEL2_OFFSET			10	/* I'm Special */
+#define RZN1_FUNC_HIGHZ1			10
+#define RZN1_FUNC_ETHERCAT			11
+#define RZN1_FUNC_SERCOS3			12
+#define RZN1_FUNC_SDIO_E			13
+#define RZN1_FUNC_ETH_MDIO			14
+#define RZN1_FUNC_ETH_MDIO_E1			15
+#define RZN1_FUNC_USB				16
+#define RZN1_FUNC_MSEBIM_E			17
+#define RZN1_FUNC_MSEBIS_E			18
+#define RZN1_FUNC_RSV				19
+#define RZN1_FUNC_RSV_E				20
+#define RZN1_FUNC_RSV_E1			21
+#define RZN1_FUNC_UART0_I			22
+#define RZN1_FUNC_UART0_I_E			23
+#define RZN1_FUNC_UART1_I			24
+#define RZN1_FUNC_UART1_I_E			25
+#define RZN1_FUNC_UART2_I			26
+#define RZN1_FUNC_UART2_I_E			27
+#define RZN1_FUNC_UART0				28
+#define RZN1_FUNC_UART0_E			29
+#define RZN1_FUNC_UART1				30
+#define RZN1_FUNC_UART1_E			31
+#define RZN1_FUNC_UART2				32
+#define RZN1_FUNC_UART2_E			33
+#define RZN1_FUNC_UART3				34
+#define RZN1_FUNC_UART3_E			35
+#define RZN1_FUNC_UART4				36
+#define RZN1_FUNC_UART4_E			37
+#define RZN1_FUNC_UART5				38
+#define RZN1_FUNC_UART5_E			39
+#define RZN1_FUNC_UART6				40
+#define RZN1_FUNC_UART6_E			41
+#define RZN1_FUNC_UART7				42
+#define RZN1_FUNC_UART7_E			43
+#define RZN1_FUNC_SPI0_M			44
+#define RZN1_FUNC_SPI0_M_E			45
+#define RZN1_FUNC_SPI1_M			46
+#define RZN1_FUNC_SPI1_M_E			47
+#define RZN1_FUNC_SPI2_M			48
+#define RZN1_FUNC_SPI2_M_E			49
+#define RZN1_FUNC_SPI3_M			50
+#define RZN1_FUNC_SPI3_M_E			51
+#define RZN1_FUNC_SPI4_S			52
+#define RZN1_FUNC_SPI4_S_E			53
+#define RZN1_FUNC_SPI5_S			54
+#define RZN1_FUNC_SPI5_S_E			55
+#define RZN1_FUNC_SGPIO0_M			56
+#define RZN1_FUNC_SGPIO1_M			57
+#define RZN1_FUNC_GPIO				58
+#define RZN1_FUNC_CAN				59
+#define RZN1_FUNC_I2C				60
+#define RZN1_FUNC_SAFE				61
+#define RZN1_FUNC_PTO_PWM			62
+#define RZN1_FUNC_PTO_PWM1			63
+#define RZN1_FUNC_PTO_PWM2			64
+#define RZN1_FUNC_PTO_PWM3			65
+#define RZN1_FUNC_PTO_PWM4			66
+#define RZN1_FUNC_DELTA_SIGMA			67
+#define RZN1_FUNC_SGPIO2_M			68
+#define RZN1_FUNC_SGPIO3_M			69
+#define RZN1_FUNC_SGPIO4_S			70
+#define RZN1_FUNC_MAC_MTIP_SWITCH		71
+#define RZN1_FUNC_MDIO_MUX_HIGHZ		72
+#define RZN1_FUNC_MDIO_MUX_MAC0			73
+#define RZN1_FUNC_MDIO_MUX_MAC1			74
+#define RZN1_FUNC_MDIO_MUX_ECAT			75
+#define RZN1_FUNC_MDIO_MUX_S3_MDIO0		76
+#define RZN1_FUNC_MDIO_MUX_S3_MDIO1		77
+#define RZN1_FUNC_MDIO_MUX_HWRTOS		78
+#define RZN1_FUNC_MDIO_MUX_SWITCH		79
+#define RZN1_FUNC_MAX				80
+
+#define RZN1_FUNC_NONE				0xff
+
+
+#endif /* __PINCTRL_RZN1_H__ */
diff --git a/include/renesas/rzn1-clkctrl-tables.h b/include/renesas/rzn1-clkctrl-tables.h
new file mode 100644
index 0000000..f0382f1
--- /dev/null
+++ b/include/renesas/rzn1-clkctrl-tables.h
@@ -0,0 +1,297 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_CLKCTRL_TABLES_H__
+#define __RZN1_CLKCTRL_TABLES_H__
+
+#define RZN1_CLK_COUNT		129
+
+static const struct rzn1_clkdesc rzn1_clock_list[RZN1_CLK_COUNT] = {
+	[RZN1_HCLK_SDIO0_ID] =
+		_CLK("hclk_sdio0",	_BIT(3, 0), _BIT(3, 1), _BIT(3, 2), _BIT(3, 3), _BIT(4, 0), _BIT(4, 1), _BIT(4, 2)),
+	[RZN1_CLK_SDIO0_ID] =
+		_CLK("clk_sdio0",	_BIT(3, 4), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_USBH_ID] =
+		_CLK("hclk_usbh",	_BIT(7, 0), _BIT(7, 1), {}, _BIT(7, 2), {}, _BIT(8, 0), _BIT(8, 1)),
+	[RZN1_HCLK_USBF_ID] =
+		_CLK("hclk_usbf",	_BIT(7, 3), {}, {}, _BIT(7, 4), {}, _BIT(8, 2), _BIT(8, 3)),
+	[RZN1_HCLK_USBPM_ID] =
+		_CLK("hclk_usbpm",	_BIT(7, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_PCI_USB_ID] =
+		_CLK("clk_pci_usb",	_BIT(7, 6), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_CRYPTO_EIP93_ID] =
+		_CLK("hclk_crypto_eip93",	_BIT(9, 0), _BIT(9, 1), {}, _BIT(9, 2), {}, _BIT(10, 0), _BIT(10, 1)),
+	[RZN1_HCLK_CRYPTO_EIP150_ID] =
+		_CLK("hclk_crypto_eip150",	_BIT(9, 3), _BIT(9, 4), _BIT(9, 5), {}, _BIT(10, 2), {}, {}),
+	[RZN1_HCLK_MSEBI_S_ID] =
+		_CLK("hclk_msebi_s",	_BIT(11, 0), _BIT(11, 1), _BIT(11, 2), _BIT(11, 3), _BIT(12, 0), _BIT(12, 1), _BIT(12, 2)),
+	[RZN1_HCLK_MSEBI_M_ID] =
+		_CLK("hclk_msebi_m",	_BIT(11, 4), _BIT(11, 5), _BIT(11, 6), {}, _BIT(12, 3), {}, {}),
+	[RZN1_HCLK_UART0_ID] =
+		_CLK("hclk_uart0",	_BIT(13, 0), _BIT(13, 1), _BIT(13, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_UART1_ID] =
+		_CLK("hclk_uart1",	_BIT(13, 3), _BIT(13, 4), _BIT(13, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_UART2_ID] =
+		_CLK("hclk_uart2",	_BIT(13, 6), _BIT(13, 7), _BIT(13, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_I2C0_ID] =
+		_CLK("hclk_i2c0",	_BIT(13, 9), _BIT(13, 10), _BIT(13, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_I2C1_ID] =
+		_CLK("hclk_i2c1",	_BIT(13, 12), _BIT(13, 13), _BIT(13, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_ADC_ID] =
+		_CLK("hclk_adc",	_BIT(13, 15), _BIT(13, 16), _BIT(13, 17), {}, {}, {}, {}),
+	[RZN1_CLK_UART0_ID] =
+		_CLK("clk_uart0",	_BIT(13, 18), _BIT(13, 19), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART0_ID] =
+		_CLK("clk_usbuart0",	_BIT(13, 20), _BIT(13, 21), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART1_ID] =
+		_CLK("clk_uart1",	_BIT(13, 22), _BIT(13, 23), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART1_ID] =
+		_CLK("clk_usbuart1",	_BIT(13, 24), _BIT(13, 25), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART2_ID] =
+		_CLK("clk_uart2",	_BIT(13, 26), _BIT(13, 27), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART2_ID] =
+		_CLK("clk_usbuart2",	_BIT(13, 28), _BIT(13, 29), {}, {}, {}, {}, {}),
+	[RZN1_CLK_I2C0_ID] =
+		_CLK("clk_i2c0",	_BIT(15, 6), _BIT(15, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_I2C1_ID] =
+		_CLK("clk_i2c1",	_BIT(15, 8), _BIT(15, 9), {}, {}, {}, {}, {}),
+	[RZN1_CLK_ADC_ID] =
+		_CLK("clk_adc",		_BIT(15, 10), _BIT(15, 11), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SGPIO0_ID] =
+		_CLK("hclk_sgpio0",	_BIT(15, 0), _BIT(15, 1), _BIT(15, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SGPIO1_ID] =
+		_CLK("hclk_sgpio1",	_BIT(15, 3), _BIT(15, 4), _BIT(15, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_PWMPTO_ID] =
+		_CLK("hclk_pwmpto",	_BIT(15, 12), _BIT(15, 13), _BIT(15, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_DELTASIGMA_ID] =
+		_CLK("hclk_deltasigma",	_BIT(15, 15), _BIT(15, 16), _BIT(15, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI0_ID] =
+		_CLK("hclk_spi0",	_BIT(16, 0), _BIT(16, 1), _BIT(16, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI1_ID] =
+		_CLK("hclk_spi1",	_BIT(16, 3), _BIT(16, 4), _BIT(16, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI2_ID] =
+		_CLK("hclk_spi2",	_BIT(16, 6), _BIT(16, 7), _BIT(16, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI3_ID] =
+		_CLK("hclk_spi3",	_BIT(16, 9), _BIT(16, 10), _BIT(16, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI4_ID] =
+		_CLK("hclk_spi4",	_BIT(16, 12), _BIT(16, 13), _BIT(16, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI5_ID] =
+		_CLK("hclk_spi5",	_BIT(16, 15), _BIT(16, 16), _BIT(16, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO0_ID] =
+		_CLK("hclk_gpio0",	_BIT(16, 18), _BIT(16, 19), _BIT(16, 20), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO1_ID] =
+		_CLK("hclk_gpio1",	_BIT(16, 21), _BIT(16, 22), _BIT(16, 23), {}, {}, {}, {}),
+	[RZN1_HCLK_UART3_ID] =
+		_CLK("hclk_uart3",	_BIT(16, 24), _BIT(16, 25), _BIT(16, 26), {}, {}, {}, {}),
+	[RZN1_HCLK_UART4_ID] =
+		_CLK("hclk_uart4",	_BIT(16, 27), _BIT(16, 28), _BIT(16, 29), {}, {}, {}, {}),
+	[RZN1_HCLK_UART5_ID] =
+		_CLK("hclk_uart5",	_BIT(17, 0), _BIT(17, 1), _BIT(17, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_UART6_ID] =
+		_CLK("hclk_uart6",	_BIT(17, 3), _BIT(17, 4), _BIT(17, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_UART7_ID] =
+		_CLK("hclk_uart7",	_BIT(17, 6), _BIT(17, 7), _BIT(17, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO2_ID] =
+		_CLK("hclk_gpio2",	_BIT(17, 9), _BIT(17, 10), _BIT(17, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_PG19_ID] =
+		_CLK("hclk_pg19",	_BIT(17, 12), _BIT(17, 13), _BIT(17, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_PG20_ID] =
+		_CLK("hclk_pg20",	_BIT(17, 15), _BIT(17, 16), _BIT(17, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_DMA0_ID] =
+		_CLK("hclk_dma0",	_BIT(19, 0), _BIT(19, 1), _BIT(19, 2), _BIT(19, 3), _BIT(22, 0), _BIT(22, 1), _BIT(22, 2)),
+	[RZN1_HCLK_DMA1_ID] =
+		_CLK("hclk_dma1",	_BIT(19, 4), _BIT(19, 5), _BIT(19, 6), _BIT(19, 7), _BIT(22, 3), _BIT(22, 4), _BIT(22, 5)),
+	[RZN1_HCLK_NAND_ID] =
+		_CLK("hclk_nand",	_BIT(20, 0), _BIT(20, 1), _BIT(20, 2), _BIT(20, 3), _BIT(23, 0), _BIT(23, 1), _BIT(23, 2)),
+	[RZN1_CLK_NAND_ID] =
+		_CLK("clk_nand",	_BIT(20, 4), _BIT(20, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_QSPI0_ID] =
+		_CLK("hclk_qspi0",	_BIT(21, 0), _BIT(21, 1), _BIT(21, 2), _BIT(21, 3), _BIT(24, 0), _BIT(24, 1), _BIT(24, 2)),
+	[RZN1_CLK_QSPI0_ID] =
+		_CLK("clk_qspi0",	_BIT(21, 4), _BIT(21, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_DDRC_ID] =
+		_CLK("hclk_ddrc",	_BIT(25, 0), _BIT(25, 2), {}, _BIT(25, 1), {}, _BIT(29, 0), _BIT(29, 1)),
+	[RZN1_CLK_DDRC_ID] =
+		_CLK("clk_ddrc",	_BIT(25, 3), _BIT(25, 4), {}, {}, {}, {}, {}),
+	[RZN1_CLK_RGMII_REF_ID] =
+		_CLK("clk_rgmii_ref",	_BIT(26, 0), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_RMII_REF_ID] =
+		_CLK("clk_rmii_ref",	_BIT(26, 1), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_MII_REF_ID] =
+		_CLK("clk_mii_ref",	_BIT(26, 2), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_GMAC0_ID] =
+		_CLK("hclk_gmac0",	_BIT(27, 0), _BIT(27, 1), _BIT(27, 2), _BIT(27, 3), _BIT(30, 0), _BIT(30, 1), _BIT(30, 2)),
+	[RZN1_HCLK_GMAC1_ID] =
+		_CLK("hclk_gmac1",	_BIT(28, 0), _BIT(28, 1), _BIT(28, 2), _BIT(28, 3), _BIT(31, 0), _BIT(31, 1), _BIT(31, 2)),
+	[RZN1_HCLK_ECAT125_ID] =
+		_CLK("hclk_ecat125",	_BIT(32, 0), _BIT(32, 1), {}, _BIT(32, 2), {}, _BIT(34, 0), _BIT(34, 1)),
+	[RZN1_CLK_ECAT25_ID] =
+		_CLK("clk_ecat25",	_BIT(32, 3), _BIT(32, 4), {}, {}, {}, {}, {}),
+	[RZN1_CLK_ECAT100_ID] =
+		_CLK("clk_ecat100",	_BIT(32, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SERCOS_ID] =
+		_CLK("hclk_sercos",	_BIT(33, 0), _BIT(33, 2), {}, _BIT(33, 1), {}, _BIT(35, 0), _BIT(35, 1)),
+	[RZN1_CLK_SERCOS50_ID] =
+		_CLK("clk_sercos50",	_BIT(33, 4), _BIT(33, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SERCOS100_ID] =
+		_CLK("clk_sercos100",	_BIT(33, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_QSPI1_ID] =
+		_CLK("hclk_qspi1",	_BIT(36, 0), _BIT(36, 1), _BIT(36, 2), _BIT(36, 3), _BIT(38, 0), _BIT(38, 1), _BIT(38, 2)),
+	[RZN1_CLK_QSPI1_ID] =
+		_CLK("clk_qspi1",	_BIT(36, 4), _BIT(36, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_HSR_ID] =
+		_CLK("hclk_hsr",	_BIT(36, 0), _BIT(36, 2), {}, _BIT(36, 1), {}, _BIT(38, 0), _BIT(38, 1)),
+	[RZN1_CLK_HSR_DUP_ID] =
+		_CLK("clk_hsr_dup",	_BIT(36, 3), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_HSR50_ID] =
+		_CLK("clk_hsr50",	_BIT(36, 4), _BIT(36, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SDIO1_ID] =
+		_CLK("hclk_sdio1",	_BIT(50, 0), _BIT(50, 1), _BIT(50, 2), _BIT(50, 3), _BIT(51, 0), _BIT(51, 1), _BIT(51, 2)),
+	[RZN1_CLK_SDIO1_ID] =
+		_CLK("clk_sdio1",	_BIT(50, 4), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_PINCONFIG_ID] =
+		_CLK("hclk_pinconfig",	_BIT(58, 0), _BIT(58, 1), _BIT(58, 2), {}, _BIT(87, 0), {}, {}),
+	[RZN1_HCLK_TIMER0_ID] =
+		_CLK("hclk_timer0",	_BIT(58, 3), _BIT(58, 4), _BIT(58, 5), {}, _BIT(87, 1), {}, {}),
+	[RZN1_HCLK_TIMER1_ID] =
+		_CLK("hclk_timer1",	_BIT(58, 6), _BIT(58, 7), _BIT(58, 8), {}, _BIT(87, 2), {}, {}),
+	[RZN1_CLK_25MHZ_PG4_ID] =
+		_CLK("clk_25mhz_pg4",	_BIT(58, 9), _BIT(58, 10), _BIT(58, 11), {}, _BIT(87, 3), {}, {}),
+	[RZN1_CLK_25MHZ_PG5_ID] =
+		_CLK("clk_25mhz_pg5",	_BIT(58, 12), _BIT(58, 13), _BIT(58, 14), {}, _BIT(87, 4), {}, {}),
+	[RZN1_CLK_25MHZ_PG6_ID] =
+		_CLK("clk_25mhz_pg6",	_BIT(58, 15), _BIT(58, 16), _BIT(58, 17), {}, _BIT(87, 5), {}, {}),
+	[RZN1_CLK_25MHZ_PG7_ID] =
+		_CLK("clk_25mhz_pg7",	_BIT(58, 18), _BIT(58, 19), _BIT(58, 20), {}, _BIT(87, 6), {}, {}),
+	[RZN1_CLK_25MHZ_PG8_ID] =
+		_CLK("clk_25mhz_pg8",	_BIT(58, 21), _BIT(58, 22), _BIT(58, 23), {}, _BIT(87, 7), {}, {}),
+	[RZN1_CLK_UART3_ID] =
+		_CLK("clk_uart3",	_BIT(59, 0), _BIT(59, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART3_ID] =
+		_CLK("clk_usbuart3",	_BIT(59, 2), _BIT(59, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART4_ID] =
+		_CLK("clk_uart4",	_BIT(59, 4), _BIT(59, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART4_ID] =
+		_CLK("clk_usbuart4",	_BIT(59, 6), _BIT(59, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART5_ID] =
+		_CLK("clk_uart5",	_BIT(59, 8), _BIT(59, 9), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART5_ID] =
+		_CLK("clk_usbuart5",	_BIT(59, 10), _BIT(59, 11), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART6_ID] =
+		_CLK("clk_uart6",	_BIT(59, 12), _BIT(59, 13), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART6_ID] =
+		_CLK("clk_usbuart6",	_BIT(59, 14), _BIT(59, 15), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART7_ID] =
+		_CLK("clk_uart7",	_BIT(59, 16), _BIT(59, 17), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART7_ID] =
+		_CLK("clk_usbuart7",	_BIT(59, 18), _BIT(59, 19), {}, {}, {}, {}, {}),
+	[RZN1_CLK_NOUSBP2_PG6_ID] =
+		_CLK("clk_nousbp2_pg6",	_BIT(59, 20), _BIT(59, 21), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBP2_PG6_ID] =
+		_CLK("clk_usbp2_pg6",	_BIT(59, 22), _BIT(59, 23), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_CAN1_ID] =
+		_CLK("hclk_can1",	_BIT(60, 6), _BIT(60, 7), _BIT(60, 8), {}, _BIT(88, 2), {}, {}),
+	[RZN1_CLK_48MHZ_PG4_ID] =
+		_CLK("clk_48mhz_pg4",	_BIT(60, 9), _BIT(60, 10), _BIT(60, 11), {}, _BIT(88, 3), {}, {}),
+	[RZN1_CLK_48MHZ_PG_F_ID] =
+		_CLK("clk_48mhz_pg_f",	_BIT(60, 12), _BIT(60, 13), {}, _BIT(60, 14), {}, _BIT(88, 4), _BIT(88, 5)),
+	[RZN1_HCLK_RSV_ID] =
+		_CLK("hclk_rsv",	_BIT(60, 0), _BIT(60, 1), _BIT(60, 2), {}, _BIT(88, 0), {}, {}),
+	[RZN1_HCLK_CAN0_ID] =
+		_CLK("hclk_can0",	_BIT(60, 3), _BIT(60, 4), _BIT(60, 5), {}, _BIT(88, 1), {}, {}),
+	[RZN1_HCLK_LCD_ID] =
+		_CLK("hclk_lcd",	_BIT(61, 0), _BIT(61, 1), _BIT(61, 2), {}, _BIT(89, 0), {}, {}),
+	[RZN1_HCLK_SEMAP_ID] =
+		_CLK("hclk_semap",	_BIT(61, 3), _BIT(61, 4), _BIT(61, 5), {}, _BIT(89, 1), {}, {}),
+	[RZN1_HCLK_PG3_ID] =
+		_CLK("hclk_pg3",	_BIT(61, 6), _BIT(61, 7), _BIT(61, 8), {}, _BIT(89, 2), {}, {}),
+	[RZN1_HCLK_PG4_ID] =
+		_CLK("hclk_pg4",	_BIT(61, 9), _BIT(61, 10), _BIT(61, 11), {}, _BIT(89, 3), {}, {}),
+	[RZN1_HCLK_PG_I_ID] =
+		_CLK("hclk_pg_i",	_BIT(61, 12), _BIT(61, 13), {}, _BIT(61, 14), {}, _BIT(89, 4), _BIT(89, 5)),
+	[RZN1_CLK_SPI0_ID] =
+		_CLK("clk_spi0",	_BIT(63, 0), _BIT(63, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI1_ID] =
+		_CLK("clk_spi1",	_BIT(63, 2), _BIT(63, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI2_ID] =
+		_CLK("clk_spi2",	_BIT(63, 4), _BIT(63, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI3_ID] =
+		_CLK("clk_spi3",	_BIT(63, 6), _BIT(63, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI4_ID] =
+		_CLK("clk_spi4",	_BIT(65, 0), _BIT(65, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI5_ID] =
+		_CLK("clk_spi5",	_BIT(65, 2), _BIT(65, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P4_PG3_ID] =
+		_CLK("clk_p4_pg3",	_BIT(65, 4), _BIT(65, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P4_PG4_ID] =
+		_CLK("clk_p4_pg4",	_BIT(65, 6), _BIT(65, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SLCD_ID] =
+		_CLK("clk_slcd",	_BIT(67, 0), _BIT(67, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG2_ID] =
+		_CLK("clk_p1_pg2",	_BIT(67, 2), _BIT(67, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG3_ID] =
+		_CLK("clk_p1_pg3",	_BIT(67, 4), _BIT(67, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG4_ID] =
+		_CLK("clk_p1_pg4",	_BIT(67, 6), _BIT(67, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P6_PG1_ID] =
+		_CLK("clk_p6_pg1",	_BIT(69, 0), _BIT(69, 1), _BIT(69, 2), {}, _BIT(91, 0), {}, {}),
+	[RZN1_CLK_P6_PG2_ID] =
+		_CLK("clk_p6_pg2",	_BIT(69, 3), _BIT(69, 4), _BIT(69, 5), {}, _BIT(91, 1), {}, {}),
+	[RZN1_CLK_P6_PG3_ID] =
+		_CLK("clk_p6_pg3",	_BIT(69, 6), _BIT(69, 7), _BIT(69, 8), {}, _BIT(91, 2), {}, {}),
+	[RZN1_CLK_P6_PG4_ID] =
+		_CLK("clk_p6_pg4",	_BIT(69, 9), _BIT(69, 10), _BIT(69, 11), {}, _BIT(91, 3), {}, {}),
+	[RZN1_HCLK_SGPIO2_ID] =
+		_CLK("hclk_sgpio2",	_BIT(70, 3), _BIT(70, 4), _BIT(70, 5), {}, _BIT(90, 1), {}, {}),
+	[RZN1_HCLK_SGPIO3_ID] =
+		_CLK("hclk_sgpio3",	_BIT(70, 6), _BIT(70, 7), _BIT(70, 8), {}, _BIT(90, 2), {}, {}),
+	[RZN1_HCLK_SGPIO4_ID] =
+		_CLK("hclk_sgpio4",	_BIT(70, 9), _BIT(70, 10), _BIT(70, 11), {}, _BIT(90, 3), {}, {}),
+	[RZN1_HCLK_SWITCH_ID] =
+		_CLK("hclk_switch",	_BIT(76, 0), {}, _BIT(76, 1), {}, {}, {}, {}),
+	[RZN1_CLK_SWITCH_ID] =
+		_CLK("clk_switch",	_BIT(76, 2), _BIT(76, 3), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_RTC_ID] =
+		_CLK("hclk_rtc",	_BIT(80, 0), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_ROM_ID] =
+		_CLK("hclk_rom",	_BIT(85, 0), _BIT(85, 1), _BIT(85, 2), {}, _BIT(92, 0), {}, {}),
+	[RZN1_CLK_CM3_ID] =
+		_CLK("clk_cm3",		_BIT(93, 0), _BIT(93, 1), {}, _BIT(93, 2), {}, _BIT(94, 0), _BIT(94, 1)),
+	[RZN1_HCLK_CM3_ID] =
+		_CLK("hclk_cm3",	_BIT(97, 0), _BIT(97, 1), _BIT(97, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SWITCH_RG_ID] =
+		_CLK("hclk_switch_rg",	_BIT(98, 0), _BIT(98, 1), _BIT(98, 2), {}, {}, {}, {}),
+	[RZN1_CLK_HW_RTOS_ID] =
+		_CLK("clk_hw_rtos",	_BIT(99, 0), _BIT(99, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_RTOS_MDC_ID] =
+		_CLK("clk_rtos_mdc",	_BIT(99, 2), {}, {}, {}, {}, {}, {}),
+};
+
+
+#endif /* __RZN1_CLKCTRL_TABLES_H__ */
diff --git a/include/renesas/rzn1-clocks.h b/include/renesas/rzn1-clocks.h
new file mode 100644
index 0000000..51507f3
--- /dev/null
+++ b/include/renesas/rzn1-clocks.h
@@ -0,0 +1,183 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_CLOCKS_H__
+#define __RZN1_CLOCKS_H__
+
+#define RZN1_CLKDIV_PGEXT2_PR6			0
+#define RZN1_CLKDIV_QSPI2			1
+#define RZN1_CLKDIV_SWITCH			2
+#define RZN1_CLKDIV_OPP				3
+#define RZN1_CLKDIV_CA7				4
+#define RZN1_CLKDIV_PG1_PR2			5
+#define RZN1_CLKDIV_PG1_PR3			6
+#define RZN1_CLKDIV_PG1_PR4			7
+#define RZN1_CLKDIV_PG4_PR1			8
+#define RZN1_CLKDIV_PG5_PR5			9
+#define RZN1_CLKDIV_QSPI1			10
+#define RZN1_CLKDIV_SDIO1			11
+#define RZN1_CLKDIV_SDIO2			12
+#define RZN1_CLKDIV_PG0_ADC			13
+#define RZN1_CLKDIV_PG0_I2C			14
+#define RZN1_CLKDIV_PG0_UART			15
+#define RZN1_CLKDIV_NFLASH			16
+#define RZN1_CLKDIV_PG0_MOTOR			17
+#define RZN1_CLKDIV_HWRTOS_MDC			18
+
+#define RZN1_HCLK_SDIO0_ID			0
+#define RZN1_CLK_SDIO0_ID			1
+#define RZN1_HCLK_USBH_ID			2
+#define RZN1_HCLK_USBF_ID			3
+#define RZN1_HCLK_USBPM_ID			4
+#define RZN1_CLK_PCI_USB_ID			5
+#define RZN1_HCLK_CRYPTO_EIP93_ID		6
+#define RZN1_HCLK_CRYPTO_EIP150_ID		7
+#define RZN1_HCLK_MSEBI_S_ID			8
+#define RZN1_HCLK_MSEBI_M_ID			9
+#define RZN1_HCLK_UART0_ID			10
+#define RZN1_HCLK_UART1_ID			11
+#define RZN1_HCLK_UART2_ID			12
+#define RZN1_HCLK_I2C0_ID			13
+#define RZN1_HCLK_I2C1_ID			14
+#define RZN1_HCLK_ADC_ID			15
+#define RZN1_CLK_UART0_ID			16
+#define RZN1_CLK_USBUART0_ID			17
+#define RZN1_CLK_UART1_ID			18
+#define RZN1_CLK_USBUART1_ID			19
+#define RZN1_CLK_UART2_ID			20
+#define RZN1_CLK_USBUART2_ID			21
+#define RZN1_CLK_I2C0_ID			22
+#define RZN1_CLK_I2C1_ID			23
+#define RZN1_CLK_ADC_ID				24
+#define RZN1_HCLK_SGPIO0_ID			25
+#define RZN1_HCLK_SGPIO1_ID			26
+#define RZN1_HCLK_PWMPTO_ID			27
+#define RZN1_HCLK_DELTASIGMA_ID			28
+#define RZN1_HCLK_SPI0_ID			29
+#define RZN1_HCLK_SPI1_ID			30
+#define RZN1_HCLK_SPI2_ID			31
+#define RZN1_HCLK_SPI3_ID			32
+#define RZN1_HCLK_SPI4_ID			33
+#define RZN1_HCLK_SPI5_ID			34
+#define RZN1_HCLK_GPIO0_ID			35
+#define RZN1_HCLK_GPIO1_ID			36
+#define RZN1_HCLK_UART3_ID			37
+#define RZN1_HCLK_UART4_ID			38
+#define RZN1_HCLK_UART5_ID			39
+#define RZN1_HCLK_UART6_ID			40
+#define RZN1_HCLK_UART7_ID			41
+#define RZN1_HCLK_GPIO2_ID			42
+#define RZN1_HCLK_PG19_ID			43
+#define RZN1_HCLK_PG20_ID			44
+#define RZN1_HCLK_DMA0_ID			45
+#define RZN1_HCLK_DMA1_ID			46
+#define RZN1_HCLK_NAND_ID			47
+#define RZN1_CLK_NAND_ID			48
+#define RZN1_HCLK_QSPI0_ID			49
+#define RZN1_CLK_QSPI0_ID			50
+#define RZN1_HCLK_DDRC_ID			51
+#define RZN1_CLK_DDRC_ID			52
+#define RZN1_CLK_RGMII_REF_ID			53
+#define RZN1_CLK_RMII_REF_ID			54
+#define RZN1_CLK_MII_REF_ID			55
+#define RZN1_HCLK_GMAC0_ID			56
+#define RZN1_HCLK_GMAC1_ID			57
+#define RZN1_HCLK_ECAT125_ID			58
+#define RZN1_CLK_ECAT25_ID			59
+#define RZN1_CLK_ECAT100_ID			60
+#define RZN1_HCLK_SERCOS_ID			61
+#define RZN1_CLK_SERCOS50_ID			62
+#define RZN1_CLK_SERCOS100_ID			63
+#define RZN1_HCLK_QSPI1_ID			64
+#define RZN1_CLK_QSPI1_ID			65
+#define RZN1_HCLK_HSR_ID			66
+#define RZN1_CLK_HSR_DUP_ID			67
+#define RZN1_CLK_HSR50_ID			68
+#define RZN1_HCLK_SDIO1_ID			69
+#define RZN1_CLK_SDIO1_ID			70
+#define RZN1_HCLK_PINCONFIG_ID			71
+#define RZN1_HCLK_TIMER0_ID			72
+#define RZN1_HCLK_TIMER1_ID			73
+#define RZN1_CLK_25MHZ_PG4_ID			74
+#define RZN1_CLK_25MHZ_PG5_ID			75
+#define RZN1_CLK_25MHZ_PG6_ID			76
+#define RZN1_CLK_25MHZ_PG7_ID			77
+#define RZN1_CLK_25MHZ_PG8_ID			78
+#define RZN1_CLK_UART3_ID			79
+#define RZN1_CLK_USBUART3_ID			80
+#define RZN1_CLK_UART4_ID			81
+#define RZN1_CLK_USBUART4_ID			82
+#define RZN1_CLK_UART5_ID			83
+#define RZN1_CLK_USBUART5_ID			84
+#define RZN1_CLK_UART6_ID			85
+#define RZN1_CLK_USBUART6_ID			86
+#define RZN1_CLK_UART7_ID			87
+#define RZN1_CLK_USBUART7_ID			88
+#define RZN1_CLK_NOUSBP2_PG6_ID			89
+#define RZN1_CLK_USBP2_PG6_ID			90
+#define RZN1_HCLK_CAN1_ID			91
+#define RZN1_CLK_48MHZ_PG4_ID			92
+#define RZN1_CLK_48MHZ_PG_F_ID			93
+#define RZN1_HCLK_RSV_ID			94
+#define RZN1_HCLK_CAN0_ID			95
+#define RZN1_HCLK_LCD_ID			96
+#define RZN1_HCLK_SEMAP_ID			97
+#define RZN1_HCLK_PG3_ID			98
+#define RZN1_HCLK_PG4_ID			99
+#define RZN1_HCLK_PG_I_ID			100
+#define RZN1_CLK_SPI0_ID			101
+#define RZN1_CLK_SPI1_ID			102
+#define RZN1_CLK_SPI2_ID			103
+#define RZN1_CLK_SPI3_ID			104
+#define RZN1_CLK_SPI4_ID			105
+#define RZN1_CLK_SPI5_ID			106
+#define RZN1_CLK_P4_PG3_ID			107
+#define RZN1_CLK_P4_PG4_ID			108
+#define RZN1_CLK_SLCD_ID			109
+#define RZN1_CLK_P1_PG2_ID			110
+#define RZN1_CLK_P1_PG3_ID			111
+#define RZN1_CLK_P1_PG4_ID			112
+#define RZN1_CLK_P6_PG1_ID			113
+#define RZN1_CLK_P6_PG2_ID			114
+#define RZN1_CLK_P6_PG3_ID			115
+#define RZN1_CLK_P6_PG4_ID			116
+#define RZN1_HCLK_SGPIO2_ID			117
+#define RZN1_HCLK_SGPIO3_ID			118
+#define RZN1_HCLK_SGPIO4_ID			119
+#define RZN1_HCLK_SWITCH_ID			120
+#define RZN1_CLK_SWITCH_ID			121
+#define RZN1_HCLK_RTC_ID			122
+#define RZN1_HCLK_ROM_ID			123
+#define RZN1_CLK_CM3_ID				124
+#define RZN1_HCLK_CM3_ID			125
+#define RZN1_HCLK_SWITCH_RG_ID			126
+#define RZN1_CLK_HW_RTOS_ID			127
+#define RZN1_CLK_RTOS_MDC_ID			128
+
+#endif /* __RZN1_CLOCKS_H__ */
diff --git a/include/renesas/rzn1-irq.h b/include/renesas/rzn1-irq.h
new file mode 100644
index 0000000..f0d379c
--- /dev/null
+++ b/include/renesas/rzn1-irq.h
@@ -0,0 +1,169 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_IRQ_H__
+#define __RZN1_IRQ_H__
+
+#define RZN1_IRQ_ADC			0
+#define RZN1_IRQ_I2C0			1
+#define RZN1_IRQ_I2C1			2
+#define RZN1_IRQ_SAFETY_FILTERING	3
+#define RZN1_IRQ_SGPIO0			4
+#define RZN1_IRQ_SGPIO1			5
+#define RZN1_IRQ_UART0			6
+#define RZN1_IRQ_UART1			7
+#define RZN1_IRQ_UART2			8
+#define RZN1_IRQ_DELTASIGMA		9
+#define RZN1_IRQ_PWMPTO			10
+#define RZN1_IRQ_ECC_4MB		11
+#define RZN1_IRQ_ECC_2MB		12
+#define RZN1_IRQ_CM3_LOCKUP		13
+#define RZN1_IRQ_CM3_TRING_0		14
+#define RZN1_IRQ_CM3_TRING_1		15
+#define RZN1_IRQ_HWRTOS_BRAMERR		16
+#define RZN1_IRQ_HWRTOS_BUFDMA		17
+#define RZN1_IRQ_HWRTOS_BUFDMAERR	18
+#define RZN1_IRQ_HWRTOS_ETHMII		19
+#define RZN1_IRQ_HWRTOS_ETHPAUSE	20
+#define RZN1_IRQ_HWRTOS_ETHRXDERR	21
+#define RZN1_IRQ_HWRTOS_ETHRXDMA	22
+#define RZN1_IRQ_HWRTOS_ETHRXERR	23
+#define RZN1_IRQ_HWRTOS_ETHRXFIFO	24
+#define RZN1_IRQ_HWRTOS_ETHTX		25
+#define RZN1_IRQ_HWRTOS_ETHTXDERR	26
+#define RZN1_IRQ_HWRTOS_ETHTXDMA	27
+#define RZN1_IRQ_HWRTOS_ETHTXFIFO	28
+#define RZN1_IRQ_HWRTOS_ETHTXFIFOERR	29
+#define RZN1_IRQ_HWRTOS			30
+#define RZN1_IRQ_HWRTOS_MACDMARXFRM	31
+#define RZN1_IRQ_HWRTOS_TM_LPI_AST	32
+#define RZN1_IRQ_HWRTOS_TM_LPI_DEAST	33
+#define RZN1_IRQ_SBD0			34
+#define RZN1_IRQ_LPI0			35
+#define RZN1_IRQ_PMT0			36
+#define RZN1_IRQ_SBD1			37
+#define RZN1_IRQ_LPI1			38
+#define RZN1_IRQ_PMT1			39
+#define RZN1_IRQ_SWITCHDLR		40
+#define RZN1_IRQ_SWITCH			42
+#define RZN1_IRQ_SWITCHPRP		43
+#define RZN1_IRQ_ETHSWHUB		44
+#define RZN1_IRQ_ETHSWPTRN		45
+#define RZN1_IRQ_CAT_RST		46
+#define RZN1_IRQ_CAT_SYNC_0		47
+#define RZN1_IRQ_CAT_SYNC_1		48
+#define RZN1_IRQ_CAT_WDT		49	/* shared */
+#define RZN1_IRQ_S3_DIVCLK		49	/* shared */
+#define RZN1_IRQ_CAT_EOF		50	/* shared */
+#define RZN1_IRQ_S3_CONCLK		50	/* shared */
+#define RZN1_IRQ_HSR_PTP		50	/* shared */
+#define RZN1_IRQ_CAT_SOF		51	/* shared */
+#define RZN1_IRQ_S3_0			51	/* shared */
+#define RZN1_IRQ_HSR_CPU		51	/* shared */
+#define RZN1_IRQ_CAT			52	/* shared */
+#define RZN1_IRQ_S3_1			52	/* shared */
+#define RZN1_IRQ_NOCFIREWALL		53
+#define RZN1_IRQ_CRYPTO0		54
+#define RZN1_IRQ_CRYPTO1		55
+#define RZN1_IRQ_DMA0			56
+#define RZN1_IRQ_DMA1			57
+#define RZN1_IRQ_NAND			58
+#define RZN1_IRQ_IPCM_0			59
+#define RZN1_IRQ_IPCM_1			60
+#define RZN1_IRQ_IPCM_2			61
+#define RZN1_IRQ_MSEBIM			62
+#define RZN1_IRQ_MSEBIS			63
+#define RZN1_IRQ_QSPI0			64
+#define RZN1_IRQ_QSPI1			65
+#define RZN1_IRQ_RTCATINTAL		66
+#define RZN1_IRQ_RTCATINTR		67
+#define RZN1_IRQ_RTCATINT1S		68
+#define RZN1_IRQ_SDIO0			69
+#define RZN1_IRQ_SDIO0_WKUP		70
+#define RZN1_IRQ_SDIO1			71
+#define RZN1_IRQ_SDIO1_WKUP		72
+#define RZN1_IRQ_WATCHDOG_RESETN_0	73
+#define RZN1_IRQ_WATCHDOG_RESETN_1	74
+#define RZN1_IRQ_WATCHDOG_CM3_RESETN	75
+#define RZN1_IRQ_DDRSUB			76
+#define RZN1_IRQ_USBF_EPC		77
+#define RZN1_IRQ_USBF			78
+#define RZN1_IRQ_USBH_BIND		79
+#define RZN1_IRQ_SPI0			80
+#define RZN1_IRQ_SPI1			81
+#define RZN1_IRQ_SPI2			82
+#define RZN1_IRQ_SPI3			83
+#define RZN1_IRQ_SPI4			84
+#define RZN1_IRQ_SPI5			85
+#define RZN1_IRQ_UART3			86
+#define RZN1_IRQ_UART4			87
+#define RZN1_IRQ_UART5			88
+#define RZN1_IRQ_UART6			89
+#define RZN1_IRQ_UART7			90
+#define RZN1_IRQ_SGPIO2			91
+#define RZN1_IRQ_SGPIO3			92
+#define RZN1_IRQ_SGPIO4			93
+#define RZN1_IRQ_RSV			94
+#define RZN1_IRQ_CAN0			95
+#define RZN1_IRQ_CAN1			96
+#define RZN1_IRQ_LCD			97
+#define RZN1_IRQ_WATCHDOGSAFE0		100
+#define RZN1_IRQ_WATCHDOGSAFE1		101
+#define RZN1_IRQ_RESET			102
+#define RZN1_IRQ_GPIO_0			103
+#define RZN1_IRQ_GPIO_1			104
+#define RZN1_IRQ_GPIO_2			105
+#define RZN1_IRQ_GPIO_3			106
+#define RZN1_IRQ_GPIO_4			107
+#define RZN1_IRQ_GPIO_5			108
+#define RZN1_IRQ_GPIO_6			109
+#define RZN1_IRQ_GPIO_7			110
+#define RZN1_IRQ_TIMER0_0		112
+#define RZN1_IRQ_TIMER0_1		113
+#define RZN1_IRQ_TIMER0_2		114
+#define RZN1_IRQ_TIMER0_3		115
+#define RZN1_IRQ_TIMER0_4		116
+#define RZN1_IRQ_TIMER0_5		117
+#define RZN1_IRQ_TIMER0_6		118
+#define RZN1_IRQ_TIMER0_7		119
+#define RZN1_IRQ_TIMER1_0		120
+#define RZN1_IRQ_TIMER1_1		121
+#define RZN1_IRQ_TIMER1_2		122
+#define RZN1_IRQ_TIMER1_3		123
+#define RZN1_IRQ_TIMER1_4		124
+#define RZN1_IRQ_TIMER1_5		125
+#define RZN1_IRQ_TIMER1_6		126
+#define RZN1_IRQ_TIMER1_7		127
+#define RZN1_IRQ_NAXIERRIRQ		155
+#define RZN1_IRQ_NCTIIRQ_0		156
+#define RZN1_IRQ_NCTIIRQ_1		157
+#define RZN1_IRQ_NPMUIRQ_0		158
+#define RZN1_IRQ_NPMUIRQ_1		159
+
+#endif /* __RZN1_IRQ_H__ */
diff --git a/include/renesas/rzn1-memory-map.h b/include/renesas/rzn1-memory-map.h
new file mode 100644
index 0000000..d20adea
--- /dev/null
+++ b/include/renesas/rzn1-memory-map.h
@@ -0,0 +1,199 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_MEMORY_MAP_H__
+#define __RZN1_MEMORY_MAP_H__
+
+#define RZN1_ROM_BASE			0x00000000
+#define RZN1_ROM_SIZE			0x10000		/* 64 KB */
+#define RZN1_SRAM_ID_BASE		0x04000000
+#define RZN1_SRAM_ID_SIZE		0x100000	/* 1 MB */
+#define RZN1_V_QSPI_BASE		0x10000000
+#define RZN1_V_QSPI_SIZE		0x10000000	/* 256 MB */
+#define RZN1_SRAM_SYS_BASE		0x20000000
+#define RZN1_SRAM_SYS_SIZE		0x100000	/* 1 MB */
+#define RZN1_QSPI_BASE			0x40005000
+#define RZN1_QSPI_SIZE			0x1000		/* 4 KB */
+#define RZN1_RTC_BASE			0x40006000
+#define RZN1_RTC_SIZE			0x1000		/* 4 KB */
+#define RZN1_OTP_BASE			0x40007000
+#define RZN1_OTP_SIZE			0x1000		/* 4 KB */
+#define RZN1_WATCHDOG0_BASE		0x40008000
+#define RZN1_WATCHDOG0_SIZE		0x1000		/* 4 KB */
+#define RZN1_WATCHDOG1_BASE		0x40009000
+#define RZN1_WATCHDOG1_SIZE		0x1000		/* 4 KB */
+#define RZN1_WATCHDOG_M3_BASE		0x4000A000
+#define RZN1_WATCHDOG_M3_SIZE		0x1000		/* 4 KB */
+#define RZN1_MAILBOX_BASE		0x4000B000
+#define RZN1_MAILBOX_SIZE		0x1000		/* 4 KB */
+#define RZN1_SYSTEM_CTRL_BASE		0x4000C000
+#define RZN1_SYSTEM_CTRL_SIZE		0x1000		/* 4 KB */
+#define RZN1_DDR_BASE			0x4000D000
+#define RZN1_DDR_SIZE			0x1000		/* 4 KB */
+#define RZN1_DDRPHY_BASE		0x4000E000
+#define RZN1_DDRPHY_SIZE		0x1000		/* 4 KB */
+#define RZN1_QSPI1_BASE			0x4000E000	/* RZ/N1S only */
+#define RZN1_QSPI1_SIZE			0x1000		/* 4 KB */
+#define RZN1_PACKET_ENGINE_BASE		0x40010000
+#define RZN1_PACKET_ENGINE_SIZE		0x1000		/* 4 KB */
+#define RZN1_USB_DEV_BASE		0x4001E000
+#define RZN1_USB_DEV_SIZE		0x2000		/* 8 KB */
+#define RZN1_USB_HOST_BASE		0x40020000
+#define RZN1_USB_HOST_SIZE		0x20000		/* 128 KB */
+#define RZN1_PUBLIC_KEY_PROC_BASE	0x40040000
+#define RZN1_PUBLIC_KEY_PROC_SIZE	0x10000		/* 64 KB */
+#define RZN1_UART0_BASE			0x40060000
+#define RZN1_UART0_SIZE			0x400		/* 1 KB */
+#define RZN1_UART1_BASE			0x40061000
+#define RZN1_UART1_SIZE			0x400		/* 1 KB */
+#define RZN1_UART2_BASE			0x40062000
+#define RZN1_UART2_SIZE			0x400		/* 1 KB */
+#define RZN1_I2C0_BASE			0x40063000
+#define RZN1_I2C0_SIZE			0x100		/* 256 bytes */
+#define RZN1_I2C1_BASE			0x40064000
+#define RZN1_I2C1_SIZE			0x100		/* 256 bytes */
+#define RZN1_ADC_BASE			0x40065000
+#define RZN1_ADC_SIZE			0x1000		/* 4 KB */
+#define RZN1_CONFIG_SOC_BASE		0x40066000
+#define RZN1_CONFIG_SOC_SIZE		0x2000		/* 8 KB */
+#define RZN1_PINCTRL_BASE		0x40067000
+#define RZN1_PINCTRL_SIZE		0x1000		/* 4 KB */
+#define RZN1_PWM_BASE			0x40068000
+#define RZN1_PWM_SIZE			0x4000		/* 16 KB */
+#define RZN1_DELTASIGMA_BASE		0x4006C000
+#define RZN1_DELTASIGMA_SIZE		0x400		/* 1 KB */
+#define RZN1_SGPIO0_BASE		0x4006D000
+#define RZN1_SGPIO0_SIZE		0x400		/* 1 KB */
+#define RZN1_SGPIO1_BASE		0x4006E000
+#define RZN1_SGPIO1_SIZE		0x400		/* 1 KB */
+#define RZN1_MSEBI_M1_BASE		0x40080000
+#define RZN1_MSEBI_M1_SIZE		0x40000		/* 256 KB */
+#define RZN1_MSEBI_M0_BASE		0x400C0000
+#define RZN1_MSEBI_M0_SIZE		0x2000		/* 8 KB */
+#define RZN1_MSEBI_S_BASE		0x400C2000
+#define RZN1_MSEBI_S_SIZE		0x1000		/* 4 KB */
+#define RZN1_RIN_CTRL_REG_BASE		0x400E0000
+#define RZN1_RIN_CTRL_REG_SIZE		0x20000		/* 128 KB */
+#define RZN1_SDIO0_BASE			0x40100000
+#define RZN1_SDIO0_SIZE			0x1000		/* 4 KB */
+#define RZN1_SDIO1_BASE			0x40101000
+#define RZN1_SDIO1_SIZE			0x1000		/* 4 KB */
+#define RZN1_NAND_BASE			0x40102000
+#define RZN1_NAND_SIZE			0x2000		/* 8 KB */
+#define RZN1_DMA0_BASE			0x40104000
+#define RZN1_DMA0_SIZE			0x1000		/* 4 KB */
+#define RZN1_DMA1_BASE			0x40105000
+#define RZN1_DMA1_SIZE			0x1000		/* 4 KB */
+#define RZN1_GMAC0_BASE			0x44000000
+#define RZN1_GMAC0_SIZE			0x2000		/* 8 KB */
+#define RZN1_GMAC1_BASE			0x44002000
+#define RZN1_GMAC1_SIZE			0x2000		/* 8 KB */
+#define RZN1_ETHERCAT_BASE		0x44010000
+#define RZN1_ETHERCAT_SIZE		0x10000		/* 64 KB */
+#define RZN1_SERCOS_BASE		0x44020000
+#define RZN1_SERCOS_SIZE		0x10000		/* 64 KB */
+#define RZN1_SWITCH_CTRL_REG_BASE	0x44030000
+#define RZN1_SWITCH_CTRL_REG_SIZE	0x10000		/* 64 KB */
+#define RZN1_CPU_BASE			0x44040000
+#define RZN1_CPU_SIZE			0x8000		/* 32 KB */
+#define RZN1_CORE_BASE			0x44048000
+#define RZN1_CORE_SIZE			0x4000		/* 16 KB */
+#define RZN1_PTP_BASE			0x4404C000
+#define RZN1_PTP_SIZE			0x4000		/* 16 KB */
+#define RZN1_SWITCH_BASE		0x44050000
+#define RZN1_SWITCH_SIZE		0x10000		/* 64 KB */
+#define RZN1_GIC_BASE			0x44100000
+#define RZN1_GIC_SIZE			0x8000		/* 32 KB */
+#define RZN1_CSDAP_BASE			0x45000000
+#define RZN1_CSDAP_SIZE			0x200000	/* 2 MB */
+#define RZN1_UART3_BASE			0x50000000
+#define RZN1_UART3_SIZE			0x400		/* 1 KB */
+#define RZN1_UART4_BASE			0x50001000
+#define RZN1_UART4_SIZE			0x400		/* 1 KB */
+#define RZN1_UART5_BASE			0x50002000
+#define RZN1_UART5_SIZE			0x400		/* 1 KB */
+#define RZN1_UART6_BASE			0x50003000
+#define RZN1_UART6_SIZE			0x400		/* 1 KB */
+#define RZN1_UART7_BASE			0x50004000
+#define RZN1_UART7_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI0_BASE			0x50005000
+#define RZN1_SPI0_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI1_BASE			0x50006000
+#define RZN1_SPI1_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI2_BASE			0x50007000
+#define RZN1_SPI2_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI3_BASE			0x50008000
+#define RZN1_SPI3_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI4_BASE			0x50009000
+#define RZN1_SPI4_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI5_BASE			0x5000A000
+#define RZN1_SPI5_SIZE			0x400		/* 1 KB */
+#define RZN1_GPIO0_BASE			0x5000B000
+#define RZN1_GPIO0_SIZE			0x80		/* 128 bytes */
+#define RZN1_GPIO1_BASE			0x5000C000
+#define RZN1_GPIO1_SIZE			0x80		/* 128 bytes */
+#define RZN1_GPIO2_BASE			0x5000D000
+#define RZN1_GPIO2_SIZE			0x80		/* 128 bytes */
+#define RZN1_SGPIO3_BASE		0x5000F000
+#define RZN1_SGPIO3_SIZE		0x400		/* 1 KB */
+#define RZN1_SGPIO4_BASE		0x50010000
+#define RZN1_SGPIO4_SIZE		0x400		/* 1 KB */
+#define RZN1_PINCTRL_L2_BASE		0x51000000
+#define RZN1_PINCTRL_L2_SIZE		0x800		/* 2 KB */
+#define RZN1_TIMER0_BASE		0x51001000
+#define RZN1_TIMER0_SIZE		0x400		/* 1 KB */
+#define RZN1_TIMER1_BASE		0x51002000
+#define RZN1_TIMER1_SIZE		0x400		/* 1 KB */
+#define RZN1_WATCHDOGSAFE0_BASE		0x51003000
+#define RZN1_WATCHDOGSAFE0_SIZE		0x400		/* 1 KB */
+#define RZN1_WATCHDOGSAFE1_BASE		0x51004000
+#define RZN1_WATCHDOGSAFE1_SIZE		0x400		/* 1 KB */
+#define RZN1_CLKMONITORING_BASE		0x51005000
+#define RZN1_CLKMONITORING_SIZE		0x400		/* 1 KB */
+#define RZN1_RESET_BASE			0x51006000
+#define RZN1_RESET_SIZE			0x400		/* 1 KB */
+#define RZN1_RSV_MEM_BASE		0x52000000
+#define RZN1_RSV_MEM_SIZE		0x100000	/* 1 MB */
+#define RZN1_RSV_REG_BASE		0x52100000
+#define RZN1_RSV_REG_SIZE		0x4000		/* 16 KB */
+#define RZN1_CAN0_BASE			0x52104000
+#define RZN1_CAN0_SIZE			0x800		/* 2 KB */
+#define RZN1_CAN1_BASE			0x52105000
+#define RZN1_CAN1_SIZE			0x800		/* 2 KB */
+#define RZN1_RSV_ID_BASE		0x52200000
+#define RZN1_RSV_ID_SIZE		0x20000		/* 128 KB */
+#define RZN1_SEMAPHORE_BASE		0x53000000
+#define RZN1_SEMAPHORE_SIZE		0x4000		/* 16 KB */
+#define RZN1_LCD_BASE			0x53004000
+#define RZN1_LCD_SIZE			0x1000		/* 4 KB */
+#define RZN1_V_DDR_BASE			0x80000000
+#define RZN1_V_QSPI1_BASE		0xA0000000	/* RZ/N1S only */
+#define RZN1_V_QSPI1_SIZE		0x10000000	/* 256 MB */
+
+#endif /* __RZN1_MEMORY_MAP_H__ */
diff --git a/include/renesas/rzn1-sysctrl.h b/include/renesas/rzn1-sysctrl.h
new file mode 100644
index 0000000..5042b51
--- /dev/null
+++ b/include/renesas/rzn1-sysctrl.h
@@ -0,0 +1,768 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_SYSCTRL_H__
+#define __RZN1_SYSCTRL_H__
+
+
+/*
+ * Auto-generated from SYSCTRL_ipxact.xml
+ */
+#define RZN1_SYSCTRL_REG_CFG_USB		0x0
+#define RZN1_SYSCTRL_REG_CFG_USB_DIRPD			0
+#define RZN1_SYSCTRL_REG_CFG_USB_H2MODE			1
+#define RZN1_SYSCTRL_REG_CFG_USB_FRCLK48MOD		2
+#define RZN1_SYSCTRL_REG_OPMODE			0x4
+#define RZN1_SYSCTRL_REG_OPMODE_DDRMOD			0
+#define RZN1_SYSCTRL_REG_OPMODE_OPPMOD			1
+#define RZN1_SYSCTRL_REG_OPMODE_CA7BOOTSRC		2
+#define RZN1_SYSCTRL_REG_OPMODE_CA7BOOTSRC_MASK		0xc
+#define RZN1_SYSCTRL_REG_OPMODE_CM3BOOTSEL		4
+#define RZN1_SYSCTRL_REG_OPMODE_LCD2PU			5
+#define RZN1_SYSCTRL_REG_OPMODE_LCD1PU			6
+#define RZN1_SYSCTRL_REG_CFG_SDIO0		0x8
+#define RZN1_SYSCTRL_REG_CFG_SDIO0_BASECLKFREQ		0
+#define RZN1_SYSCTRL_REG_CFG_SDIO0_BASECLKFREQ_MASK	0xff
+#define RZN1_SYSCTRL_REG_CFG_SDIO0_SLOTTYPE		8
+#define RZN1_SYSCTRL_REG_CFG_SDIO0_SLOTTYPE_MASK	0x300
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0		0xc
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO0		0x10
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO0_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO0_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO0_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_DBGCON			0x14
+#define RZN1_SYSCTRL_REG_DBGCON_PR_DBG_EN		0
+#define RZN1_SYSCTRL_REG_DBGCON_CM3WD_DBG_EN		1
+#define RZN1_SYSCTRL_REG_DBGCON_CA7WD0_DBG_EN		2
+#define RZN1_SYSCTRL_REG_DBGCON_CA7WD1_DBG_EN		3
+#define RZN1_SYSCTRL_REG_SYSSTAT		0x18
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFE		0
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFE_MASK	0x3
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFI		2
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFI_MASK	0xc
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFIL2	4
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_COREVDDON		5
+#define RZN1_SYSCTRL_REG_SYSSTAT_PKGMODE		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB		0x1c
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_MIREQ_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_MIREQ_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_CLKEN_C		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_CLKEN_E		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_RSTN_F		7
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB		0x20
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB_MIRACK_B		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB_MISTAT_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO		0x24
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_MIREQ_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_SLVRDY_B	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_RSTN_A_ZERO	6
+#define RZN1_SYSCTRL_REG_PWRSTAT_CRYPTO		0x28
+#define RZN1_SYSCTRL_REG_PWRSTAT_CRYPTO_MIRACK_A	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_CRYPTO_MISTAT_A	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_CRYPTO_SCON_B		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI		0x2c
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_SLVRDY_B		6
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI		0x30
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI_SCON_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0		0x34
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_C		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_C		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_C		8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_D		9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_D		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_D		11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_E		12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_E		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_E		14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_F		15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_F		16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_F		17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_H1		18
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_H1		19
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_H2		20
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_H2		21
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_I1		22
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_I1		23
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_I2		24
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_I2		25
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_J1		26
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_J1		27
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_J2		28
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_J2		29
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_UARTCLKSEL	30
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0		0x38
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_B		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_C		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_D		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_E		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_F		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_N		6
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_O		7
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_P		8
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_R		9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1		0x3c
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_N		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_N		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_SLVRDY_N		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_O		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_O		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_SLVRDY_O		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_K		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_K		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_L		8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_L		9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_M		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_M		11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_P		12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_P		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_SLVRDY_P		14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_R		15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_R		16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_SLVRDY_R		17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1	0x40
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_A	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_A	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_B	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_B	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_C	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_C		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_C	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_D	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_D		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_D	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_E	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_E		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_E	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_F	15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_F		16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_F	17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_G	18
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_G		19
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_G	20
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_H	21
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_H		22
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_H	23
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_I	24
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_I		25
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_I	26
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_J	27
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_J		28
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_J	29
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2	0x44
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_K	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_K		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_K	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_L	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_L		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_L	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_M	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_M		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_M	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_N	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_N		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_N	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_O	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_O		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_O	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_P	15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_P		16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_P	17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV	0x48
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV_DIV	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA		0x4c
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_SLVRDY_B		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_MIREQ_B		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH		0x50
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_SLVRDY_A	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0		0x54
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA		0x58
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_SCON_B		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_MIRACK_B		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_MISTAT_B		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_NFLASH		0x5c
+#define RZN1_SYSCTRL_REG_PWRSTAT_NFLASH_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_NFLASH_MIRACK_A	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_NFLASH_MISTAT_A	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI0		0x60
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI0_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI0_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI0_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV	0x64
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC		0x64
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_MIREQ_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_RSTN_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_EETH		0x68
+#define RZN1_SYSCTRL_REG_PWRCTRL_EETH_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_EETH_CLKEN_B		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_EETH_CLKEN_C		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0		0x6c
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1		0x70
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_DDRC		0x74
+#define RZN1_SYSCTRL_REG_PWRSTAT_DDRC_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_DDRC_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC0		0x78
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC0_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC0_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC0_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC1		0x7c
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC1_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC1_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC1_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT		0x80
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_MIREQ_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_CLKEN_C		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS		0x84
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_MIREQ_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_RSTN_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_RSTN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_CLKEN_C		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_ECAT		0x88
+#define RZN1_SYSCTRL_REG_PWRSTAT_ECAT_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_ECAT_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_SERCOS		0x8c
+#define RZN1_SYSCTRL_REG_PWRSTAT_SERCOS_MIRACK_A	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_SERCOS_MISTAT_A	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1		0x90
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR		0x90
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_MIREQ_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_RSTN_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_CLKEN_C		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_RSTN_C		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV	0x94
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI1		0x98
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI1_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI1_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI1_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_HSR		0x98
+#define RZN1_SYSCTRL_REG_PWRSTAT_HSR_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_HSR_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_SWITCH		0x9c
+#define RZN1_SYSCTRL_REG_PWRSTAT_SWITCH_SCON_A		0
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX		0xa0
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX0		0
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX1		1
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX2		2
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX3		3
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX4		4
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX5		5
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX6		6
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX7		7
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX8		8
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX9		9
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX10		10
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX11		11
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX12		12
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX13		13
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX14		14
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX15		15
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX0		16
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX1		17
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX2		18
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX3		19
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX4		20
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX5		21
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX6		22
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX7		23
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX8		24
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX9		25
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX10		26
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX11		27
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX12		28
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX13		29
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX14		30
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX15		31
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_1A	0xa4
+#define RZN1_SYSCTRL_REG_RSTSTAT		0xa8
+#define RZN1_SYSCTRL_REG_RSTSTAT_WDA7RST_ST		1
+#define RZN1_SYSCTRL_REG_RSTSTAT_WDA7RST_ST_MASK	0x6
+#define RZN1_SYSCTRL_REG_RSTSTAT_WDM3RST_ST		3
+#define RZN1_SYSCTRL_REG_RSTSTAT_CM3LOCKUPRST_ST	4
+#define RZN1_SYSCTRL_REG_RSTSTAT_CM3SYSRESET_ST		5
+#define RZN1_SYSCTRL_REG_RSTSTAT_SWRST_ST		6
+#define RZN1_SYSCTRL_REG_RSTSTAT_PORRST_ST		31
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_1B	0xb0
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_2A	0xb4
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_2B	0xb8
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC		0xbc
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG0		0
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG0_MASK	0x1f
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG1		8
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG1_MASK	0x1f00
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG2		16
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG2_MASK	0x1f0000
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG3		24
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG3_MASK	0x1f000000
+#define RZN1_SYSCTRL_REG_USBSTAT		0xc0
+#define RZN1_SYSCTRL_REG_USBSTAT_PLL_LOCK		0
+#define RZN1_SYSCTRL_REG_CFG_SDIO1		0xc4
+#define RZN1_SYSCTRL_REG_CFG_SDIO1_BASECLKFREQ		0
+#define RZN1_SYSCTRL_REG_CFG_SDIO1_BASECLKFREQ_MASK	0xff
+#define RZN1_SYSCTRL_REG_CFG_SDIO1_SLOTTYPE		8
+#define RZN1_SYSCTRL_REG_CFG_SDIO1_SLOTTYPE_MASK	0x300
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1		0xc8
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO1		0xcc
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO1_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO1_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO1_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT	0xd0
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_F_SEC	0
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_I_SEC	1
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_Z_SEC	2
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_YD_SEC	3
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_YC_SEC	4
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_YS_SEC	5
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_CSA_SEC	6
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_CSB_SEC	7
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG	0xd4
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_UA_SEC	0
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_UB_SEC	1
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_J_SEC	2
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_K_SEC	3
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_NA_SEC	4
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_NB_SEC	5
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_QA_SEC	6
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_QB_SEC	7
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_RA_SEC	8
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_PC_SEC	9
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_MA_SEC	10
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_MB_SEC	11
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_MC_SEC	12
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_MD_SEC	13
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_W_SEC	14
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_3A	0xd8
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_3B	0xdc
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_3B_PORTEN	0
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_3B_PORTEN_MASK	0x3ff
+#define RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV		0xe0
+#define RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV_DIV_MASK	0x1f
+#define RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV		0xe4
+#define RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV_DIV_MASK	0x7
+#define RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ	0xe8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_Q	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_Q	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_Q	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_R	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_R	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_R	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_S	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_S	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_S	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_T	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_T	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_T	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_U	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_U	13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_U	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_V	15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_V	16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_V	17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_W	18
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_W	19
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_W	20
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_X	21
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_X	22
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_X	23
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2	0xec
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AG1	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AG1	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AG2	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AG2	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AH1	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AH1	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AH2	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AH2	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AI1	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AI1	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AI2	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AI2	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AJ1	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AJ1	13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AJ2	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AJ2	15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AK1	16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AK1	17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AK2	18
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AK2	19
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AL1	20
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AL1	21
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AL2	22
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AL2	23
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_UARTCLKSEL	24
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ	0xf0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_Y	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_Y	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_SLVRDY_Y	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_Z	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_Z	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_SLVRDY_Z	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_AA	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_AA	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_SLVRDY_AA	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_AB	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_AB	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_SLVRDY_AB	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_UF	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_UF	13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_MIREQ_UF	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW		0xf4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_AC	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_AC		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_SLVRDY_AC	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_AD	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_AD		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_SLVRDY_AD	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_AE	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_AE		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_SLVRDY_AE	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_AF	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_AF		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_SLVRDY_AF	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_UI	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_UI		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_MIREQ_UI	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV	0xf8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3	0xfc
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_CLKEN_AM	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_RSTN_AM	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_CLKEN_AN	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_RSTN_AN	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_CLKEN_AO	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_RSTN_AO	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_CLKEN_AP	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_RSTN_AP	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV	0x100
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4	0x104
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_CLKEN_AQ	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_RSTN_AQ	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_CLKEN_AR	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_RSTN_AR	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_CLKEN_AS	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_RSTN_AS	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_CLKEN_AT	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_RSTN_AT	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV	0x108
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1	0x10c
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_CLKEN_AU	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_RSTN_AU	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_CLKEN_AV	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_RSTN_AV	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_CLKEN_AW	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_RSTN_AW	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_CLKEN_AX	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_RSTN_AX	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV	0x110
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6	0x114
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_CLKEN_BC	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_RSTN_BC	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_SLVRDY_BC	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_CLKEN_BD	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_RSTN_BD	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_SLVRDY_BD	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_CLKEN_BE	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_RSTN_BE	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_SLVRDY_BE	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_CLKEN_BF	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_RSTN_BF	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_SLVRDY_BF	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5	0x118
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_CLKEN_AZ	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_RSTN_AZ	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_SLVRDY_AZ	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_CLKEN_BA	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_RSTN_BA	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_SLVRDY_BA	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_CLKEN_BB	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_RSTN_BB	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_SLVRDY_BB	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV	0x11c
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_RSTEN			0x120
+#define RZN1_SYSCTRL_REG_RSTEN_MRESET_EN		0
+#define RZN1_SYSCTRL_REG_RSTEN_WDA7RST_EN		1
+#define RZN1_SYSCTRL_REG_RSTEN_WDA7RST_EN_MASK		0x6
+#define RZN1_SYSCTRL_REG_RSTEN_WDM3RST_EN		3
+#define RZN1_SYSCTRL_REG_RSTEN_CM3LOCKUPRST_EN		4
+#define RZN1_SYSCTRL_REG_RSTEN_CM3SYSRESET_EN		5
+#define RZN1_SYSCTRL_REG_RSTEN_SWRST_EN			6
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV	0x124
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV	0x128
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV	0x12c
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH		0x130
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH_SLVRDY_A	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH_CLKEN_B		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH_RSTN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV	0x134
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV_DIV_MASK	0x3ff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV	0x138
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV	0x13c
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV_DIV	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC		0x140
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC_CLKEN_RTC		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC_RST_RTC		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC_IDLE_REQ		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC_RSTN_FW_RTC	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_RTC		0x144
+#define RZN1_SYSCTRL_REG_PWRSTAT_RTC_RTC_IACK		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_RTC_RTC_IDLE		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_RTC_PWR_GOOD		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV	0x148
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV	0x150
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV_DIV	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV_DIV_MASK	0xf
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_ROM		0x154
+#define RZN1_SYSCTRL_REG_PWRCTRL_ROM_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_ROM_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_ROM_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW		0x158
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_B		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_C		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_D		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_E		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_F		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_G		6
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_H		7
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_I		8
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_J		9
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_K		10
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_L		11
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_M		12
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_N		13
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_O		14
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_P		15
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ	0x15c
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_Q	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_R	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_S	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_T	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_U	4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_V	5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_W	6
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_X	7
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ	0x160
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_SCON_Y	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_SCON_Z	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_SCON_AA	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_SCON_AB	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_MIRACK_UF	4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_MISTAT_UF	5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW		0x164
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_SCON_AC		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_SCON_AD		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_SCON_AE		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_SCON_AF		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_MIRACK_UI	4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_MISTAT_UI	5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG5_PR5	0x168
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG5_PR5_SCON_AZ	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG5_PR5_SCON_BA	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG5_PR5_SCON_BB	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6	0x16c
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6_SCON_BC	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6_SCON_BD	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6_SCON_BE	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6_SCON_BF	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_ROM		0x170
+#define RZN1_SYSCTRL_REG_PWRSTAT_ROM_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_CM3		0x174
+#define RZN1_SYSCTRL_REG_PWRCTRL_CM3_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_CM3_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_CM3_MIREQ_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_CM3		0x178
+#define RZN1_SYSCTRL_REG_PWRSTAT_CM3_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_CM3_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_RINCTRL	0x17c
+#define RZN1_SYSCTRL_REG_PWRSTAT_RINCTRL_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_SWITCHCTRL	0x180
+#define RZN1_SYSCTRL_REG_PWRSTAT_SWITCHCTRL_SCON_A	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_RINCTRL	0x184
+#define RZN1_SYSCTRL_REG_PWRCTRL_RINCTRL_CLKEN_A	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_RINCTRL_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_RINCTRL_SLVRDY_A	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL	0x188
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_CLKEN_A	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_RSTN_A	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_SLVRDY_A	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_RSTN_CLK25	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_RSTN_ETH	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS		0x18c
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_CLKEN_B		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV	0x190
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV_DIV	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV_DIV_MASK	0x3ff
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_RSTCTRL		0x198
+#define RZN1_SYSCTRL_REG_RSTCTRL_WDA7RST_REQ		1
+#define RZN1_SYSCTRL_REG_RSTCTRL_WDA7RST_REQ_MASK	0x6
+#define RZN1_SYSCTRL_REG_RSTCTRL_WDM3RST_REQ		3
+#define RZN1_SYSCTRL_REG_RSTCTRL_CM3LOCKUPRST_REQ	4
+#define RZN1_SYSCTRL_REG_RSTCTRL_CM3SYSRESET_REQ	5
+#define RZN1_SYSCTRL_REG_RSTCTRL_SWRST_REQ		6
+#define RZN1_SYSCTRL_REG_VERSION		0x19c
+#define RZN1_SYSCTRL_REG_VERSION_MINOR			0
+#define RZN1_SYSCTRL_REG_VERSION_MINOR_MASK		0xf
+#define RZN1_SYSCTRL_REG_VERSION_MAJOR			4
+#define RZN1_SYSCTRL_REG_VERSION_MAJOR_MASK		0xf0
+#define RZN1_SYSCTRL_REG_VERSION_PROD			8
+#define RZN1_SYSCTRL_REG_BOOTADDR		0x204
+
+#define RZN1_SYSCTRL_REGSIZE			520
+
+#endif /* __RZN1_SYSCTRL_H__ */
diff --git a/include/renesas/rzn1-utils.h b/include/renesas/rzn1-utils.h
new file mode 100644
index 0000000..15739b4
--- /dev/null
+++ b/include/renesas/rzn1-utils.h
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier:	BSD-2-Clause
+ */
+
+#ifndef __RZN1_UTILS_H__
+#define __RZN1_UTILS_H__
+
+#include <usb.h>
+#include "renesas/rzn1-memory-map.h"
+
+/* System Controller */
+#define sysctrl_readl(addr) \
+	readl(RZN1_SYSTEM_CTRL_BASE + addr)
+#define sysctrl_writel(val, addr) \
+	writel(val, RZN1_SYSTEM_CTRL_BASE + addr)
+
+int rzn1_clk_set_gate(int clkdesc_id, int on);
+void rzn1_clk_reset(int clkdesc_id);
+void rzn1_clk_reset_state(int clkdesc_id, int level);
+
+void rzn1_sysctrl_div(u32 reg, u32 div);
+
+static inline int is_rzn1d(void)
+{
+	u32 ver = sysctrl_readl(RZN1_SYSCTRL_REG_VERSION);
+	if ((ver >> RZN1_SYSCTRL_REG_VERSION_PROD) == 0)
+		return 1;
+	return 0;
+}
+
+/* USB */
+int rzn1_usb_init(int index, enum usb_init_type init);
+
+/* PinMux */
+#define RZN1_DRIVE_SET  	(1 << 31)
+#define RZN1_PULL_SET  		(1 << 30)
+#define RZN1_DRIVE_4MA		(RZN1_DRIVE_SET | (0 << 10))
+#define RZN1_DRIVE_6MA		(RZN1_DRIVE_SET | (1 << 10))
+#define RZN1_DRIVE_8MA		(RZN1_DRIVE_SET | (2 << 10))
+#define RZN1_DRIVE_12MA		(RZN1_DRIVE_SET | (3 << 10))
+#define RZN1_DRIVE_MASK		(3 << 10)
+#define RZN1_PULL_NONE		(RZN1_PULL_SET | (0 << 8))
+#define RZN1_PULL_UP		(RZN1_PULL_SET | (1 << 8))
+#define RZN1_PULL_DOWN		(RZN1_PULL_SET | (3 << 8))
+#define RZN1_PULL_MASK		(3 << 8)
+
+void rzn1_pinmux_set(u32 setting);
+void rzn1_pinmux_select(u8 pin, u32 func, u32 attrib);
+
+/* Ethernet */
+void rzn1_mt5pt_switch_enable_port(int port);
+void rzn1_mt5pt_switch_setup_port_speed(int port, int speed);
+void rzn1_mt5pt_switch_init(void);
+
+void rzn1_rin_prot_writel(u32 val, u32 reg);
+void rzn1_rin_switchcore_setup(int port, int duplex, int speed);
+void rzn1_switch_setup_port_speed(int port, int speed, int enable);
+void rzn1_rgmii_rmii_conv_setup(int phy, u32 if_type, int rmii_ref_clk_out);
+void rzn1_rgmii_rmii_conv_speed(int phy, int duplex, int speed);
+void rzn1_rin_init(void);
+void rzn1_rin_reset_clks(void);
+
+/* DDR */
+#define RZN1_DDR2 2
+#define RZN1_DDR3_SINGLE_BANK 3
+#define RZN1_DDR3_DUAL_BANK 32
+void ddr_phy_init(int ddr_type);
+void ddr_phy_enable_wl(void);
+void rzn1_ddr_ctrl_init(const u32 *reg0, const u32 *reg350, u32 ddr_size);
+
+#endif /* __RZN1_UTILS_H__ */
diff --git a/include/spi.h b/include/spi.h
index deb65ef..adc06ac 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -105,6 +105,7 @@ struct spi_slave {
 	unsigned int max_write_size;
 	void *memory_map;
 	u8 option;
+	u8 addressing_bytes;
 
 	u8 flags;
 #define SPI_XFER_BEGIN		BIT(0)	/* Assert CS before transfer */
@@ -112,6 +113,7 @@ struct spi_slave {
 #define SPI_XFER_ONCE		(SPI_XFER_BEGIN | SPI_XFER_END)
 #define SPI_XFER_MMAP		BIT(2)	/* Memory Mapped start */
 #define SPI_XFER_MMAP_END	BIT(3)	/* Memory Mapped End */
+#define SPI_XFER_MMAP_WRITE	BIT(4)	/* Memory Mapped Write Access */
 };
 
 /**
@@ -315,6 +317,18 @@ static inline int spi_w8r8(struct spi_slave *slave, unsigned char byte)
 	return ret < 0 ? ret : din[1];
 }
 
+#ifdef CONFIG_SPI_REGISTER_FLASH
+/**
+ * Inform the SPI slave that a flash has been allocated
+ * This is used to allow the spi slave to possibly configure
+ * the underlying hardware using the number of address bytes,
+ * number of blocks etc.
+ * @flash:	The flash we are registering
+ */
+struct spi_flash;
+void spi_slave_register_flash(struct spi_flash *flash);
+#endif
+
 /**
  * Set up a SPI slave for a particular device tree node
  *
diff --git a/include/spi_flash.h b/include/spi_flash.h
index be2fe3f..03faef9 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -47,8 +47,10 @@ struct spi_slave;
  * @erase_cmd:		Erase cmd 4K, 32K, 64K
  * @read_cmd:		Read cmd - Array Fast, Extn read and quad read.
  * @write_cmd:		Write cmd - page and quad program.
- * @dummy_byte:		Dummy cycles for read operation.
+ * @dummy_byte:		Dummy bytes for read operation.
+ * @dummy_cycles:	Dummy cycles for read operation.
  * @memory_map:		Address of read-only SPI flash access
+ * @memory_map_write:	Address of write SPI flash access
  * @flash_lock:		lock a region of the SPI Flash
  * @flash_unlock:	unlock a region of the SPI Flash
  * @flash_is_locked:	check if a region of the SPI Flash is completely locked
@@ -83,8 +85,10 @@ struct spi_flash {
 	u8 read_cmd;
 	u8 write_cmd;
 	u8 dummy_byte;
+	u8 dummy_cycles;
 
 	void *memory_map;
+	void *memory_map_write;
 
 	int (*flash_lock)(struct spi_flash *flash, u32 ofs, size_t len);
 	int (*flash_unlock)(struct spi_flash *flash, u32 ofs, size_t len);
diff --git a/include/spl.h b/include/spl.h
index 6e746b2..037a185 100644
--- a/include/spl.h
+++ b/include/spl.h
@@ -130,6 +130,8 @@ int spl_start_uboot(void);
  * This function should be provided by the board.
  */
 void spl_display_print(void);
+void __noreturn spl_load_multi_images(void);
+void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image);
 
 /**
  * struct spl_boot_device - Describes a boot device used by SPL
@@ -250,4 +252,10 @@ int spl_dfu_cmd(int usbctrl, char *dfu_alt_info, char *interface, char *devstr);
 int spl_mmc_load_image(struct spl_image_info *spl_image,
 		       struct spl_boot_device *bootdev);
 
+struct spi_flash *spl_spi_probe(void);
+int spl_spi_load_one_uimage(struct spl_image_info *spl_image,
+	struct spi_flash *flash, u32 offset);
+int spl_nand_load_element(struct spl_image_info *spl_image,
+			  int offset, struct image_header *header);
+
 #endif
diff --git a/scripts/config_whitelist.txt b/scripts/config_whitelist.txt
index 00ee3f1..01fb705 100644
--- a/scripts/config_whitelist.txt
+++ b/scripts/config_whitelist.txt
@@ -160,6 +160,7 @@ CONFIG_ARCH_PXA_IDP
 CONFIG_ARCH_RMOBILE_BOARD_STRING
 CONFIG_ARCH_RMOBILE_EXTRAM_BOOT
 CONFIG_ARCH_RPC
+CONFIG_ARCH_RZN1
 CONFIG_ARCH_S3C2440
 CONFIG_ARCH_SHARK
 CONFIG_ARCH_TEGRA
@@ -177,6 +178,7 @@ CONFIG_ARMADA100_FEC
 CONFIG_ARMADA168
 CONFIG_ARMADA_39X
 CONFIG_ARMCORTEXA9
+CONFIG_ARMV7_NONSEC_AT_BOOT
 CONFIG_ARMV7_PSCI_1_0
 CONFIG_ARMV7_SECURE_BASE
 CONFIG_ARMV7_SECURE_MAX_SIZE
@@ -454,6 +456,9 @@ CONFIG_BUS_WIDTH
 CONFIG_BZIP2
 CONFIG_CACHELINE_ALIGNED_L1
 CONFIG_CADDY2
+CONFIG_CADENCE_DDR_CTRL
+CONFIG_CADENCE_DDR_CTRL_8BIT_WIDTH
+CONFIG_CADENCE_DDR_CTRL_ENABLE_ECC
 CONFIG_CALXEDA_XGMAC
 CONFIG_CAM5200
 CONFIG_CAM5200_NIOSFLASH
@@ -666,6 +671,7 @@ CONFIG_CONTROLCENTERD
 CONFIG_CON_ROT
 CONFIG_CORE1_RUN
 CONFIG_CORE_COUNT
+CONFIG_CORTEX_A7
 CONFIG_CORTINA_FW_ADDR
 CONFIG_CORTINA_FW_LENGTH
 CONFIG_CPCI405
@@ -3819,6 +3825,7 @@ CONFIG_SCSI_DEV_LIST
 CONFIG_SCSI_SYM53C8XX
 CONFIG_SC_TIMER_CLK
 CONFIG_SDCARD
+CONFIG_SDHCI_ARASAN_QUIRKS
 CONFIG_SDRAM_BANK0
 CONFIG_SDRAM_BANK1
 CONFIG_SDRAM_ECC
@@ -3964,6 +3971,7 @@ CONFIG_SMDK5420
 CONFIG_SMDKC100
 CONFIG_SMDKV310
 CONFIG_SMP_PEN_ADDR
+CONFIG_SMP_PEN_WFE
 CONFIG_SMSC_LPC47M
 CONFIG_SMSC_SIO1007
 CONFIG_SMSTP0_ENA
@@ -4050,13 +4058,16 @@ CONFIG_SPI_BOOTING
 CONFIG_SPI_CS_IS_VALID
 CONFIG_SPI_DATAFLASH_WRITE_VERIFY
 CONFIG_SPI_FLASH_ALL
+CONFIG_SPI_FLASH_DUMMY_CYCLES
 CONFIG_SPI_FLASH_ISSI
 CONFIG_SPI_FLASH_QUAD
+CONFIG_SPI_FLASH_READ_QUAD_CMD
 CONFIG_SPI_FLASH_SIZE
 CONFIG_SPI_HALF_DUPLEX
 CONFIG_SPI_IDLE_VAL
 CONFIG_SPI_LENGTH
 CONFIG_SPI_N25Q256A_RESET
+CONFIG_SPI_REGISTER_FLASH
 CONFIG_SPLASHIMAGE_GUARD
 CONFIG_SPLASH_SCREEN
 CONFIG_SPLASH_SCREEN_ALIGN
@@ -4107,6 +4118,7 @@ CONFIG_SPL_NAND_INIT
 CONFIG_SPL_NAND_LOAD
 CONFIG_SPL_NAND_MINIMAL
 CONFIG_SPL_NAND_MXS
+CONFIG_SPL_NAND_ONFI
 CONFIG_SPL_NAND_RAW_ONLY
 CONFIG_SPL_NAND_SIMPLE
 CONFIG_SPL_NAND_SOFTECC
@@ -6386,6 +6398,7 @@ CONFIG_SYS_NAND_BR_PRELIM
 CONFIG_SYS_NAND_BUSWIDTH_16
 CONFIG_SYS_NAND_CE
 CONFIG_SYS_NAND_CLE
+CONFIG_SYS_NAND_CLOCK
 CONFIG_SYS_NAND_CS
 CONFIG_SYS_NAND_CSOR
 CONFIG_SYS_NAND_CSPR
@@ -7393,6 +7406,7 @@ CONFIG_SYS_STACK_LENGTH
 CONFIG_SYS_STACK_SIZE
 CONFIG_SYS_STATUS_C
 CONFIG_SYS_STATUS_OK
+CONFIG_SYS_STAY_IN_SRAM
 CONFIG_SYS_STMICRO_BOOT
 CONFIG_SYS_SUPPORT_64BIT_DATA
 CONFIG_SYS_SXCNFG_VAL
diff --git a/tools/Makefile b/tools/Makefile
index 5b81dde..54a1f7b 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -195,6 +195,10 @@ HOSTCFLAGS_md5.o := -pedantic
 HOSTCFLAGS_sha1.o := -pedantic
 HOSTCFLAGS_sha256.o := -pedantic
 
+ifneq ($(CONFIG_ARCH_RZN1),)
+subdir-$(CONFIG_ARCH_RZN1) += rzn1
+endif
+
 quiet_cmd_wrap = WRAP    $@
 cmd_wrap = echo "\#include <../$(patsubst $(obj)/%,%,$@)>" >$@
 
diff --git a/tools/rzn1/Makefile b/tools/rzn1/Makefile
new file mode 100644
index 0000000..f42c095
--- /dev/null
+++ b/tools/rzn1/Makefile
@@ -0,0 +1,9 @@
+
+# Compile for a hosted environment on the target
+HOST_EXTRACFLAGS  = $(patsubst -I%,-idirafter%, $(UBOOTINCLUDE)) \
+                -idirafter $(srctree)/common/spl \
+                -DUSE_HOSTCC -std=gnu99
+
+hostprogs-y := pkgt_add_entry spkg_utility
+
+always := $(hostprogs-y)
diff --git a/tools/rzn1/pkgt_add_entry.c b/tools/rzn1/pkgt_add_entry.c
new file mode 100644
index 0000000..46c5dff
--- /dev/null
+++ b/tools/rzn1/pkgt_add_entry.c
@@ -0,0 +1,254 @@
+/*
+ * Renesas RZ/N1 Linux tools: pkgt_add_entry.c
+ *
+ * Normally, U-Boot SPL loads a uImage from NAND or SPI Flash from a fixed
+ * offset into the media, and the uImage header contains all the information
+ * needed.
+ * The Renesas RZ/N1 version of U-Boot SPL is different, it can load uImages or
+ * Renesas RPKGs, it can load multiple images and the images can be data, an
+ * executable for the Cortex M3 processor or for the Cortex A7 processor.
+ * In order to do this, it loads a 'Package Table' from a fixed offset into the
+ * media. This program generates the 'Package Table' image, by adding entries
+ * to an existing 'Package Table' image file. If the file doesn't exist, it will
+ * create a new one.
+ *
+ * This software is licensed under the MIT License (MIT), details below.
+ * Copyright (c) 2015 Renesas Electronics Europe Ltd
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <byteswap.h>
+#include <endian.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "pkgt_table.h"
+
+
+static uint32_t
+crc32(const uint8_t *message, uint32_t l)
+{
+	uint32_t crc = ~0;
+
+	while (l--) {
+		uint32_t byte = *message++;		// Get next byte.
+		crc = crc ^ byte;
+		for (int8_t j = 7; j >= 0; j--) {	// Do eight times.
+			uint32_t mask = -(crc & 1);
+			crc = (crc >> 1) ^ (0xEDB88320 & mask);
+		}
+	}
+	return ~crc;
+}
+
+#define OM(_n,_b,_m,_d) \
+	{ .name=_n, .bit=_b, .value=_m, .mask = 0xf, .doc=_d }
+#define O(_n,_b,_d) \
+	{ .name=_n, .bit=_b, .value=1, .mask = 1, .doc=_d }
+const struct {
+	const char * name;
+	const char * doc;
+	int bit : 5;
+	int value : 5;
+	int mask : 5;
+} options[] = {
+	{ .doc = "Options for core selection:" },
+	OM("ca70", PKG_CORE_BIT, PKGT_CORE_CA70,
+		"[default]"),
+	OM("ca71", PKG_CORE_BIT, PKGT_CORE_CA71,
+		"Sets target core to Cortex A7 #1."),
+	OM("cm3", PKG_CORE_BIT, PKGT_CORE_CA71,
+		"Set target core to the the Cortex M3."),
+
+	{ .doc = "Options for package content:" },
+	OM("code", PKG_KIND_BIT, PKGT_KIND_CODE,
+		"Set packet kind to Code. [default]"),
+	OM("dtb", PKG_KIND_BIT, PKGT_KIND_DTB,
+		"Set packet kind to to Device Tree blob."),
+	OM("data", PKG_KIND_BIT, PKGT_KIND_DATA,
+		"Set packet kind to to Data (or initramfs)."),
+
+	{ .doc = "Options for package location:" },
+	OM("same", PKG_SRC_BIT, PKGT_SRC_SAME,
+		"Offset is in Boot flash [default]."),
+	OM("qspi", PKG_SRC_BIT, PKGT_SRC_QSPI,
+		"Offset is QSPI."),
+	OM("nand", PKG_SRC_BIT, PKGT_SRC_NAND,
+		"Offset is in NAND."),
+
+	{ .doc = "Options for package kind:" },
+	OM("u", PKG_TYPE_BIT, PKGT_TYPE_UIMAGE, ""),
+	OM("uimage", PKG_TYPE_BIT, PKGT_TYPE_UIMAGE,
+		"Offset containts a (u-boot) uimage"),
+	OM("rpkg", PKG_TYPE_BIT, PKGT_TYPE_RPKG,
+		"Is a Renesas Signed RPKG."),
+	OM("spkg", PKG_TYPE_BIT, PKGT_TYPE_SPKG,
+		"Is a Renesas SPKG (can be unsigned) [default]."),
+	OM("raw", PKG_TYPE_BIT, PKGT_TYPE_RAW,
+		"Offset has no headers."),
+
+	{ .doc = "Modifier flags:" },
+	O("backup", PKG_BACKUP_BIT,
+		"Mark this entry as an alternate to load in case\n"
+		"\tThe primary one has not been loaded due to errors."),
+	O("nonsec", PKG_NONSEC_BIT,
+		"Switch to NONSEC mode for this code blob."),
+	O("hyp", PKG_HYP_BIT,
+		"Switch to HYP mode for this code blob."),
+	O("nocrc", PKG_NOCRC_BIT,
+		"Don't check SPKG payload CRC."),
+	O("initramfs", PKG_INITRAMFS_BIT,
+		"Data payload is a linux initramfs."),
+	O("alt", PKG_ALT_BIT,
+		"Code is alternative payload (u-boot)."),
+
+	{ 0 }, /* trailer */
+};
+
+static void print_usage(
+	char * progname, int exitcode)
+{
+	printf("RZ/N1: Add an entry to the U-Boot/SPL Package Table.\n");
+	printf("Use:\n");
+	printf("  %s [<options>] -offset <offset> <file>\n", progname);
+
+	for (int i = 0; options[i].doc; i++) {
+		if (options[i].name)
+			printf("  -%-9.9s %s\n",
+				options[i].name, options[i].doc);
+		else
+			printf(" %s\n", options[i].doc);
+	}
+	printf(" Mandatory options:\n");
+	printf("  -offset <offset>  Offset in source (hex)\n");
+	printf("  <file>    Filename of PKG Table file to be extended, or written if it doesn't exist.\n");
+	printf(" (Table size is %ld bytes; with redundancy of %d it is %ld total)\n",
+		sizeof(struct pkg_table), PKGT_REDUNDANCY_COUNT,
+		sizeof(struct pkg_table) * PKGT_REDUNDANCY_COUNT);
+	exit(exitcode);
+}
+
+int main(int argc, char *argv[])
+{
+	struct pkg_entry *entry;
+	struct pkg_table table = { };
+	const char *image_name = NULL;
+	FILE *fp;
+	uint8_t corrupt = 0;
+	uint32_t offset = ~0;
+	uint32_t pkgt = PKGT_TYPE_SPKG << PKG_TYPE_BIT;
+	int pkg_count = 0, i;
+
+	for (int i = 1; i < argc; i++) {
+		char *p = argv[i];
+
+		/* treat --<param> same as -<param> */
+		if (!strncmp(p, "--", 2))
+			p++;
+		if (p[0] == '-') {
+			for (int i = 0; options[i].doc; i++)
+				if (options[i].name &&
+						!strcmp(p + 1, options[i].name)) {
+					pkgt &= ~(options[i].mask << options[i].bit);
+					pkgt |= options[i].value << options[i].bit;
+					goto next;
+				}
+		}
+		if (!strcmp(p, "-debug-corrupt"))
+			corrupt++;
+		else if (!strncmp(p, "-o", 2) && i < argc-1) {
+			char *endptr;
+			i++;
+			offset = strtoul(argv[i], &endptr, 0);
+		} else if (!strncmp(p, "-h", 2))
+			print_usage(argv[0], 0);
+		else if (p[0] == '-' || image_name) {
+			fprintf(stderr, "%s invalid argument '%s' -- use --help\n",
+				argv[0], argv[i]);
+			exit(1);
+		} else
+			image_name = argv[i];
+	next: ;
+	}
+	if (!image_name) {
+		fprintf(stderr, "%s missing filename -- use --help\n",
+			argv[0]);
+		exit(1);
+	}
+	if (offset == ~0) {
+		fprintf(stderr, "%s invalid offset -- use --help\n",
+			argv[0]);
+		exit(1);
+	}
+
+	/* If the file exists, read it in */
+	if (access(image_name, F_OK) != -1) {
+		size_t len;
+		fp = fopen(image_name, "rb");
+		len = fread(&table, 1, sizeof(table), fp);
+		fclose(fp);
+
+		if (len != sizeof(table)) {
+			fprintf(stderr, "%s file is too short!\n", image_name);
+			exit(1);
+		}
+		if (table.magic != PKGT_MAGIC) {
+			fprintf(stderr, "%s file does not have the magic number!\n",
+				image_name);
+			exit(1);
+		}
+		pkg_count = (table.pkgt >> PKGT_COUNT_BIT) & (PKGT_MAX_TBL_ENTRIES-1);
+		if (pkg_count == PKGT_MAX_TBL_ENTRIES - 1) {
+			fprintf(stderr, "%s is full (%d entries)!\n",
+				image_name, PKGT_MAX_TBL_ENTRIES);
+			exit(1);
+		}
+	}
+
+	entry = &table.entries[pkg_count];
+	entry->pkg = pkgt;
+	entry->offset   = offset;
+	/* Now update table header */
+	table.magic = PKGT_MAGIC;
+	table.pkgt &= ~((PKGT_MAX_TBL_ENTRIES-1) << PKGT_COUNT_BIT);
+	table.pkgt |= (pkg_count + 1) << PKGT_COUNT_BIT;
+	table.crc = 0;
+	table.crc = crc32((uint8_t*)&table, sizeof(table));
+
+	fp = fopen(image_name, "wb");
+	if (!fp) {
+		perror(image_name);
+		exit(1);
+	}
+	for (i = 0; i < PKGT_REDUNDANCY_COUNT; i++) {
+		struct pkg_table w = table;
+		/* if debugging, corrupt the first entr(ies) to validate SPL
+		 * error recovery. Pass -debug-corrupt multiple times to
+		 * corrupt extra headers */
+		if (corrupt--)
+			w.crc = 0xcafef00d;
+		fwrite(&w, 1, sizeof(w), fp);
+	}
+	fclose(fp);
+}
diff --git a/tools/rzn1/spkg_utility.c b/tools/rzn1/spkg_utility.c
new file mode 100644
index 0000000..e5080a7
--- /dev/null
+++ b/tools/rzn1/spkg_utility.c
@@ -0,0 +1,397 @@
+/*
+ * This is a utility to create a SPKG file.
+ * It packages the binary code into the SPKG.
+ *
+ * (C) Copyright 2016 Renesas Electronics Europe Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#define _GNU_SOURCE /* for strdupa */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <libgen.h>
+#include <string.h>
+
+#include "spkg_header.h"
+
+#define MAX_PATH		300
+#define MAX_CONFIG_NAME_SIZE	50
+#define MAX_CONFIG_LINE_SIZE	500
+
+// Note: Order of bit fields is not used, this is purely just holding the SPKG information.
+struct spkg_header {
+	char config_filename[MAX_PATH];
+	char input[MAX_PATH];
+	char output[MAX_PATH];
+	unsigned int version:4;
+	unsigned int ecc_enable:1;
+	unsigned int ecc_block_size:2;
+	unsigned int ecc_scheme:3;
+	unsigned int ecc_bytes:8;
+	unsigned int dummy_blp_length : 10;
+	unsigned int payload_length:24;
+	unsigned int spl_nonsec : 1;
+	unsigned int spl_hyp : 1;
+	unsigned int load_address;
+	unsigned int execution_offset;
+	uint32_t padding;
+};
+
+struct spkg_header g_header = {
+	.version = 1,
+	.padding = 256,
+};
+
+int verbose = 0;
+
+/* strip traling spaces and end of lines from string _ptr */
+#define strip_trailing(_ptr) { \
+	while ((_ptr) && *(_ptr) && (_ptr)[strlen((_ptr))-1] <= ' ') \
+		(_ptr)[strlen((_ptr))-1] = 0; \
+	}
+/* strip leading spaces */
+#define strip_leading(_ptr) \
+	while ((_ptr) && (*(_ptr) == ' ' || *(_ptr) == '\t')) (_ptr)++;
+
+static uint32_t
+crc32(const uint8_t *message, uint32_t l)
+{
+	uint32_t crc = ~0;
+
+	while (l--) {
+		uint32_t byte = *message++;		// Get next byte.
+		crc = crc ^ byte;
+		for (int8_t j = 7; j >= 0; j--) {	// Do eight times.
+			uint32_t mask = -(crc & 1);
+			crc = (crc >> 1) ^ (0xEDB88320 & mask);
+		}
+	}
+	return ~crc;
+}
+
+static int spkg_write(
+	struct spkg_header *h,
+	FILE * file_Input,
+	FILE * file_SPKG)
+{
+	int i;
+	uint32_t length_inputfile;
+	uint32_t length_read;
+	uint32_t length_written;
+	uint32_t length_total;
+	uint32_t padding = 0;
+	uint8_t *pData, *start;
+	uint32_t crc;
+
+	/* Calculate length of input file */
+	fseek(file_Input, 0, SEEK_END);	// seek to end of file
+	length_inputfile = ftell(file_Input);	// get current file pointer
+	fseek(file_Input, 0, SEEK_SET);	// seek back to beginning of file
+
+	/* Set payload_length field. */
+	h->payload_length =
+	    length_inputfile + h->dummy_blp_length + SPKG_HEADER_CRC_SIZE;
+
+	/* Calculate total length of SPKG */
+	length_total =
+	    (SPKG_HEADER_SIZE * SPKG_HEADER_COUNT) + h->dummy_blp_length +
+	    length_inputfile + SPKG_HEADER_CRC_SIZE;
+	padding = h->padding ? h->padding - (length_total % h->padding) : 0;
+	length_total += padding;
+	/* Padding needs to be part of the payload size, otherwise the ROM DFU
+	 * refuses to accept the extra bytes and return and error. */
+	h->payload_length += padding;
+
+	printf("Addr: 0x%08x ", h->load_address);
+	printf("In: %8d ", length_inputfile);
+	printf("padding to %3dKB: %6d ", h->padding / 1024, padding);
+	printf("Total: 0x%08x ", length_total);
+	printf("%s\n", basename(strdupa(h->output)));
+
+	/* Create and zero array for SPKG */
+	pData = malloc(length_total);
+	memset(pData, 0, length_total);
+
+	/* Fill the SPKG with the headers */
+	{
+		struct spkg_hdr head = {
+			.signature = SPKG_HEADER_SIGNATURE,
+			.version = h->version,
+			.ecc = (h->ecc_enable << 5) | (h->ecc_block_size << 1),
+			.ecc_scheme = h->ecc_scheme,
+			.ecc_bytes = h->ecc_bytes,
+			.payload_length = htole32((h->payload_length << 8) |
+				(h->spl_nonsec << SPKG_CODE_NONSEC_BIT) |
+				(h->spl_hyp << SPKG_CODE_HYP_BIT)),
+			.load_address = htole32(h->load_address),
+			.execution_offset = htole32(h->execution_offset),
+		};
+
+		head.crc = crc32((uint8_t*)&head, sizeof(head) - SPKG_HEADER_CRC_SIZE);
+		for (i = 0; i < SPKG_HEADER_COUNT; i++)
+			((struct spkg_hdr*)pData)[i] = head;
+	}
+
+	start = pData + INDEX_BLP_START;
+
+	/* Fill the SPKG with the Dummy BLp */
+	for (i = 0; i < h->dummy_blp_length; i++)
+		*start++ = 0x88;
+	/* Fill the SPKG with the data from the code file. */
+	length_read =
+	    fread(start, sizeof(char), length_inputfile,
+		  file_Input);
+
+	if (length_read != length_inputfile) {
+		fprintf(stderr, "Error reading %s: ferror=%d, feof=%d \n",
+		       h->input, ferror(file_Input), feof(file_Input));
+
+		return -1;
+	}
+	/* fill padding with flash friendly one bits */
+	memset(start + length_inputfile + SPKG_HEADER_CRC_SIZE, 0xff, padding);
+
+	/* Add Payload CRC */
+	crc = crc32(&pData[INDEX_BLP_START],
+		     h->dummy_blp_length + length_inputfile + padding);
+
+	start += length_inputfile + padding;
+	start[0] = crc;
+	start[1] = crc >> 8;
+	start[2] = crc >> 16;
+	start[3] = crc >> 24;
+
+	/* Write the completed SKPG to file */
+	length_written = fwrite(pData, sizeof(char), length_total, file_SPKG);
+
+	if (length_written != length_total) {
+		fprintf(stderr, "Error writing to %s\n", h->output);
+		return -1;
+	}
+
+
+	return 0;
+}
+
+const char * usage =
+	"%s\n"
+	"  [--config <filename]	: read configuration from <filename>\n"
+	"  [-i <filename>]	: input file\n"
+	"  [-o <filename>]	: output file\n"
+	"  [--load_address <hex constant>] : code load address\n"
+	"  [--execution_offset <hex constant>] : starting offset\n"
+	"  [--nand_ecc_enable] : Enable nand ECC\n"
+	"  [--nand_ecc_blksize <hex constant>] : Block size code\n"
+	"        0=256 bytes, 1=512 bytes, 2=1024 bytes\n"
+	"  [--nand_ecc_scheme <hex constant>] : ECC scheme code\n"
+	"        0=BCH2 1=BCH4 2=BCH8 3=BCH16 4=BCH24 5=BCH32\n"
+	"  [--add_dummy_blp] : Add a passthru BLP\n"
+	"  [--spl_nonsec] : Code package run in NONSEC\n"
+	"  [--spl_hyp] : Code package run in HYP (and NONSEC)\n"
+	"  [--padding <value>[K|M]] : Pass SPKG to <value> size block\n"
+	;
+
+static int spkg_parse_option(
+	struct spkg_header *h,
+	const char * name,
+	const char * sz,
+	uint32_t value )
+{
+//	printf("%s %s=%s %08x\n", __func__, name, sz, value);
+	if (!strcmp("file_input", name) || !strcmp("i", name))
+		strncpy(h->input, sz, sizeof(h->input));
+	else if (!strcmp("file_output", name) || !strcmp("o", name))
+		strncpy(h->output, sz, sizeof(h->output));
+	else if (!strcmp("config", name) && !h->config_filename[0])
+		strncpy(h->config_filename, name, sizeof(h->config_filename));
+	else if (!strcmp("version", name))
+		h->version = value;
+	else if (!strcmp("load_address", name))
+		h->load_address = value;
+	else if (!strcmp("execution_offset", name))
+		h->execution_offset = value;
+	else if (!strcmp("nand_ecc_enable", name))
+		h->ecc_enable = value;
+	else if (!strcmp("nand_ecc_blksize", name))
+		h->ecc_block_size = value;
+	else if (!strcmp("nand_ecc_scheme", name))
+		h->ecc_scheme = value;
+	else if (!strcmp("nand_bytes_per_ecc_block", name))
+		h->ecc_bytes = value;
+	else if (!strcmp("add_dummy_blp", name))
+		h->dummy_blp_length = value ? SPKG_BLP_SIZE : 0;
+	else if (!strcmp("spl_nonsec", name))
+		h->spl_nonsec = !!value;
+	else if (!strcmp("spl_hyp", name))
+		h->spl_hyp = !!value;
+	else if (!strcmp("help", name) || !strcmp("h", name)) {
+		fprintf(stderr, usage, "spkg_utility");
+		exit(0);
+	} else if (!strcmp("padding", name) && sz && value) {
+		if (strchr(sz, 'K'))
+			h->padding = value * 1024;
+		else if (strchr(sz, 'M'))
+			h->padding = value * 1024 * 1024;
+		else
+			h->padding = value;
+	} else
+		return -1;
+	return 0;
+}
+
+/*
+ * Read a configuration file for the SPKG header.
+ * NOTE: The length field should not be specified in the config file because it is calculated.
+ * Config file format: (Note Values can be are specified in HEX if preceded with 0x)
+ * name = Value
+ * name = Value
+  ...
+*/
+static int spkg_read_config(FILE * file, struct spkg_header *h)
+{
+	char line[MAX_CONFIG_LINE_SIZE];
+
+	do {
+		char * ptr = line;
+		unsigned long int value = 0;
+
+		if (!fgets(ptr, MAX_CONFIG_LINE_SIZE, file)) {
+			if (feof(file))
+				return 0;
+			else {
+				perror(__func__);
+				return -1;
+			}
+		}
+		strip_leading(ptr);
+		strip_trailing(ptr);
+
+		/* Check for a comment line */
+		if (!strncmp(ptr, "//", 2))
+			continue;
+
+		/* Check for a blank line */
+		if (strlen(ptr) < 4) {
+			/*Don't parse this line */
+			continue;
+		}
+		char * sz = ptr;
+		char * name = strsep(&sz, "=");
+
+		if (!name) {
+			fprintf(stderr, "%s invalid argument '%s'\n",
+				__func__, line);
+			return -1;
+		}
+		strip_trailing(name);
+		strip_leading(sz);
+
+		if (!sscanf(sz, "0x%lx", &value))
+			sscanf(sz, "%lu", &value);
+
+		if (spkg_parse_option(h, name, sz, value)) {
+			fprintf(stderr, "%s Error invalid '%s'\n", __func__,  name);
+			return -1;
+		}
+
+	} while (1);
+}
+
+
+int main(int argc, char *argv[])
+{
+	FILE *file_SPKG = NULL;
+	FILE *file_Input = NULL;
+	int result = -1;
+
+	if (argc == 2 && argv[1][0] != '-') {
+		strncpy(g_header.config_filename, argv[1],
+			sizeof(g_header.config_filename));
+	} else {
+		for (int i = 1; i < argc; i++) {
+			unsigned long int value = 0;
+			char * ptr = strdup(argv[i]);
+			char * sz = ptr;
+			char * name = strsep(&sz, "=");
+
+			if (!name || name[0] != '-') {
+				fprintf(stderr, "%s invalid argument '%s'\n",
+					argv[0], argv[i]);
+				return -1;
+			}
+			name++;
+			if (name[0] == '-')
+				name++;
+			strip_trailing(name);
+			strip_leading(sz);
+
+			if (!sz && i < argc - 1 && argv[i+1][0] != '-')
+				sz = argv[++i];
+
+			if (sz) {
+				if (!sscanf(sz, "0x%lx", &value))
+					sscanf(sz, "%lu", &value);
+			} else {
+				value = 1;
+			}
+			if (spkg_parse_option(&g_header, name, sz, value)) {
+				fprintf(stderr, "%s Error invalid '%s'\n",
+					argv[0],  argv[i]);
+				return -1;
+			}
+		}
+	}
+
+	if (g_header.config_filename[0]) {
+		FILE *config = fopen(g_header.config_filename, "r");
+
+		if (!config) {
+			perror(g_header.config_filename);
+			exit(1);
+		}
+
+		if (spkg_read_config(config, &g_header)) {
+			fprintf(stderr, "%s Invalid config: %s\n",
+				argv[0], g_header.config_filename);
+			exit(1);
+		}
+		fclose(config);
+	}
+	if (!g_header.input[0]) {
+		fprintf(stderr, usage, argv[0]);
+		exit(1);
+	}
+	if (!g_header.output[0])
+		snprintf(g_header.output, sizeof(g_header.output),
+			"%s.spkg", g_header.input);
+	if (verbose)
+		printf("%s -> %s\n", g_header.input, g_header.output);
+	/*NOTE: Using binary mode as this seems necessary if running in Windows */
+	file_SPKG = fopen(g_header.output, "wb");
+	file_Input = fopen(g_header.input, "rb");
+
+	if (!file_SPKG)
+		perror(g_header.output);
+	if (!file_Input)
+		perror(g_header.input);
+
+	if (file_Input && file_SPKG)
+		result = spkg_write(&g_header, file_Input, file_SPKG);
+
+	if (file_SPKG)
+		fclose(file_SPKG);
+	if (file_Input)
+		fclose(file_Input);
+
+	if (result >= 0) {
+		if (verbose)
+			printf("%s created \n", g_header.output);
+	} else
+		fprintf(stderr, "ERROR creating %s\n", g_header.output);
+
+	return result;
+
+}
+
